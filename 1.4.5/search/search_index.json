{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python Manta","text":"<p>Python bindings for the dotabuff/manta Dota 2 replay parser</p> AI Summary <pre><code>Python Manta lets you parse Dota 2 replay files (.dem) in Python. Install with `pip install python-manta`. The library wraps the Go-based manta parser and provides:\n</code></pre> <ul> <li>Header/draft parsing for match metadata</li> <li>272 message callbacks for any replay data</li> <li>Game events (364 types), combat log, modifiers, entity queries</li> <li>Pydantic models for type-safe data access</li> </ul> <p>Quick start: <code>from python_manta import MantaParser; parser = MantaParser(); header = parser.parse_header(\"match.dem\")</code></p>"},{"location":"#what-is-python-manta","title":"What is Python Manta?","text":"<p>Python Manta provides Python access to the Manta Go library for parsing Dota 2 replay files. All parsing is done by Manta - this library provides:</p> <ol> <li>CGO bindings - Wraps the Go parser as a shared library</li> <li>Pythonic API - Clean, intuitive interface via <code>MantaParser</code></li> <li>Type safety - Pydantic models for all parsed data</li> <li>Comprehensive access - All 272 Manta callbacks + specialized APIs</li> </ol>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-manta\n</code></pre> <p>Pre-built wheels available for Linux, macOS (Intel + Apple Silicon), and Windows.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get match metadata\nheader = parser.parse_header(\"match.dem\")\nprint(f\"Map: {header.map_name}, Build: {header.build_num}\")\n\n# Get game info (draft, players, teams)\ngame_info = parser.parse_game_info(\"match.dem\")\nfor pb in game_info.picks_bans:\n    action = \"PICK\" if pb.is_pick else \"BAN\"\n    print(f\"{action}: Hero {pb.hero_id}\")\n\n# Parse chat messages\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\nfor msg in result.messages:\n    print(f\"[{msg.tick}] {msg.data}\")\n</code></pre>"},{"location":"#features-overview","title":"Features Overview","text":"Feature Method Description Header <code>parse_header()</code> Match metadata (map, build, server) Game Info <code>parse_game_info()</code> Draft, players, teams, league Messages <code>parse_universal()</code> Any of 272 message types Game Events <code>parse_game_events()</code> 364 named event types Combat Log <code>parse_combat_log()</code> Damage, heals, kills Modifiers <code>parse_modifiers()</code> Buffs, debuffs, auras Entities <code>query_entities()</code> Hero/unit state queries Positions <code>parse_entities()</code> Hero positions over time String Tables <code>get_string_tables()</code> Player info, baselines"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>API Reference - Complete API documentation</li> <li>Guides - In-depth feature guides</li> <li>Examples - Real-world code examples</li> <li>Callbacks Reference - All 272 supported callbacks</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Original Manta (Go)</li> </ul>"},{"location":"examples/","title":"Examples","text":"AI Summary <p>Complete working examples for common Dota 2 replay analysis tasks. All examples use TI 2025 Grand Finals Game 5 (XG vs Falcons, Match ID: 8461956309) as the reference replay. Includes: match summary generator (header + draft + final stats), kill timeline builder, item build tracker (via combat log type 11), item usage tracker (combat log type 6), Lotus Orb detection (ability triggers type 13), neutral item tracker (pickups via FoundNeutralItem, usage via combat log, buffs via modifiers), ward placement analyzer, damage report generator, rune tracking, and defensive item analysis (Outworld Staff vs Omnislash). Each example demonstrates combining multiple API methods for real analysis workflows.</p>"},{"location":"examples/#example-match-ti-2025-grand-finals-game-5","title":"Example Match: TI 2025 Grand Finals Game 5","text":"<p>All examples in this documentation use The International 2025 Grand Finals Game 5 as the reference replay:</p> Property Value Match ID 8461956309 Event The International 2025 Grand Finals Teams Xtreme Gaming (XG) vs Team Falcons (FLCN) Winner Falcons (Dire) Duration 77.9 minutes Server Valve TI14 Server (Hamburg) <p>XG (Radiant): - Ame: Juggernaut - Xm: Shadow Fiend - Xxs: Earthshaker - XinQ: Shadow Demon - xNova: Pugna</p> <p>Falcons (Dire): - Sneyking: Naga Siren - skiter: Medusa - Malr1ne: Pangolier - AMMAR_THE_F: Magnus - Cr1t-: Disruptor</p>"},{"location":"examples/#match-summary","title":"Match Summary","text":"<p>Extract a complete match summary with draft, players, and final scores.</p> <pre><code>from python_manta import MantaParser\n\ndef generate_match_summary(demo_path: str):\n    parser = MantaParser()\n\n    # Get header\n    header = parser.parse_header(demo_path)\n    print(f\"Match Summary\")\n    print(f\"{'='*50}\")\n    print(f\"Map: {header.map_name}\")\n    print(f\"Build: {header.build_num}\")\n    print(f\"Server: {header.server_name}\")\n\n    # Get game info (draft)\n    game_info = parser.parse_game_info(demo_path)\n    print(f\"\\nDraft:\")\n    print(\"-\" * 30)\n\n    radiant_picks = []\n    dire_picks = []\n    for event in game_info.picks_bans:\n        if event.is_pick:\n            if event.team == 2:\n                radiant_picks.append(event.hero_id)\n            else:\n                dire_picks.append(event.hero_id)\n\n    print(f\"Radiant picks: {radiant_picks}\")\n    print(f\"Dire picks: {dire_picks}\")\n\n    # Get final hero stats\n    heroes = parser.query_entities(\n        demo_path,\n        class_filter=\"Hero\",\n        property_filter=[\n            \"m_iCurrentLevel\", \"m_iKills\", \"m_iDeaths\", \"m_iAssists\",\n            \"m_iTotalEarnedGold\", \"m_iLastHits\", \"m_iTeamNum\"\n        ],\n        max_entities=10\n    )\n\n    print(f\"\\nFinal Scoreboard:\")\n    print(\"-\" * 70)\n    print(f\"{'Hero':&lt;35} {'Lvl':&gt;4} {'K':&gt;3} {'D':&gt;3} {'A':&gt;3} {'LH':&gt;5} {'Gold':&gt;7}\")\n    print(\"-\" * 70)\n\n    radiant = []\n    dire = []\n    for hero in heroes.entities:\n        p = hero.properties\n        team = p.get(\"m_iTeamNum\", 0)\n        stats = (hero.class_name, p.get(\"m_iCurrentLevel\", 0), p.get(\"m_iKills\", 0),\n                 p.get(\"m_iDeaths\", 0), p.get(\"m_iAssists\", 0), p.get(\"m_iLastHits\", 0),\n                 p.get(\"m_iTotalEarnedGold\", 0))\n\n        if team == 2:\n            radiant.append(stats)\n        elif team == 3:\n            dire.append(stats)\n\n    print(\"RADIANT:\")\n    for name, lvl, k, d, a, lh, gold in radiant:\n        print(f\"  {name:&lt;33} {lvl:&gt;4} {k:&gt;3} {d:&gt;3} {a:&gt;3} {lh:&gt;5} {gold:&gt;7,}\")\n\n    print(\"\\nDIRE:\")\n    for name, lvl, k, d, a, lh, gold in dire:\n        print(f\"  {name:&lt;33} {lvl:&gt;4} {k:&gt;3} {d:&gt;3} {a:&gt;3} {lh:&gt;5} {gold:&gt;7,}\")\n\n# Usage\ngenerate_match_summary(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals Game 5): <pre><code>Match Summary\n==================================================\nMap: start\nBuild: 10512\nServer: Valve TI14 Server (srcds427-fra2.Hamburg.5)\n\nMatch ID: 8461956309\nDuration: 77.9 minutes\nWinner: Dire\n\nTeams:\n  Radiant: XG (ID: 8261500)\n  Dire: FLCN (ID: 9247354)\n\nDraft:\n  Radiant picks: [7, 79, 11, 45, 8]  # Juggernaut, Shadow Fiend, Shadow Demon, Pugna, Earthshaker\n  Dire picks: [89, 120, 87, 94, 97]  # Naga Siren, Pangolier, Disruptor, Medusa, Magnus\n\nPlayers:\n  [Radiant] Ame: juggernaut\n  [Radiant] Xm: nevermore\n  [Radiant] Xxs: earthshaker\n  [Radiant] XinQ: shadow_demon\n  [Radiant] xNova: pugna\n  [Dire] Sneyking: naga_siren\n  [Dire] skiter: medusa\n  [Dire] Malr1ne: pangolier\n  [Dire] AMMAR_THE_F: magnataur\n  [Dire] Cr1t-: disruptor\n</code></pre></p>"},{"location":"examples/#kill-timeline","title":"Kill Timeline","text":"<p>Build a chronological kill feed with timestamps.</p> <pre><code>from python_manta import MantaParser\n\ndef build_kill_timeline(demo_path: str):\n    parser = MantaParser()\n\n    # Use game events for kills\n    result = parser.parse_game_events(\n        demo_path,\n        event_filter=\"dota_player_kill\",\n        max_events=500\n    )\n\n    print(\"Kill Timeline\")\n    print(\"=\" * 60)\n\n    for event in result.events:\n        tick = event.tick\n        fields = event.fields\n\n        victim = fields.get(\"victim_userid\", \"?\")\n        killer = fields.get(\"killer1_userid\", \"?\")\n\n        # Collect assisters\n        assisters = []\n        for i in range(2, 6):\n            a = fields.get(f\"killer{i}_userid\")\n            if a:\n                assisters.append(str(a))\n\n        # Format output\n        assist_str = f\" + {', '.join(assisters)}\" if assisters else \"\"\n        print(f\"[Tick {tick:&gt;7}] Player {killer}{assist_str} killed Player {victim}\")\n\n    print(f\"\\nTotal kills: {len(result.events)}\")\n\n# Usage\nbuild_kill_timeline(\"match.dem\")\n</code></pre>"},{"location":"examples/#item-build-tracker","title":"Item Build Tracker","text":"<p>Track item purchases for each player throughout the match using combat log.</p> <pre><code>from python_manta import MantaParser, CombatLogType\nfrom collections import defaultdict\n\ndef track_item_builds(demo_path: str):\n    parser = MantaParser()\n\n    # Item purchases are in combat log PURCHASE type\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.PURCHASE],\n        max_entries=2000\n    )\n\n    # Group by hero\n    hero_items = defaultdict(list)\n\n    for entry in result.entries:\n        hero = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.value_name.replace(\"item_\", \"\")\n\n        # Calculate game time\n        mins = int(abs(entry.game_time) // 60)\n        secs = int(abs(entry.game_time)) % 60\n        sign = \"-\" if entry.game_time &lt; 0 else \"\"\n\n        hero_items[hero].append({\n            \"time\": f\"{sign}{mins:02d}:{secs:02d}\",\n            \"item\": item,\n            \"game_time\": entry.game_time\n        })\n\n    print(\"Item Build Order by Hero\")\n    print(\"=\" * 60)\n\n    for hero in sorted(hero_items.keys()):\n        items = hero_items[hero]\n        print(f\"\\n{hero}: ({len(items)} items)\")\n        print(\"-\" * 50)\n\n        for i, item in enumerate(items, 1):\n            print(f\"  {i:&gt;3}. [{item['time']}] {item['item']}\")\n\n# Usage\ntrack_item_builds(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals - Ame's Juggernaut build): <pre><code>Item Build Order by Hero\n============================================================\n\njuggernaut: (54 items)\n--------------------------------------------------\n    1. [01:04] recipe_wraith_band\n    2. [01:54] wraith_band\n    3. [02:06] boots_of_elves\n    4. [03:35] gloves\n    5. [04:53] boots\n    6. [05:32] power_treads          # Power Treads at 5:32\n    7. [08:05] cornucopia\n    8. [09:36] broadsword\n    9. [12:01] broadsword\n   10. [13:17] recipe_bfury\n   11. [13:44] bfury                 # Battle Fury at 13:44\n   12. [14:18] blade_of_alacrity\n   13. [15:14] boots_of_elves\n   14. [15:31] recipe_yasha\n   15. [16:11] yasha\n   16. [16:56] diadem\n   17. [19:20] recipe_manta\n   18. [19:44] manta                 # Manta Style at 19:44\n   19. [22:56] eagle\n   20. [24:19] claymore\n   21. [25:56] talisman_of_evasion\n   22. [26:40] butterfly             # Butterfly at 26:40\n   ...\n</code></pre></p>"},{"location":"examples/#ward-placement-analyzer","title":"Ward Placement Analyzer","text":"<p>Analyze ward placement patterns from pings and events.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef analyze_wards(demo_path: str):\n    parser = MantaParser()\n\n    # Get ward-related entities at end of game\n    wards = parser.query_entities(\n        demo_path,\n        class_filter=\"Ward\",\n        property_filter=[\"m_vecOrigin\", \"m_iTeamNum\", \"m_iHealth\"],\n        max_entities=100\n    )\n\n    print(\"Ward Analysis\")\n    print(\"=\" * 50)\n\n    radiant_wards = []\n    dire_wards = []\n\n    for ward in wards.entities:\n        pos = ward.properties.get(\"m_vecOrigin\", [0, 0, 0])\n        team = ward.properties.get(\"m_iTeamNum\", 0)\n        alive = ward.properties.get(\"m_iHealth\", 0) &gt; 0\n\n        ward_info = {\n            \"class\": ward.class_name,\n            \"position\": (pos[0], pos[1]),\n            \"alive\": alive\n        }\n\n        if team == 2:\n            radiant_wards.append(ward_info)\n        elif team == 3:\n            dire_wards.append(ward_info)\n\n    print(f\"\\nRadiant wards (end of game): {len(radiant_wards)}\")\n    for w in radiant_wards:\n        status = \"ALIVE\" if w[\"alive\"] else \"dead\"\n        print(f\"  {w['class']}: ({w['position'][0]:.0f}, {w['position'][1]:.0f}) [{status}]\")\n\n    print(f\"\\nDire wards (end of game): {len(dire_wards)}\")\n    for w in dire_wards:\n        status = \"ALIVE\" if w[\"alive\"] else \"dead\"\n        print(f\"  {w['class']}: ({w['position'][0]:.0f}, {w['position'][1]:.0f}) [{status}]\")\n\n# Usage\nanalyze_wards(\"match.dem\")\n</code></pre>"},{"location":"examples/#damage-report","title":"Damage Report","text":"<p>Generate a damage breakdown by hero and ability.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef generate_damage_report(demo_path: str):\n    parser = MantaParser()\n\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[0],  # Damage only\n        heroes_only=True,\n        max_entries=10000\n    )\n\n    # Aggregate damage by attacker\n    damage_dealt = defaultdict(int)\n    damage_taken = defaultdict(int)\n    ability_damage = defaultdict(lambda: defaultdict(int))\n\n    for entry in result.entries:\n        if entry.is_attacker_hero:\n            damage_dealt[entry.attacker_name] += entry.value\n\n            if entry.inflictor_name:\n                ability_damage[entry.attacker_name][entry.inflictor_name] += entry.value\n\n        if entry.is_target_hero:\n            damage_taken[entry.target_name] += entry.value\n\n    print(\"Damage Report\")\n    print(\"=\" * 60)\n\n    print(\"\\nTotal Damage Dealt:\")\n    print(\"-\" * 40)\n    for hero, dmg in sorted(damage_dealt.items(), key=lambda x: -x[1]):\n        print(f\"  {hero:&lt;35}: {dmg:&gt;10,}\")\n\n    print(\"\\nTotal Damage Taken:\")\n    print(\"-\" * 40)\n    for hero, dmg in sorted(damage_taken.items(), key=lambda x: -x[1]):\n        print(f\"  {hero:&lt;35}: {dmg:&gt;10,}\")\n\n    print(\"\\nTop Damage Sources by Hero:\")\n    print(\"-\" * 60)\n    for hero in sorted(ability_damage.keys()):\n        abilities = ability_damage[hero]\n        top_abilities = sorted(abilities.items(), key=lambda x: -x[1])[:5]\n\n        print(f\"\\n{hero}:\")\n        for ability, dmg in top_abilities:\n            print(f\"    {ability:&lt;30}: {dmg:&gt;8,}\")\n\n# Usage\ngenerate_damage_report(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Damage Report\n============================================================\n\nTotal Hero vs Hero Damage:\n----------------------------------------\n  medusa                              :    157,175\n  juggernaut                          :    120,374\n  earthshaker                         :    120,136\n  nevermore                           :     78,853\n  pugna                               :     46,453\n  disruptor                           :     27,317\n  magnataur                           :     24,803\n  shadow_demon                        :     22,983\n  pangolier                           :     22,755\n  naga_siren                          :     20,433\n</code></pre></p> <p>Note: skiter's Medusa dealt the most hero damage (157k), while Ame's Juggernaut (120k) and Xxs's Earthshaker (120k) were the top damage dealers for XG.</p>"},{"location":"examples/#team-fight-detector","title":"Team Fight Detector","text":"<p>Detect team fights by analyzing death clusters.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef detect_team_fights(demo_path: str, tick_window: int = 600):\n    parser = MantaParser()\n\n    # Get deaths from combat log\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[4],  # Deaths\n        heroes_only=True,\n        max_entries=500\n    )\n\n    if not result.entries:\n        print(\"No hero deaths found\")\n        return\n\n    # Group deaths by time window\n    fights = []\n    current_fight = []\n\n    for entry in sorted(result.entries, key=lambda e: e.tick):\n        if not current_fight:\n            current_fight.append(entry)\n        elif entry.tick - current_fight[-1].tick &lt;= tick_window:\n            current_fight.append(entry)\n        else:\n            if len(current_fight) &gt;= 3:  # At least 3 deaths = team fight\n                fights.append(current_fight)\n            current_fight = [entry]\n\n    # Don't forget last fight\n    if len(current_fight) &gt;= 3:\n        fights.append(current_fight)\n\n    print(\"Team Fight Detection\")\n    print(\"=\" * 60)\n    print(f\"Found {len(fights)} team fights (3+ deaths within {tick_window} ticks)\")\n\n    for i, fight in enumerate(fights, 1):\n        start_tick = fight[0].tick\n        end_tick = fight[-1].tick\n        duration = end_tick - start_tick\n\n        radiant_deaths = sum(1 for e in fight if e.target_team == 2)\n        dire_deaths = sum(1 for e in fight if e.target_team == 3)\n\n        print(f\"\\nFight #{i}: Tick {start_tick} - {end_tick} ({duration} ticks)\")\n        print(f\"  Deaths: Radiant {radiant_deaths}, Dire {dire_deaths}\")\n        print(f\"  Outcome: {'Radiant' if dire_deaths &gt; radiant_deaths else 'Dire'} won\")\n\n        print(f\"  Deaths:\")\n        for entry in fight:\n            team = \"R\" if entry.target_team == 2 else \"D\"\n            print(f\"    [{team}] {entry.target_name} killed by {entry.attacker_name}\")\n\n# Usage\ndetect_team_fights(\"match.dem\")\n</code></pre>"},{"location":"examples/#chat-log-extractor","title":"Chat Log Extractor","text":"<p>Extract and format all chat messages.</p> <pre><code>from python_manta import MantaParser\n\ndef extract_chat_log(demo_path: str):\n    parser = MantaParser()\n\n    result = parser.parse_universal(\n        demo_path,\n        \"CDOTAUserMsg_ChatMessage\",\n        max_messages=1000\n    )\n\n    # Get string tables for player names (if available)\n    userinfo = parser.get_string_tables(\n        demo_path,\n        table_names=[\"userinfo\"],\n        max_entries=20\n    )\n\n    print(\"Chat Log\")\n    print(\"=\" * 60)\n\n    chat_types = {1: \"ALL\", 2: \"TEAM\", 3: \"SPEC\"}\n\n    for msg in result.messages:\n        player_id = msg.data.get(\"source_player_id\", \"?\")\n        text = msg.data.get(\"message_text\", \"\")\n        chat_type = msg.data.get(\"chat_type\", 0)\n\n        if not text:\n            continue\n\n        type_str = chat_types.get(chat_type, \"???\")\n        tick = msg.tick\n\n        print(f\"[{tick:&gt;7}] [{type_str:&gt;4}] Player {player_id}: {text}\")\n\n# Usage\nextract_chat_log(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Chat Log\n============================================================\n[ 27298] [ ALL] Player 0: gl hf\n[ 27330] [ ALL] Player 5: hf\n[ 27338] [ ALL] Player 1: gl\n[ 27346] [ ALL] Player 6: glhf\n[ 28882] [ ALL] Player 3: the lights are too much\n[ 29194] [ ALL] Player 7: its fine\n[ 29330] [ ALL] Player 0: g\n[ 29378] [ ALL] Player 7: g\n[ 29394] [ ALL] Player 9: G\n[ 65954] [ ALL] Player 5: teamspeak delay\n[ 66538] [ ALL] Player 0: g\n[ 66618] [ ALL] Player 5: g\n[ 66858] [ ALL] Player 9: g\n[139170] [ ALL] Player 5: gg\n[139250] [ ALL] Player 3: gg\n</code></pre></p> <p>Note: The TI Grand Finals captured the pre-game \"gl hf\" exchanges, a technical pause for \"teamspeak delay\", and the final \"gg\" at match end.</p>"},{"location":"examples/#rune-tracking","title":"Rune Tracking","text":"<p>Track rune pickups throughout the match using combat log modifiers.</p> <pre><code>from python_manta import MantaParser, RuneType\nfrom collections import defaultdict\n\ndef track_runes(demo_path: str):\n    parser = MantaParser()\n\n    # Rune pickups are tracked via combat log modifiers\n    # When a hero picks up a rune, they receive a modifier_rune_* buff\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[2],  # MODIFIER_ADD only\n        heroes_only=True,\n        max_entries=50000\n    )\n\n    # Filter for rune modifiers using the RuneType enum\n    rune_pickups = [\n        e for e in result.entries\n        if RuneType.is_rune_modifier(e.inflictor_name)\n    ]\n\n    print(\"Rune Tracking\")\n    print(\"=\" * 50)\n    print(f\"\\nTotal Rune Pickups: {len(rune_pickups)}\")\n    print(\"-\" * 40)\n\n    # Group by hero\n    hero_runes = defaultdict(list)\n    for pickup in rune_pickups:\n        hero = pickup.target_name.replace(\"npc_dota_hero_\", \"\")\n        rune = RuneType.from_modifier(pickup.inflictor_name)\n        rune_name = rune.display_name if rune else pickup.inflictor_name\n        hero_runes[hero].append({\n            \"time\": pickup.timestamp,\n            \"rune\": rune_name\n        })\n\n    # Print timeline\n    print(\"\\nRune Pickup Timeline:\")\n    print(\"-\" * 60)\n    for pickup in rune_pickups:\n        hero = pickup.target_name.replace(\"npc_dota_hero_\", \"\")\n        rune = RuneType.from_modifier(pickup.inflictor_name)\n        rune_name = rune.display_name if rune else pickup.inflictor_name\n        minutes = int(pickup.timestamp // 60)\n        seconds = int(pickup.timestamp % 60)\n        print(f\"[{minutes:02d}:{seconds:02d}] {hero:&lt;20} picked up {rune_name}\")\n\n    # Print summary by hero\n    print(\"\\nRunes by Hero:\")\n    print(\"-\" * 40)\n    for hero, runes in sorted(hero_runes.items()):\n        rune_summary = \", \".join(r[\"rune\"] for r in runes)\n        print(f\"  {hero}: {len(runes)} runes ({rune_summary})\")\n\n# Usage\ntrack_runes(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Rune Tracking\n==================================================\n\nTotal Rune Pickups: 19\n----------------------------------------\n\nRune Pickup Timeline:\n------------------------------------------------------------\n[23:30] naga_siren           picked up Arcane\n[26:05] pangolier            picked up Invisibility\n[28:44] pangolier            picked up Haste\n[30:45] pangolier            picked up Double Damage\n[35:56] pangolier            picked up Regeneration\n[37:17] naga_siren           picked up Double Damage\n[40:29] pangolier            picked up Invisibility\n[41:24] pugna                picked up Shield\n[44:55] pangolier            picked up Regeneration\n[45:57] naga_siren           picked up Haste\n\nRunes by Hero:\n----------------------------------------\n  naga_siren: 4 runes (Arcane, Double Damage, Haste, Arcane)\n  pangolier: 8 runes (Invisibility, Haste, Double Damage, ...)\n  pugna: 3 runes (Shield, Shield, Shield)\n  ...\n</code></pre></p>"},{"location":"examples/#item-usage-tracker","title":"Item Usage Tracker","text":"<p>Track when heroes use active items (smoke, wards, BKB, etc.).</p> <pre><code>from python_manta import MantaParser, CombatLogType\nfrom collections import defaultdict\n\ndef track_item_usage(demo_path: str):\n    parser = MantaParser()\n\n    # Item usage is in combat log ITEM type\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ITEM],\n        heroes_only=True,\n        max_entries=2000\n    )\n\n    print(\"Item Usage Tracking\")\n    print(\"=\" * 60)\n    print(f\"Total item activations: {result.total_entries}\\n\")\n\n    # Group by hero\n    hero_usage = defaultdict(lambda: defaultdict(int))\n\n    for entry in result.entries:\n        hero = entry.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.inflictor_name.replace(\"item_\", \"\")\n        hero_usage[hero][item] += 1\n\n    # Print usage by hero\n    for hero in sorted(hero_usage.keys()):\n        items = hero_usage[hero]\n        print(f\"\\n{hero}:\")\n        for item, count in sorted(items.items(), key=lambda x: -x[1]):\n            print(f\"  {item}: {count}x\")\n\n# Usage\ntrack_item_usage(\"match.dem\")\n</code></pre>"},{"location":"examples/#lotus-orb-detection","title":"Lotus Orb Detection","text":"<p>Detect Lotus Orb spell reflections using ability triggers.</p> <pre><code>from python_manta import MantaParser, CombatLogType\n\ndef detect_lotus_orb(demo_path: str):\n    parser = MantaParser()\n\n    # Ability triggers include Lotus Orb reflections\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ABILITY_TRIGGER],\n        max_entries=500\n    )\n\n    print(\"Lotus Orb / Ability Trigger Detection\")\n    print(\"=\" * 60)\n\n    lotus_events = []\n    other_triggers = []\n\n    for entry in result.entries:\n        hero = entry.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        target = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.inflictor_name\n\n        # Calculate time\n        mins = int(entry.game_time // 60)\n        secs = int(entry.game_time % 60)\n\n        event = {\n            \"time\": f\"{mins:02d}:{secs:02d}\",\n            \"hero\": hero,\n            \"target\": target,\n            \"item\": item\n        }\n\n        if \"lotus_orb\" in item:\n            lotus_events.append(event)\n        else:\n            other_triggers.append(event)\n\n    if lotus_events:\n        print(f\"\\nLotus Orb Reflections ({len(lotus_events)} total):\")\n        print(\"-\" * 50)\n        for e in lotus_events:\n            print(f\"[{e['time']}] {e['hero']} reflected spell to {e['target']}\")\n\n    if other_triggers:\n        print(f\"\\nOther Ability Triggers ({len(other_triggers)} total):\")\n        print(\"-\" * 50)\n        for e in other_triggers[:10]:  # Show first 10\n            print(f\"[{e['time']}] {e['hero']} -&gt; {e['target']} ({e['item']})\")\n\n# Usage\ndetect_lotus_orb(\"match.dem\")\n</code></pre>"},{"location":"examples/#neutral-item-tracker","title":"Neutral Item Tracker","text":"<p>Track neutral item drops, pickups, and usage throughout the game.</p> <pre><code>from python_manta import MantaParser, NeutralItem, NeutralItemTier, CombatLogType\n\ndef track_neutral_items(demo_path: str):\n    parser = MantaParser()\n\n    print(\"Neutral Item Analysis\")\n    print(\"=\" * 60)\n\n    # 1. Track neutral item pickups via CDOTAUserMsg_FoundNeutralItem\n    found_result = parser.parse_universal(demo_path, \"FoundNeutralItem\", max_messages=100)\n\n    print(f\"\\nNeutral Items Found: {len(found_result.messages)}\")\n    print(\"-\" * 40)\n\n    items_by_tier = {t: [] for t in NeutralItemTier}\n\n    for msg in found_result.messages:\n        player_id = msg.data.get('player_id')\n        item_tier_value = msg.data.get('item_tier', 0)\n        tier = NeutralItemTier.from_value(item_tier_value)\n\n        if tier:\n            mins = int(msg.tick / 30 / 60)  # Approximate game time\n            items_by_tier[tier].append({\n                \"player\": player_id,\n                \"time_approx\": f\"~{mins}m\",\n                \"tick\": msg.tick\n            })\n\n    for tier in NeutralItemTier:\n        items = items_by_tier[tier]\n        if items:\n            print(f\"\\n{tier.display_name} (unlocks at {tier.unlock_time_minutes}min): {len(items)} drops\")\n            for item in items[:5]:  # Show first 5\n                print(f\"  Player {item['player']} at {item['time_approx']}\")\n\n    # 2. Track neutral item USAGE via combat log\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ITEM],\n        max_entries=1000\n    )\n\n    print(f\"\\n\\nNeutral Item Active Usage\")\n    print(\"-\" * 40)\n\n    usage_count = {}\n    for entry in result.entries:\n        if NeutralItem.is_neutral_item(entry.inflictor_name):\n            item = NeutralItem.from_item_name(entry.inflictor_name)\n            if item:\n                key = (entry.attacker_name, item.display_name)\n                usage_count[key] = usage_count.get(key, 0) + 1\n\n    # Sort by usage count\n    sorted_usage = sorted(usage_count.items(), key=lambda x: x[1], reverse=True)\n    for (hero, item_name), count in sorted_usage[:15]:\n        hero_short = hero.replace(\"npc_dota_hero_\", \"\")\n        print(f\"  {hero_short}: {item_name} x{count}\")\n\n    # 3. Track neutral item modifiers/buffs\n    mod_result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.MODIFIER_ADD],\n        max_entries=2000\n    )\n\n    print(f\"\\n\\nNeutral Item Buffs Applied\")\n    print(\"-\" * 40)\n\n    buff_count = {}\n    for entry in mod_result.entries:\n        inflictor = entry.inflictor_name\n        # Check if it's a neutral item modifier\n        if inflictor and inflictor.startswith(\"modifier_item_\"):\n            # Extract item name from modifier\n            item_name = inflictor.replace(\"modifier_\", \"\")\n            if NeutralItem.is_neutral_item(item_name):\n                buff_count[inflictor] = buff_count.get(inflictor, 0) + 1\n\n    for mod, count in sorted(buff_count.items(), key=lambda x: x[1], reverse=True)[:10]:\n        print(f\"  {mod}: {count} applications\")\n\n# Usage\ntrack_neutral_items(\"match.dem\")\n</code></pre>"},{"location":"examples/#defensive-item-vs-ultimate-analysis","title":"Defensive Item vs Ultimate Analysis","text":"<p>Analyze how defensive items counter ultimates. This example shows how skiter's Outworld Staff nullified Ame's Omnislash in a crucial teamfight at 64:08.</p> <pre><code>from python_manta import MantaParser, CombatLogType, NeutralItem\n\ndef analyze_defensive_counter(demo_path: str, start_time: float, end_time: float):\n    \"\"\"Analyze a specific window for ability vs defensive item interactions.\"\"\"\n    parser = MantaParser()\n\n    print(\"Defensive Item Analysis\")\n    print(\"=\" * 60)\n    print(f\"Window: {start_time/60:.0f}:{start_time%60:02.0f} - {end_time/60:.0f}:{end_time%60:02.0f}\")\n\n    # Get abilities cast in window\n    abilities = parser.parse_combat_log(demo_path, types=[CombatLogType.ABILITY], max_entries=100000)\n    items = parser.parse_combat_log(demo_path, types=[CombatLogType.ITEM], max_entries=100000)\n    damage = parser.parse_combat_log(demo_path, types=[CombatLogType.DAMAGE], max_entries=500000)\n    mods = parser.parse_combat_log(demo_path, types=[CombatLogType.MODIFIER_ADD], max_entries=100000)\n\n    window_abilities = [e for e in abilities.entries if start_time &lt;= e.timestamp &lt;= end_time]\n    window_items = [e for e in items.entries if start_time &lt;= e.timestamp &lt;= end_time]\n    window_damage = [e for e in damage.entries if start_time &lt;= e.timestamp &lt;= end_time]\n    window_mods = [e for e in mods.entries if start_time &lt;= e.timestamp &lt;= end_time]\n\n    print(\"\\n--- Abilities Cast ---\")\n    for e in window_abilities:\n        mins = int(e.timestamp // 60)\n        secs = int(e.timestamp % 60)\n        caster = e.attacker_name.replace('npc_dota_hero_', '')\n        ability = e.inflictor_name\n        target = e.target_name.replace('npc_dota_hero_', '')\n        print(f\"  [{mins:02d}:{secs:02d}] {caster} -&gt; {ability} on {target}\")\n\n    print(\"\\n--- Items Used ---\")\n    for e in window_items:\n        mins = int(e.timestamp // 60)\n        secs = int(e.timestamp % 60)\n        user = e.attacker_name.replace('npc_dota_hero_', '')\n        item = e.inflictor_name\n        print(f\"  [{mins:02d}:{secs:02d}] {user} -&gt; {item}\")\n\n    print(\"\\n--- Key Modifiers ---\")\n    defensive_mods = [e for e in window_mods\n                      if 'ethereal' in e.inflictor_name.lower()\n                      or 'invulnerable' in e.inflictor_name.lower()\n                      or 'outworld' in e.inflictor_name.lower()\n                      or 'aeon' in e.inflictor_name.lower()]\n    for e in defensive_mods:\n        mins = int(e.timestamp // 60)\n        secs = int(e.timestamp % 60)\n        target = e.target_name.replace('npc_dota_hero_', '')\n        mod = e.inflictor_name\n        print(f\"  [{mins:02d}:{secs:02d}] {mod} on {target}\")\n\n    # Check for Omnislash damage specifically\n    omni_damage = [e for e in window_damage\n                   if 'omni' in e.inflictor_name.lower() or 'swift' in e.inflictor_name.lower()]\n    print(f\"\\n--- Omnislash Damage: {len(omni_damage)} hits ---\")\n    for e in omni_damage[:5]:\n        mins = int(e.timestamp // 60)\n        secs = int(e.timestamp % 60)\n        target = e.target_name.replace('npc_dota_hero_', '')\n        dmg = e.value\n        print(f\"  [{mins:02d}:{secs:02d}] Hit {target} for {dmg}\")\n\n# Usage - Analyze the 64:08 Omnislash vs Outworld Staff moment\n# At 64:08, Ame Omnislashes Medusa, but she uses Outworld Staff at 64:09\n# The ethereal form nullifies the Omnislash, leading to Juggernaut's death at 64:13\nanalyze_defensive_counter(\"match.dem\", start_time=3848, end_time=3855)\n</code></pre> <p>Expected Output (TI 2025 Grand Finals - 64:08 fight): <pre><code>Defensive Item Analysis\n============================================================\nWindow: 64:08 - 64:15\n\n--- Abilities Cast ---\n  [64:08] juggernaut -&gt; juggernaut_omni_slash on medusa\n  [64:10] juggernaut -&gt; juggernaut_blade_fury on dota_unknown\n  [64:10] shadow_demon -&gt; shadow_demon_demonic_cleanse on juggernaut\n  [64:11] pangolier -&gt; pangolier_gyroshell on dota_unknown\n\n--- Items Used ---\n  [64:09] medusa -&gt; item_outworld_staff\n\n--- Key Modifiers ---\n  [64:09] modifier_item_outworld_staff on medusa\n\n--- Omnislash Damage: 0 hits ---\n</code></pre></p> <p>Analysis: Ame's Omnislash targeted Medusa at 64:08, but skiter immediately used Outworld Staff at 64:09. The <code>modifier_item_outworld_staff</code> made Medusa ethereal (untargetable by physical attacks), causing Omnislash to deal zero damage and end prematurely. This forced Juggernaut into Blade Fury defensively, and he was killed at 64:13.</p> <p>This demonstrates how: 1. Ability casts are tracked via <code>CombatLogType.ABILITY</code> 2. Defensive items are tracked via <code>CombatLogType.ITEM</code> 3. Buff effects are tracked via <code>CombatLogType.MODIFIER_ADD</code> 4. Missing damage indicates the counter was successful</p>"},{"location":"examples/#complete-analysis-pipeline","title":"Complete Analysis Pipeline","text":"<p>Combine multiple analyses into a single comprehensive report.</p> <pre><code>from python_manta import MantaParser, CombatLogType\n\ndef full_analysis(demo_path: str):\n    parser = MantaParser()\n\n    print(\"=\" * 70)\n    print(\"COMPREHENSIVE MATCH ANALYSIS\")\n    print(\"=\" * 70)\n\n    # 1. Basic Info\n    header = parser.parse_header(demo_path)\n    info = parser.get_parser_info(demo_path)\n\n    print(f\"\\n[1] Match Information\")\n    print(f\"    Build: {header.build_num}\")\n    print(f\"    Duration: {info.tick} ticks\")\n    print(f\"    Entities: {info.entity_count}\")\n\n    # 2. Draft\n    game_info = parser.parse_game_info(demo_path)\n    picks = [e for e in game_info.picks_bans if e.is_pick]\n    bans = [e for e in game_info.picks_bans if not e.is_pick]\n\n    print(f\"\\n[2] Draft\")\n    print(f\"    Picks: {len(picks)}\")\n    print(f\"    Bans: {len(bans)}\")\n\n    # 3. Kill Summary\n    kills = parser.parse_game_events(demo_path, event_filter=\"dota_player_kill\", max_events=500)\n    print(f\"\\n[3] Kills\")\n    print(f\"    Total: {len(kills.events)}\")\n\n    # 4. Combat Log Stats\n    combat = parser.parse_combat_log(demo_path, heroes_only=True, max_entries=5000)\n    damage_entries = [e for e in combat.entries if e.type == 0]\n    death_entries = [e for e in combat.entries if e.type == 4]\n\n    print(f\"\\n[4] Combat Log\")\n    print(f\"    Damage events: {len(damage_entries)}\")\n    print(f\"    Death events: {len(death_entries)}\")\n\n    # 5. Chat Activity\n    chat = parser.parse_universal(demo_path, \"CDOTAUserMsg_ChatMessage\", max_messages=500)\n    print(f\"\\n[5] Communication\")\n    print(f\"    Chat messages: {chat.count}\")\n\n    # 6. Item Economy (via combat log)\n    items = parser.parse_combat_log(demo_path, types=[CombatLogType.PURCHASE], max_entries=2000)\n    print(f\"\\n[6] Economy\")\n    print(f\"    Item purchases: {items.total_entries}\")\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Analysis complete\")\n\n# Usage\nfull_analysis(\"match.dem\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"AI Summary <pre><code>This page covers installation and basic usage of Python Manta. Install via `pip install python-manta` (no Go required). For development from source, either download pre-built libraries with `python scripts/download_library.py` or build with Go using `./build.sh`. The main entry point is `MantaParser()` which provides methods for parsing headers, drafts, and any message type from .dem replay files.\n</code></pre>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install python-manta\n</code></pre> <p>Pre-built wheels include the compiled library for:</p> <ul> <li>Linux x86_64</li> <li>macOS Intel (x86_64) and Apple Silicon (arm64)</li> <li>Windows AMD64</li> </ul> <p>No Go installation required when installing from PyPI.</p>"},{"location":"getting-started/#from-source","title":"From Source","text":"<p>If you're developing or need to build from source:</p>"},{"location":"getting-started/#option-1-download-pre-built-library","title":"Option 1: Download Pre-built Library","text":"<pre><code>git clone https://github.com/DeepBlueCoding/python-manta.git\ncd python-manta\npython scripts/download_library.py\npip install -e '.[dev]'\n</code></pre>"},{"location":"getting-started/#option-2-build-with-go","title":"Option 2: Build with Go","text":"<p>Requires Go 1.19+ installed.</p> <pre><code>git clone https://github.com/DeepBlueCoding/python-manta.git\ncd python-manta\ngit clone https://github.com/dotabuff/manta.git ../manta\n./build.sh\npip install -e '.[dev]'\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"from python_manta import MantaParser; print('Success!')\"\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#import-the-library","title":"Import the Library","text":"<pre><code>from python_manta import MantaParser\n\n# Create a parser instance\nparser = MantaParser()\n</code></pre>"},{"location":"getting-started/#parse-match-header","title":"Parse Match Header","text":"<p>The header contains match metadata available without parsing the full replay:</p> <pre><code>header = parser.parse_header(\"match.dem\")\n\nprint(f\"Map: {header.map_name}\")\nprint(f\"Server: {header.server_name}\")\nprint(f\"Build: {header.build_num}\")\nprint(f\"Network Protocol: {header.network_protocol}\")\n</code></pre>"},{"location":"getting-started/#parse-game-info-draft-players-teams","title":"Parse Game Info (Draft, Players, Teams)","text":"<pre><code>game_info = parser.parse_game_info(\"match.dem\")\n\n# Match basics\nprint(f\"Match ID: {game_info.match_id}\")\nprint(f\"Winner: {'Radiant' if game_info.game_winner == 2 else 'Dire'}\")\n\n# Draft picks and bans\nfor event in game_info.picks_bans:\n    action = \"PICK\" if event.is_pick else \"BAN\"\n    team = \"Radiant\" if event.team == 2 else \"Dire\"\n    print(f\"{team} {action}: Hero ID {event.hero_id}\")\n\n# Team data (pro/league matches)\nif game_info.league_id &gt; 0:\n    print(f\"League: {game_info.league_id}\")\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n\n# Player info\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n</code></pre>"},{"location":"getting-started/#parse-any-message-type","title":"Parse Any Message Type","text":"<p>Use <code>parse_universal()</code> to capture any of the 272 supported message types:</p> <pre><code># Get chat messages\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    player = msg.data.get('source_player_id', 'Unknown')\n    text = msg.data.get('message_text', '')\n    print(f\"[{msg.tick}] Player {player}: {text}\")\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\ntry:\n    header = parser.parse_header(\"match.dem\")\n\n    if header.success:\n        print(f\"Parsed: {header.map_name}\")\n    else:\n        print(f\"Parse error: {header.error}\")\n\nexcept FileNotFoundError:\n    print(\"Demo file not found\")\nexcept ValueError as e:\n    print(f\"Invalid file: {e}\")\n</code></pre>"},{"location":"getting-started/#getting-replay-files","title":"Getting Replay Files","text":"<p>Dota 2 replay files (<code>.dem</code>) can be obtained from:</p> <ol> <li>Local replays - <code>Steam/steamapps/common/dota 2 beta/game/dota/replays/</code></li> <li>OpenDota API - api.opendota.com</li> <li>Valve API - Match history endpoints provide replay URLs</li> </ol> <p>Replay files are typically 100-200MB for a full match.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete method documentation</li> <li>Game Events Guide - Parse 364 event types</li> <li>Combat Log Guide - Analyze damage and kills</li> <li>Examples - Real-world code samples</li> </ul>"},{"location":"api/","title":"API Reference","text":"AI Summary <p>Complete API documentation for Python Manta. The main class is <code>MantaParser</code> which provides all parsing methods. Data is returned as Pydantic models (<code>HeaderInfo</code>, <code>GameInfo</code>, <code>GameEventsResult</code>, etc.) for type safety and easy serialization. Key methods: <code>parse_header()</code>, <code>parse_game_info()</code>, <code>parse_universal()</code>, <code>parse_game_events()</code>, <code>parse_combat_log()</code>, <code>parse_modifiers()</code>, <code>query_entities()</code>, <code>get_string_tables()</code>, <code>get_parser_info()</code>.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>Python Manta provides a single main class and several data models:</p>"},{"location":"api/#main-class","title":"Main Class","text":"Class Description <code>MantaParser</code> Main parser class with all parsing methods"},{"location":"api/#data-models","title":"Data Models","text":"Model Description <code>HeaderInfo</code> Demo file header metadata <code>GameInfo</code> Game information (draft, players, teams) <code>DraftEvent</code> Single pick/ban event <code>PlayerInfo</code> Player information from match <code>UniversalParseResult</code> Universal parsing results <code>MessageEvent</code> Single message from replay <code>GameEventsResult</code> Game events parsing results <code>GameEventData</code> Single game event <code>ModifiersResult</code> Modifier parsing results <code>ModifierEntry</code> Single modifier/buff entry <code>EntitiesResult</code> Entity query results <code>EntityData</code> Single entity data <code>CombatLogResult</code> Combat log parsing results <code>CombatLogEntry</code> Single combat log entry <code>StringTablesResult</code> String table results <code>ParserInfo</code> Parser state information"},{"location":"api/#quick-reference","title":"Quick Reference","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Basic parsing\nheader = parser.parse_header(\"match.dem\")\ngame_info = parser.parse_game_info(\"match.dem\")\nmessages = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\n# Advanced parsing\nevents = parser.parse_game_events(\"match.dem\", event_filter=\"dota\", max_events=100)\ncombat = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\nmodifiers = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\nentities = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\ntables = parser.get_string_tables(\"match.dem\", table_names=[\"userinfo\"])\ninfo = parser.get_parser_info(\"match.dem\")\n</code></pre>"},{"location":"api/manta-parser/","title":"MantaParser","text":"AI Summary <p><code>MantaParser</code> is the main class for parsing Dota 2 replays. Create an instance with <code>MantaParser()</code> and call methods like <code>parse_header()</code>, <code>parse_game_info()</code>, <code>parse_universal()</code>. For specialized data, use <code>parse_game_events()</code>, <code>parse_combat_log()</code>, <code>parse_modifiers()</code>, <code>query_entities()</code>, <code>get_string_tables()</code>. Use <code>parse_game_info()</code> to get match data (draft, teams, players, league). All methods take a file path and return Pydantic models. The same parser instance can be reused for multiple files.</p>"},{"location":"api/manta-parser/#api-levels","title":"API Levels","text":"<p>MantaParser provides two levels of APIs:</p>"},{"location":"api/manta-parser/#high-level-apis-recommended","title":"High-Level APIs (Recommended)","text":"<p>These methods process and structure the raw Manta data, resolving string table indices to names and returning typed Pydantic models:</p> Method Purpose <code>parse_header()</code> Demo file metadata <code>parse_game_info()</code> Game data (draft, teams, players, league) <code>parse_entities()</code> Entity snapshots with player stats/positions <code>parse_game_events()</code> Game events with field name resolution <code>parse_combat_log()</code> Combat log with name resolution <code>parse_modifiers()</code> Buff/debuff tracking <code>query_entities()</code> Entity properties at end of replay <code>get_string_tables()</code> String table data <code>get_parser_info()</code> Parser state metadata"},{"location":"api/manta-parser/#low-level-api-raw-manta-data","title":"Low-Level API (Raw Manta Data)","text":"Method Purpose <code>parse_universal()</code> Raw protobuf messages from any Manta callback <p><code>parse_universal()</code> returns data exactly as Manta provides it - raw protobuf message fields serialized to JSON with no processing. Use this when you need access to message types not covered by high-level APIs, or when you need the raw unprocessed data.</p>"},{"location":"api/manta-parser/#constructor","title":"Constructor","text":"<pre><code>class MantaParser:\n    def __init__(self, library_path: Optional[str] = None)\n</code></pre> <p>Creates a new parser instance.</p> <p>Parameters: - <code>library_path</code> (optional): Path to the shared library. If not provided, uses the bundled library.</p> <p>Example: <pre><code>from python_manta import MantaParser\n\n# Use bundled library (recommended)\nparser = MantaParser()\n\n# Use custom library path\nparser = MantaParser(\"/path/to/libmanta_wrapper.so\")\n</code></pre></p>"},{"location":"api/manta-parser/#basic-parsing-methods","title":"Basic Parsing Methods","text":""},{"location":"api/manta-parser/#parse_header","title":"parse_header","text":"<pre><code>def parse_header(self, demo_file_path: str) -&gt; HeaderInfo\n</code></pre> <p>Parses the demo file header containing match metadata.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file</p> <p>Returns: <code>HeaderInfo</code></p> <p>Raises: - <code>FileNotFoundError</code>: If the file doesn't exist - <code>ValueError</code>: If parsing fails</p> <p>Example: <pre><code>header = parser.parse_header(\"match.dem\")\n\nprint(f\"Map: {header.map_name}\")\nprint(f\"Server: {header.server_name}\")\nprint(f\"Build: {header.build_num}\")\nprint(f\"Protocol: {header.network_protocol}\")\n</code></pre></p>"},{"location":"api/manta-parser/#parse_game_info","title":"parse_game_info","text":"<pre><code>def parse_game_info(self, demo_file_path: str) -&gt; GameInfo\n</code></pre> <p>Parses complete game information including draft, players, and teams.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file</p> <p>Returns: <code>GameInfo</code></p> <p>Raises: - <code>FileNotFoundError</code>: If the file doesn't exist - <code>ValueError</code>: If parsing fails</p> <p>Example: <pre><code>game_info = parser.parse_game_info(\"match.dem\")\n\nprint(f\"Match ID: {game_info.match_id}\")\nprint(f\"Game Mode: {game_info.game_mode}\")\nprint(f\"Winner: {'Radiant' if game_info.game_winner == 2 else 'Dire'}\")\n\n# Team info (pro matches)\nif game_info.league_id &gt; 0:\n    print(f\"League ID: {game_info.league_id}\")\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n\n# Draft\nfor event in game_info.picks_bans:\n    action = \"PICK\" if event.is_pick else \"BAN\"\n    team = \"Radiant\" if event.team == 2 else \"Dire\"\n    print(f\"{team} {action}: Hero {event.hero_id}\")\n\n# Player info\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n</code></pre></p>"},{"location":"api/manta-parser/#parse_entities","title":"parse_entities","text":"<pre><code>def parse_entities(\n    self,\n    demo_file_path: str,\n    interval_ticks: int = 1800,\n    max_snapshots: int = 0,\n    target_ticks: Optional[List[int]] = None,\n    target_heroes: Optional[List[str]] = None,\n    entity_classes: Optional[List[str]] = None,\n    include_raw: bool = False\n) -&gt; EntityParseResult\n</code></pre> <p>Parses entity state snapshots over time, capturing player stats and positions at regular intervals or specific ticks.</p> <p>Parameters:</p> <ul> <li><code>demo_file_path</code>: Path to the <code>.dem</code> replay file</li> <li><code>interval_ticks</code>: Capture snapshot every N ticks (default 1800 \u2248 1 minute at 30 ticks/sec)</li> <li><code>max_snapshots</code>: Maximum snapshots to return (0 = unlimited)</li> <li><code>target_ticks</code>: Specific ticks to capture (overrides interval_ticks)</li> <li><code>target_heroes</code>: Filter to specific hero names (e.g., <code>[\"npc_dota_hero_invoker\"]</code>)</li> <li><code>entity_classes</code>: Filter to specific entity classes</li> <li><code>include_raw</code>: Include raw entity properties in output</li> </ul> <p>Returns: <code>EntityParseResult</code></p> <p>Example: <pre><code># Capture every minute\nresult = parser.parse_entities(\"match.dem\", interval_ticks=1800, max_snapshots=60)\n\nfor snapshot in result.snapshots:\n    print(f\"Tick {snapshot.tick}:\")\n    for player in snapshot.players:\n        print(f\"  {player.hero}: LH={player.last_hits}, DN={player.denies}, Gold={player.gold}\")\n\n# Capture at specific ticks\nresult = parser.parse_entities(\"match.dem\", target_ticks=[30000, 45000, 60000])\n\n# Track specific heroes\nresult = parser.parse_entities(\n    \"match.dem\",\n    target_ticks=[30000],\n    target_heroes=[\"npc_dota_hero_invoker\", \"npc_dota_hero_antimage\"]\n)\n</code></pre></p>"},{"location":"api/manta-parser/#low-level-api","title":"Low-Level API","text":""},{"location":"api/manta-parser/#parse_universal","title":"parse_universal","text":"<pre><code>def parse_universal(\n    self,\n    demo_file_path: str,\n    message_filter: str = \"\",\n    max_messages: int = 0\n) -&gt; UniversalParseResult\n</code></pre> <p>Low-level API for accessing raw Manta callback data. Returns protobuf messages exactly as Manta provides them, serialized to JSON with no processing or name resolution.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>message_filter</code>: Callback name filter (substring match, case-sensitive) - <code>max_messages</code>: Maximum messages to return (0 = unlimited)</p> <p>Returns: <code>UniversalParseResult</code></p> <p>Example: <pre><code># Get chat messages\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    print(f\"[{msg.tick}] {msg.type}: {msg.data}\")\n\n# Get all messages (no filter, limited)\nall_msgs = parser.parse_universal(\"match.dem\", \"\", 1000)\n\n# Filter matches substrings\npings = parser.parse_universal(\"match.dem\", \"Ping\", 50)  # Matches LocationPing, Ping, etc.\n</code></pre></p> <p>Warning</p> <p>Some message types generate thousands of entries per match (e.g., <code>CNETMsg_Tick</code>). Always use <code>max_messages</code> to prevent memory issues.</p>"},{"location":"api/manta-parser/#game-events","title":"Game Events","text":""},{"location":"api/manta-parser/#parse_game_events","title":"parse_game_events","text":"<pre><code>def parse_game_events(\n    self,\n    demo_file_path: str,\n    event_filter: str = \"\",\n    event_names: List[str] = None,\n    max_events: int = 0,\n    capture_types: bool = False\n) -&gt; GameEventsResult\n</code></pre> <p>Parses Source 1 legacy game events with typed field access.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>event_filter</code>: Filter events by name (substring match) - <code>event_names</code>: List of specific event names to capture - <code>max_events</code>: Maximum events to return (0 = unlimited) - <code>capture_types</code>: Include event type definitions in result</p> <p>Returns: <code>GameEventsResult</code></p> <p>Example: <pre><code># Get event type definitions\nresult = parser.parse_game_events(\"match.dem\", capture_types=True, max_events=0)\nprint(f\"Found {len(result.event_types)} event types\")\n\n# Filter by event name\ncombatlog = parser.parse_game_events(\"match.dem\", event_filter=\"dota_combatlog\", max_events=100)\n\n# Get specific events\nkills = parser.parse_game_events(\"match.dem\", event_names=[\"dota_player_kill\"], max_events=50)\n\nfor event in kills.events:\n    print(f\"[{event.tick}] {event.name}: {event.fields}\")\n</code></pre></p>"},{"location":"api/manta-parser/#combat-log","title":"Combat Log","text":""},{"location":"api/manta-parser/#parse_combat_log","title":"parse_combat_log","text":"<pre><code>def parse_combat_log(\n    self,\n    demo_file_path: str,\n    types: List[int] = None,\n    max_entries: int = 0,\n    heroes_only: bool = False\n) -&gt; CombatLogResult\n</code></pre> <p>Parses structured combat log entries with filtering.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>types</code>: Filter by combat log type IDs (see table below) - <code>max_entries</code>: Maximum entries to return (0 = unlimited) - <code>heroes_only</code>: Only include entries where attacker or target is a hero</p> <p>Returns: <code>CombatLogResult</code></p> <p>Combat Log Types:</p> ID Type Name Description 0 DAMAGE Damage dealt 1 HEAL Healing received 2 MODIFIER_ADD Buff/debuff applied 3 MODIFIER_REMOVE Buff/debuff removed 4 DEATH Unit death 5 ABILITY Ability used 6 ITEM Item used 7 GOLD Gold gained/lost 8 GAME_STATE Game state change 9 XP Experience gained 10 PURCHASE Item purchased 11 BUYBACK Buyback used <p>Example: <pre><code># All combat log entries\nresult = parser.parse_combat_log(\"match.dem\", max_entries=1000)\n\n# Damage only\ndamage = parser.parse_combat_log(\"match.dem\", types=[0], max_entries=500)\n\n# Hero kills only\nhero_combat = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\n\nfor entry in hero_combat.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.type_name}: {entry.attacker_name} -&gt; {entry.target_name} ({entry.value})\")\n</code></pre></p> <p>Note</p> <p>Combat log entries only start appearing after ~12-17 minutes into a match due to HLTV broadcast delay. For early game data, use entity queries.</p>"},{"location":"api/manta-parser/#modifiers","title":"Modifiers","text":""},{"location":"api/manta-parser/#parse_modifiers","title":"parse_modifiers","text":"<pre><code>def parse_modifiers(\n    self,\n    demo_file_path: str,\n    max_modifiers: int = 0,\n    auras_only: bool = False\n) -&gt; ModifiersResult\n</code></pre> <p>Tracks buffs, debuffs, and auras applied to units.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>max_modifiers</code>: Maximum modifiers to return (0 = unlimited) - <code>auras_only</code>: Only include aura effects</p> <p>Returns: <code>ModifiersResult</code></p> <p>Example: <pre><code># All modifiers\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=200)\n\nfor mod in result.modifiers:\n    duration = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    print(f\"[{mod.tick}] Entity {mod.parent}: {duration}, stacks={mod.stack_count}\")\n\n# Auras only\nauras = parser.parse_modifiers(\"match.dem\", auras_only=True, max_modifiers=100)\n</code></pre></p>"},{"location":"api/manta-parser/#entity-queries","title":"Entity Queries","text":""},{"location":"api/manta-parser/#query_entities","title":"query_entities","text":"<pre><code>def query_entities(\n    self,\n    demo_file_path: str,\n    class_filter: str = \"\",\n    class_names: List[str] = None,\n    property_filter: List[str] = None,\n    max_entities: int = 0\n) -&gt; EntitiesResult\n</code></pre> <p>Queries entities at the end of the replay by class name and extracts properties.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>class_filter</code>: Filter by class name (substring match) - <code>class_names</code>: List of specific class names to match - <code>property_filter</code>: Only include these properties (empty = all) - <code>max_entities</code>: Maximum entities to return (0 = unlimited)</p> <p>Returns: <code>EntitiesResult</code></p> <p>Example: <pre><code># Query hero entities\nheroes = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor hero in heroes.entities:\n    health = hero.properties.get(\"m_iHealth\", 0)\n    max_hp = hero.properties.get(\"m_iMaxHealth\", 0)\n    print(f\"{hero.class_name}: {health}/{max_hp} HP\")\n\n# Query specific properties\nheroes = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_vecOrigin\"],\n    max_entities=10\n)\n\n# Query specific classes\nresult = parser.query_entities(\n    \"match.dem\",\n    class_names=[\"CDOTA_Unit_Hero_Invoker\", \"CDOTA_BaseNPC_Tower\"],\n    max_entities=20\n)\n</code></pre></p>"},{"location":"api/manta-parser/#string-tables","title":"String Tables","text":""},{"location":"api/manta-parser/#get_string_tables","title":"get_string_tables","text":"<pre><code>def get_string_tables(\n    self,\n    demo_file_path: str,\n    table_names: List[str] = None,\n    max_entries: int = 100\n) -&gt; StringTablesResult\n</code></pre> <p>Extracts string table data (player info, baselines, etc.).</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file - <code>table_names</code>: Specific tables to extract (empty = all) - <code>max_entries</code>: Maximum entries per table</p> <p>Returns: <code>StringTablesResult</code></p> <p>Common String Tables:</p> Table Name Contents <code>userinfo</code> Player Steam IDs and names <code>instancebaseline</code> Entity baselines <code>lightstyles</code> Light configuration <code>CombatLogNames</code> Combat log name lookups <p>Example: <pre><code># Get all table names\nresult = parser.get_string_tables(\"match.dem\")\nprint(f\"Tables: {result.table_names}\")\n\n# Get player info\nuserinfo = parser.get_string_tables(\"match.dem\", table_names=[\"userinfo\"], max_entries=20)\n\nfor table_name, entries in userinfo.tables.items():\n    for entry in entries:\n        print(f\"[{entry.index}] {entry.key}\")\n</code></pre></p>"},{"location":"api/manta-parser/#parser-info","title":"Parser Info","text":""},{"location":"api/manta-parser/#get_parser_info","title":"get_parser_info","text":"<pre><code>def get_parser_info(self, demo_file_path: str) -&gt; ParserInfo\n</code></pre> <p>Gets parser state information after parsing completes.</p> <p>Parameters: - <code>demo_file_path</code>: Path to the <code>.dem</code> replay file</p> <p>Returns: <code>ParserInfo</code></p> <p>Example: <pre><code>info = parser.get_parser_info(\"match.dem\")\n\nprint(f\"Final tick: {info.tick}\")\nprint(f\"Entity count: {info.entity_count}\")\nprint(f\"String tables: {info.string_tables}\")\n</code></pre></p>"},{"location":"api/models/","title":"Data Models","text":"AI Summary <p>All parsed data is returned as Pydantic models for type safety and easy serialization. Models include: <code>HeaderInfo</code> (match metadata), <code>GameInfo</code>/<code>DraftEvent</code>/<code>PlayerInfo</code> (game data with draft, teams, players), <code>UniversalParseResult</code>/<code>MessageEvent</code> (messages), <code>GameEventsResult</code>/<code>GameEventData</code> (events), <code>CombatLogResult</code>/<code>CombatLogEntry</code> (combat), <code>ModifiersResult</code>/<code>ModifierEntry</code> (buffs), <code>EntitiesResult</code>/<code>EntityData</code> (entities), <code>StringTablesResult</code> (tables), <code>ParserInfo</code> (state). Enums include <code>RuneType</code> (rune tracking), <code>EntityType</code> (hero, creep, summon, building), <code>CombatLogType</code> (45 combat log event types), <code>DamageType</code> (physical/magical/pure), <code>Team</code> (Radiant/Dire), <code>NeutralItemTier</code> (tier unlock times), <code>NeutralItem</code> (100+ neutral items), <code>ChatWheelMessage</code> (voice line IDs), and <code>GameActivity</code> (animation/taunt detection). All models have <code>.model_dump()</code> for dict conversion and <code>.model_dump_json()</code> for JSON.</p>"},{"location":"api/models/#enums","title":"Enums","text":""},{"location":"api/models/#runetype","title":"RuneType","text":"<p>Enum for Dota 2 power rune types with helper methods for combat log analysis.</p> <pre><code>class RuneType(str, Enum):\n    DOUBLE_DAMAGE = \"modifier_rune_doubledamage\"\n    HASTE = \"modifier_rune_haste\"\n    ILLUSION = \"modifier_rune_illusion\"\n    INVISIBILITY = \"modifier_rune_invis\"\n    REGENERATION = \"modifier_rune_regen\"\n    ARCANE = \"modifier_rune_arcane\"\n    SHIELD = \"modifier_rune_shield\"\n    WATER = \"modifier_rune_water\"\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Double Damage\") <code>modifier_name</code> str Combat log modifier name <p>Class Methods:</p> Method Returns Description <code>from_modifier(name)</code> <code>RuneType \\| None</code> Get RuneType from modifier name <code>is_rune_modifier(name)</code> <code>bool</code> Check if modifier is a rune <code>all_modifiers()</code> <code>List[str]</code> Get all rune modifier names <p>Example: <pre><code>from python_manta import RuneType\n\n# Check if a combat log entry is a rune pickup\nif RuneType.is_rune_modifier(entry.inflictor_name):\n    rune = RuneType.from_modifier(entry.inflictor_name)\n    print(f\"Picked up {rune.display_name}\")\n\n# Direct enum access\nprint(RuneType.HASTE.display_name)  # \"Haste\"\nprint(RuneType.HASTE.modifier_name)  # \"modifier_rune_haste\"\n\n# Get all rune modifiers for filtering\nrune_modifiers = RuneType.all_modifiers()\n</code></pre></p>"},{"location":"api/models/#entitytype","title":"EntityType","text":"<p>Enum for classifying Dota 2 entity types from entity name strings. Useful for filtering combat log entries by attacker/target type.</p> <pre><code>class EntityType(str, Enum):\n    HERO = \"hero\"\n    LANE_CREEP = \"lane_creep\"\n    NEUTRAL_CREEP = \"neutral_creep\"\n    SUMMON = \"summon\"\n    BUILDING = \"building\"\n    WARD = \"ward\"\n    COURIER = \"courier\"\n    ROSHAN = \"roshan\"\n    UNKNOWN = \"unknown\"\n</code></pre> <p>Properties:</p> Property Type Description <code>is_hero</code> bool True if this is a hero <code>is_creep</code> bool True if lane or neutral creep <code>is_unit</code> bool True if controllable unit (not building/ward) <code>is_structure</code> bool True if building or ward <p>Class Methods:</p> Method Returns Description <code>from_name(entity_name)</code> <code>EntityType</code> Get EntityType from entity name string <p>Example: <pre><code>from python_manta import MantaParser, EntityType\n\nparser = MantaParser()\nresult = parser.parse_combat_log(demo_path, types=[0], max_entries=1000)\n\nfor entry in result.entries:\n    attacker_type = EntityType.from_name(entry.attacker_name)\n    target_type = EntityType.from_name(entry.target_name)\n\n    # Self-buff detection\n    is_self = entry.attacker_name == entry.target_name\n\n    # Hero vs hero combat\n    if attacker_type.is_hero and target_type.is_hero and not is_self:\n        print(f\"Hero combat: {entry.attacker_name} -&gt; {entry.target_name}\")\n\n    # Hero farming creeps\n    if attacker_type.is_hero and target_type.is_creep:\n        print(f\"Farming: {entry.attacker_name} hit {entry.target_name}\")\n\n    # Building damage\n    if target_type == EntityType.BUILDING:\n        print(f\"Structure damage: {entry.target_name}\")\n</code></pre></p>"},{"location":"api/models/#combatlogtype","title":"CombatLogType","text":"<p>Enum for all 45+ combat log event types. Use this instead of magic numbers when filtering combat log entries.</p> <pre><code>class CombatLogType(int, Enum):\n    DAMAGE = 0\n    HEAL = 1\n    MODIFIER_ADD = 2\n    MODIFIER_REMOVE = 3\n    DEATH = 4\n    ABILITY = 5\n    ITEM = 6\n    LOCATION = 7\n    GOLD = 8\n    GAME_STATE = 9\n    XP = 10\n    PURCHASE = 11\n    BUYBACK = 12\n    ABILITY_TRIGGER = 13\n    PLAYERSTATS = 14\n    MULTIKILL = 15\n    KILLSTREAK = 16\n    TEAM_BUILDING_KILL = 17\n    FIRST_BLOOD = 18\n    MODIFIER_REFRESH = 19\n    NEUTRAL_CAMP_STACK = 20\n    PICKUP_RUNE = 21\n    REVEALED_INVISIBLE = 22\n    HERO_SAVED = 23\n    MANA_RESTORED = 24\n    HERO_LEVELUP = 25\n    BOTTLE_HEAL_ALLY = 26\n    ENDGAME_STATS = 27\n    INTERRUPT_CHANNEL = 28\n    ALLIED_GOLD = 29\n    AEGIS_TAKEN = 30\n    MANA_DAMAGE = 31\n    PHYSICAL_DAMAGE_PREVENTED = 32\n    UNIT_SUMMONED = 33\n    ATTACK_EVADE = 34\n    TREE_CUT = 35\n    SUCCESSFUL_SCAN = 36\n    END_KILLSTREAK = 37\n    BLOODSTONE_CHARGE = 38\n    CRITICAL_DAMAGE = 39\n    SPELL_ABSORB = 40\n    UNIT_TELEPORTED = 41\n    KILL_EATER_EVENT = 42\n    NEUTRAL_ITEM_EARNED = 43\n    TELEPORT_INTERRUPTED = 44\n    MODIFIER_STACK_EVENT = 45\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Purchase\") <code>is_damage_related</code> bool True if type is damage/heal related <code>is_modifier_related</code> bool True if type is buff/debuff related <code>is_economy_related</code> bool True if type is gold/XP/item related <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>CombatLogType \\| None</code> Get CombatLogType from integer value <p>Example: <pre><code>from python_manta import MantaParser, CombatLogType\n\nparser = MantaParser()\n\n# Use enum instead of magic numbers\nresult = parser.parse_combat_log(\n    demo_path,\n    types=[CombatLogType.PURCHASE, CombatLogType.ITEM],\n    max_entries=100\n)\n\nfor entry in result.entries:\n    log_type = CombatLogType.from_value(entry.type)\n    if log_type == CombatLogType.PURCHASE:\n        print(f\"{entry.target_name} bought {entry.value_name}\")\n    elif log_type == CombatLogType.ITEM:\n        print(f\"{entry.attacker_name} used {entry.inflictor_name}\")\n\n# Check type categories\nif log_type.is_economy_related:\n    print(\"Economy event\")\n</code></pre></p>"},{"location":"api/models/#damagetype","title":"DamageType","text":"<p>Enum for Dota 2 damage types.</p> <pre><code>class DamageType(int, Enum):\n    PHYSICAL = 0\n    MAGICAL = 1\n    PURE = 2\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Physical\") <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>DamageType \\| None</code> Get DamageType from integer value <p>Example: <pre><code>from python_manta import MantaParser, DamageType, CombatLogType\n\nparser = MantaParser()\nresult = parser.parse_combat_log(demo_path, types=[CombatLogType.DAMAGE], max_entries=100)\n\nfor entry in result.entries:\n    dmg_type = DamageType.from_value(entry.damage_type)\n    if dmg_type == DamageType.PURE:\n        print(f\"Pure damage: {entry.value} from {entry.inflictor_name}\")\n</code></pre></p>"},{"location":"api/models/#team","title":"Team","text":"<p>Enum for Dota 2 team identifiers.</p> <pre><code>class Team(int, Enum):\n    SPECTATOR = 0\n    UNASSIGNED = 1\n    RADIANT = 2\n    DIRE = 3\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Radiant\") <code>is_playing</code> bool True if this is an actual playing team <code>opposite</code> <code>Team \\| None</code> The opposing team (None for non-playing) <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>Team \\| None</code> Get Team from integer value <p>Example: <pre><code>from python_manta import MantaParser, Team, CombatLogType\n\nparser = MantaParser()\nresult = parser.parse_combat_log(demo_path, types=[CombatLogType.DEATH], heroes_only=True)\n\nfor entry in result.entries:\n    attacker_team = Team.from_value(entry.attacker_team)\n    target_team = Team.from_value(entry.target_team)\n\n    if attacker_team and target_team and attacker_team != target_team:\n        print(f\"{attacker_team.display_name} killed {target_team.display_name} hero\")\n\n    # Use opposite property\n    if attacker_team == Team.RADIANT:\n        enemy = attacker_team.opposite  # Team.DIRE\n</code></pre></p>"},{"location":"api/models/#neutralitemtier","title":"NeutralItemTier","text":"<p>Enum for neutral item tier classification. Tiers unlock at specific game times.</p> <pre><code>class NeutralItemTier(int, Enum):\n    TIER_1 = 0  # Unlocks at 5:00\n    TIER_2 = 1  # Unlocks at 15:00\n    TIER_3 = 2  # Unlocks at 25:00\n    TIER_4 = 3  # Unlocks at 35:00\n    TIER_5 = 4  # Unlocks at 55:00\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Tier 1\") <code>unlock_time_minutes</code> int Game time in minutes when tier unlocks <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>NeutralItemTier \\| None</code> Get tier from integer value (0-4) <p>Example: <pre><code>from python_manta import NeutralItemTier\n\ntier = NeutralItemTier.TIER_3\nprint(f\"{tier.display_name} unlocks at {tier.unlock_time_minutes} minutes\")\n# Output: Tier 3 unlocks at 25 minutes\n</code></pre></p>"},{"location":"api/models/#neutralitem","title":"NeutralItem","text":"<p>Comprehensive enum of all Dota 2 neutral items (100+ items), including both active items and retired/rotated items from previous patches. Useful for tracking neutral item pickups and usage.</p> <pre><code>class NeutralItem(str, Enum):\n    # Tier 1 - Current (7.38+)\n    CHIPPED_VEST = \"item_chipped_vest\"\n    DORMANT_CURIO = \"item_dormant_curio\"\n    KOBOLD_CUP = \"item_kobold_cup\"\n    # ... 100+ items including retired ones\n\n    # Tier 5 - Retired\n    APEX = \"item_apex\"\n    PIRATE_HAT = \"item_pirate_hat\"\n    # etc.\n</code></pre> <p>Properties:</p> Property Type Description <code>item_name</code> str Internal item name (e.g., \"item_kobold_cup\") <code>display_name</code> str Human-readable name (e.g., \"Kobold Cup\") <code>tier</code> int | None Item tier (0-4) or None for special items <code>tier_enum</code> NeutralItemTier | None Tier as enum <p>Class Methods:</p> Method Returns Description <code>from_item_name(name)</code> <code>NeutralItem \\| None</code> Get NeutralItem from internal name <code>is_neutral_item(name)</code> <code>bool</code> Check if item name is a neutral item <code>items_by_tier(tier)</code> <code>List[NeutralItem]</code> Get all items of a specific tier <code>all_item_names()</code> <code>List[str]</code> Get all neutral item internal names <p>Example: <pre><code>from python_manta import MantaParser, NeutralItem, NeutralItemTier, CombatLogType\n\nparser = MantaParser()\n\n# Track neutral item usage in combat log\nresult = parser.parse_combat_log(demo_path, types=[CombatLogType.ITEM], max_entries=1000)\n\nfor entry in result.entries:\n    if NeutralItem.is_neutral_item(entry.inflictor_name):\n        item = NeutralItem.from_item_name(entry.inflictor_name)\n        print(f\"{entry.attacker_name} used {item.display_name} (Tier {item.tier + 1})\")\n\n# Get all Tier 1 items\ntier1_items = NeutralItem.items_by_tier(0)\nprint(f\"Tier 1 has {len(tier1_items)} items\")\n\n# Check unlock times\ntier = NeutralItemTier.TIER_3\nprint(f\"{tier.display_name} items unlock at {tier.unlock_time_minutes} minutes\")\n</code></pre></p> <p>Tracking Neutral Item Drops: <pre><code># Use CDOTAUserMsg_FoundNeutralItem for neutral item pickups\nresult = parser.parse_universal(demo_path, \"FoundNeutralItem\", max_messages=100)\n\nfor msg in result.messages:\n    player_id = msg.data.get('player_id')\n    item_tier = msg.data.get('item_tier')  # 0-4\n    tier = NeutralItemTier.from_value(item_tier)\n    print(f\"Player {player_id} found a {tier.display_name} neutral item\")\n</code></pre></p>"},{"location":"api/models/#chatwheelmessage","title":"ChatWheelMessage","text":"<p>Enum for Dota 2 chat wheel message IDs. Maps voice line IDs to human-readable text.</p> <pre><code>class ChatWheelMessage(int, Enum):\n    # Standard phrases (0-232)\n    OK = 0\n    CAREFUL = 1\n    GET_BACK = 2\n    NEED_WARDS = 3\n    STUN_NOW = 4\n    HELP = 5\n    PUSH_NOW = 6\n    WELL_PLAYED = 7\n    # ... many more standard phrases\n    MY_BAD = 68\n    SPACE_CREATED = 71\n    BRUTAL_SAVAGE_REKT = 230\n    # Dota Plus lines: 11000+\n    # TI Battle Pass lines: 120000+\n    # TI talent/team lines: 401000+\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable message text <p>Class Methods:</p> Method Returns Description <code>from_id(id)</code> <code>ChatWheelMessage \\| None</code> Get enum from message ID <code>describe_id(id)</code> <code>str</code> Get description for any ID (including unmapped) <p>Example: <pre><code>from python_manta import MantaParser, ChatWheelMessage\n\nparser = MantaParser()\ngame_info = parser.parse_game_info(\"match.dem\")\nplayers = {i: p.player_name for i, p in enumerate(game_info.players)}\n\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatWheel\", 100)\n\nfor msg in result.messages:\n    player_id = msg.data.get('player_id', -1)\n    player_name = players.get(player_id, f'Player {player_id}')\n    msg_id = msg.data.get('chat_message_id', 0)\n\n    # Use enum for known IDs, describe_id for all\n    text = ChatWheelMessage.describe_id(msg_id)\n    print(f\"{player_name}: {text}\")\n\n# Output:\n# Malr1ne: TI Battle Pass Voice Line #120009\n# AMMAR_THE_F: &gt; Space created\n# Malr1ne: My bad\n</code></pre></p>"},{"location":"api/models/#gameactivity","title":"GameActivity","text":"<p>Enum for Dota 2 unit animation activity codes. Used in <code>CDOTAUserMsg_TE_UnitAnimation</code> messages to identify what animation a unit is playing. Useful for detecting taunts.</p> <pre><code>class GameActivity(int, Enum):\n    # Basic states\n    IDLE = 1500\n    IDLE_RARE = 1501\n    RUN = 1502\n    ATTACK = 1503\n    ATTACK2 = 1504\n    DIE = 1506\n    DISABLED = 1509\n    # Ability casting\n    CAST_ABILITY_1 = 1510\n    CAST_ABILITY_2 = 1511\n    # ... through CAST_ABILITY_6\n    # Channeling\n    CHANNEL_ABILITY_1 = 1520\n    # ... through CHANNEL_ABILITY_6\n    # Taunts\n    KILLTAUNT = 1535\n    TAUNT = 1536\n    TAUNT_SNIPER = 1641\n    TAUNT_SPECIAL = 1752\n    CUSTOM_TOWER_TAUNT = 1756\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable activity name <code>is_taunt</code> bool True if this is a taunt animation <code>is_attack</code> bool True if this is an attack animation <code>is_ability_cast</code> bool True if this is an ability cast <code>is_channeling</code> bool True if this is a channeling animation <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>GameActivity \\| None</code> Get activity from integer value <code>get_taunt_activities()</code> <code>List[GameActivity]</code> Get all taunt-related activities <p>Example: <pre><code>from python_manta import MantaParser, GameActivity\n\nparser = MantaParser()\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_TE_UnitAnimation\", 10000)\n\n# Find taunts\nfor msg in result.messages:\n    activity_code = msg.data.get('activity', 0)\n    activity = GameActivity.from_value(activity_code)\n\n    if activity and activity.is_taunt:\n        print(f\"Taunt detected at tick {msg.tick}: {activity.display_name}\")\n\n# Check activity types\nactivity = GameActivity.ATTACK\nprint(activity.is_attack)      # True\nprint(activity.is_ability_cast) # False\n</code></pre></p>"},{"location":"api/models/#header-models","title":"Header Models","text":""},{"location":"api/models/#headerinfo","title":"HeaderInfo","text":"<p>Match header metadata from the demo file.</p> <pre><code>class HeaderInfo(BaseModel):\n    map_name: str              # Map name (e.g., \"dota\")\n    server_name: str           # Server identifier\n    client_name: str           # Client type\n    game_directory: str        # Game directory path\n    network_protocol: int      # Network protocol version\n    demo_file_stamp: str       # Demo file signature\n    build_num: int             # Game build number\n    game: str                  # Game identifier\n    server_start_tick: int     # Server start tick\n    success: bool              # Parse success flag\n    error: Optional[str]       # Error message if failed\n</code></pre> <p>Example: <pre><code>header = parser.parse_header(\"match.dem\")\n\n# Access fields\nprint(header.map_name)\nprint(header.build_num)\n\n# Convert to dict\ndata = header.model_dump()\n\n# Convert to JSON\njson_str = header.model_dump_json()\n</code></pre></p>"},{"location":"api/models/#game-info-models","title":"Game Info Models","text":""},{"location":"api/models/#gameinfo","title":"GameInfo","text":"<p>Complete game information including draft, players, and teams.</p> <pre><code>class GameInfo(BaseModel):\n    # Basic match info\n    match_id: int              # Match ID\n    game_mode: int             # Game mode ID\n    game_winner: int           # Winner (2=Radiant, 3=Dire)\n    league_id: int             # League ID (0 for pub matches)\n    end_time: int              # End time (Unix timestamp)\n\n    # Team info (pro matches only - 0/empty for pubs)\n    radiant_team_id: int       # Radiant team ID\n    dire_team_id: int          # Dire team ID\n    radiant_team_tag: str      # Radiant team tag (e.g., \"OG\")\n    dire_team_tag: str         # Dire team tag (e.g., \"Secret\")\n\n    # Players\n    players: List[PlayerInfo]  # All players in match\n\n    # Draft\n    picks_bans: List[DraftEvent]  # Draft sequence\n\n    # Playback info\n    playback_time: float       # Total playback time in seconds\n    playback_ticks: int        # Total ticks\n    playback_frames: int       # Total frames\n\n    success: bool              # Parse success flag\n    error: Optional[str]       # Error message if failed\n</code></pre>"},{"location":"api/models/#draftevent","title":"DraftEvent","text":"<p>Single pick or ban event in the draft.</p> <pre><code>class DraftEvent(BaseModel):\n    is_pick: bool    # True for pick, False for ban\n    team: int        # 2 = Radiant, 3 = Dire\n    hero_id: int     # Hero ID (see Dota 2 Wiki for mappings)\n</code></pre>"},{"location":"api/models/#playerinfo","title":"PlayerInfo","text":"<p>Player information from match metadata.</p> <pre><code>class PlayerInfo(BaseModel):\n    hero_name: str           # Hero internal name (e.g., \"npc_dota_hero_axe\")\n    player_name: str         # Player display name\n    is_fake_client: bool     # True for bots\n    steam_id: int            # Player Steam ID\n    team: int                # Team (2=Radiant, 3=Dire)\n</code></pre> <p>Example: <pre><code>game_info = parser.parse_game_info(\"match.dem\")\n\n# Basic match info\nprint(f\"Match {game_info.match_id}\")\nprint(f\"Duration: {game_info.playback_time / 60:.1f} minutes\")\nwinner = \"Radiant\" if game_info.game_winner == 2 else \"Dire\"\nprint(f\"Winner: {winner}\")\n\n# Team info (pro matches)\nif game_info.league_id &gt; 0:\n    print(f\"League: {game_info.league_id}\")\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n\n# Players\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n\n# Draft\nradiant_picks = [e for e in game_info.picks_bans if e.is_pick and e.team == 2]\ndire_bans = [e for e in game_info.picks_bans if not e.is_pick and e.team == 3]\n\n# Hero IDs: 1=Anti-Mage, 2=Axe, etc.\nfor pick in radiant_picks:\n    print(f\"Radiant picked hero {pick.hero_id}\")\n</code></pre></p>"},{"location":"api/models/#universal-parse-models","title":"Universal Parse Models","text":""},{"location":"api/models/#universalparseresult","title":"UniversalParseResult","text":"<p>Result container for <code>parse_universal()</code>.</p> <pre><code>class UniversalParseResult(BaseModel):\n    messages: List[MessageEvent]  # Matched messages\n    success: bool                 # Parse success flag\n    error: Optional[str]          # Error message if failed\n    count: int                    # Number of messages\n</code></pre>"},{"location":"api/models/#messageevent","title":"MessageEvent","text":"<p>Single message from the replay.</p> <pre><code>class MessageEvent(BaseModel):\n    type: str                    # Callback name (e.g., \"CDOTAUserMsg_ChatMessage\")\n    tick: int                    # Game tick when message occurred\n    net_tick: int                # Network tick\n    data: Any                    # Message-specific data (dict)\n    timestamp: Optional[int]     # Unix timestamp in milliseconds\n</code></pre> <p>Example: <pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    # Access common fields\n    print(f\"Type: {msg.type}\")\n    print(f\"Tick: {msg.tick}\")\n\n    # Access message-specific data\n    player_id = msg.data.get('source_player_id')\n    text = msg.data.get('message_text')\n</code></pre></p>"},{"location":"api/models/#game-events-models","title":"Game Events Models","text":""},{"location":"api/models/#gameeventsresult","title":"GameEventsResult","text":"<p>Result container for <code>parse_game_events()</code>.</p> <pre><code>class GameEventsResult(BaseModel):\n    events: List[GameEventData]  # Parsed events\n    event_types: List[str]       # Event type definitions (if capture_types=True)\n    success: bool                # Parse success flag\n    error: Optional[str]         # Error message if failed\n    total_events: int            # Total events captured\n</code></pre>"},{"location":"api/models/#gameeventdata","title":"GameEventData","text":"<p>Single game event with typed fields.</p> <pre><code>class GameEventData(BaseModel):\n    name: str                     # Event name (e.g., \"dota_combatlog\")\n    tick: int                     # Game tick\n    net_tick: int                 # Network tick\n    fields: Dict[str, Any]        # Event-specific fields\n</code></pre> <p>Example: <pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=50)\n\nfor event in result.events:\n    print(f\"Event: {event.name}\")\n    print(f\"Tick: {event.tick}\")\n\n    # Fields depend on event type\n    for field_name, value in event.fields.items():\n        print(f\"  {field_name}: {value}\")\n</code></pre></p>"},{"location":"api/models/#combat-log-models","title":"Combat Log Models","text":""},{"location":"api/models/#combatlogresult","title":"CombatLogResult","text":"<p>Result container for <code>parse_combat_log()</code>.</p> <pre><code>class CombatLogResult(BaseModel):\n    entries: List[CombatLogEntry]  # Combat log entries\n    success: bool                  # Parse success flag\n    error: Optional[str]           # Error message if failed\n    total_entries: int             # Total entries captured\n</code></pre>"},{"location":"api/models/#combatlogentry","title":"CombatLogEntry","text":"<p>Single combat log entry with structured data.</p> <pre><code>class CombatLogEntry(BaseModel):\n    tick: int                     # Game tick\n    net_tick: int                 # Network tick\n    type: int                     # Combat log type ID\n    type_name: str                # Human-readable type name\n    target_name: str              # Target unit name\n    target_source_name: str       # Target source name\n    attacker_name: str            # Attacker unit name\n    damage_source_name: str       # Damage source name\n    inflictor_name: str           # Ability/item that caused this\n    is_attacker_illusion: bool    # Attacker is illusion\n    is_attacker_hero: bool        # Attacker is a hero\n    is_target_illusion: bool      # Target is illusion\n    is_target_hero: bool          # Target is a hero\n    is_visible_radiant: bool      # Visible to Radiant\n    is_visible_dire: bool         # Visible to Dire\n    value: int                    # Damage/heal value\n    health: int                   # Target health after\n    timestamp: float              # Game time in seconds\n    stun_duration: float          # Stun duration if applicable\n    slow_duration: float          # Slow duration if applicable\n    is_ability_toggle_on: bool    # Ability toggled on\n    is_ability_toggle_off: bool   # Ability toggled off\n    ability_level: int            # Ability level\n    xp: int                       # XP reason/amount\n    gold: int                     # Gold reason/amount\n    last_hits: int                # Last hits at time\n    attacker_team: int            # Attacker team ID\n    target_team: int              # Target team ID\n</code></pre> <p>Example: <pre><code>result = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=100)\n\nfor entry in result.entries:\n    if entry.type == 0:  # DAMAGE\n        print(f\"[{entry.timestamp:.1f}s] {entry.attacker_name} hit {entry.target_name} for {entry.value}\")\n</code></pre></p>"},{"location":"api/models/#modifier-models","title":"Modifier Models","text":""},{"location":"api/models/#modifiersresult","title":"ModifiersResult","text":"<p>Result container for <code>parse_modifiers()</code>.</p> <pre><code>class ModifiersResult(BaseModel):\n    modifiers: List[ModifierEntry]  # Modifier entries\n    success: bool                   # Parse success flag\n    error: Optional[str]            # Error message if failed\n    total_modifiers: int            # Total modifiers captured\n</code></pre>"},{"location":"api/models/#modifierentry","title":"ModifierEntry","text":"<p>Single modifier/buff entry.</p> <pre><code>class ModifierEntry(BaseModel):\n    tick: int               # Game tick\n    net_tick: int           # Network tick\n    parent: int             # Entity handle of unit with modifier\n    caster: int             # Entity handle of caster\n    ability: int            # Ability that created modifier\n    modifier_class: int     # Modifier class ID\n    serial_num: int         # Serial number\n    index: int              # Modifier index\n    creation_time: float    # When modifier was created\n    duration: float         # Duration in seconds (-1 = permanent)\n    stack_count: int        # Number of stacks\n    is_aura: bool           # Whether it's an aura\n    is_debuff: bool         # Whether it's a debuff\n</code></pre> <p>Example: <pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    print(f\"Entity {mod.parent}: duration={duration_str}, stacks={mod.stack_count}\")\n</code></pre></p>"},{"location":"api/models/#entity-models","title":"Entity Models","text":""},{"location":"api/models/#entitiesresult","title":"EntitiesResult","text":"<p>Result container for <code>query_entities()</code>.</p> <pre><code>class EntitiesResult(BaseModel):\n    entities: List[EntityData]  # Entity data\n    success: bool               # Parse success flag\n    error: Optional[str]        # Error message if failed\n    total_entities: int         # Total entities returned\n    tick: int                   # Tick when captured\n    net_tick: int               # Network tick when captured\n</code></pre>"},{"location":"api/models/#entitydata","title":"EntityData","text":"<p>Single entity with properties.</p> <pre><code>class EntityData(BaseModel):\n    index: int                    # Entity index\n    serial: int                   # Entity serial number\n    class_name: str               # Entity class name\n    properties: Dict[str, Any]    # Entity properties\n</code></pre> <p>Common Hero Properties:</p> Property Type Description <code>m_iHealth</code> int Current health <code>m_iMaxHealth</code> int Maximum health <code>m_flMana</code> float Current mana <code>m_flMaxMana</code> float Maximum mana <code>m_vecOrigin</code> list Position [x, y, z] <code>m_iCurrentLevel</code> int Hero level <code>m_iTotalEarnedGold</code> int Total gold earned <code>m_iKills</code> int Kills <code>m_iDeaths</code> int Deaths <code>m_iAssists</code> int Assists <p>Example: <pre><code>result = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    print(f\"\\n{entity.class_name} (index={entity.index})\")\n    print(f\"  Health: {entity.properties.get('m_iHealth')}/{entity.properties.get('m_iMaxHealth')}\")\n    print(f\"  Level: {entity.properties.get('m_iCurrentLevel')}\")\n</code></pre></p>"},{"location":"api/models/#string-table-models","title":"String Table Models","text":""},{"location":"api/models/#stringtablesresult","title":"StringTablesResult","text":"<p>Result container for <code>get_string_tables()</code>.</p> <pre><code>class StringTablesResult(BaseModel):\n    tables: Dict[str, List[StringTableData]]  # Table name -&gt; entries\n    table_names: List[str]                    # List of table names\n    success: bool                             # Parse success flag\n    error: Optional[str]                      # Error message if failed\n    total_entries: int                        # Total entries\n</code></pre>"},{"location":"api/models/#stringtabledata","title":"StringTableData","text":"<p>Single string table entry.</p> <pre><code>class StringTableData(BaseModel):\n    table_name: str         # Table name\n    index: int              # Entry index\n    key: str                # Entry key\n    value: Optional[str]    # Entry value (may be binary/base64)\n</code></pre>"},{"location":"api/models/#parser-info-model","title":"Parser Info Model","text":""},{"location":"api/models/#parserinfo","title":"ParserInfo","text":"<p>Parser state information.</p> <pre><code>class ParserInfo(BaseModel):\n    game_build: int           # Game build number\n    tick: int                 # Final parser tick\n    net_tick: int             # Final network tick\n    string_tables: List[str]  # List of string table names\n    entity_count: int         # Number of entities\n    success: bool             # Parse success flag\n    error: Optional[str]      # Error message if failed\n</code></pre> <p>Example: <pre><code>info = parser.get_parser_info(\"match.dem\")\n\nprint(f\"Game lasted {info.tick} ticks\")\nprint(f\"Final entity count: {info.entity_count}\")\nprint(f\"String tables: {', '.join(info.string_tables)}\")\n</code></pre></p>"},{"location":"api/models/#serialization","title":"Serialization","text":"<p>All models support Pydantic serialization:</p> <pre><code># To dictionary\ndata = model.model_dump()\n\n# To JSON string\njson_str = model.model_dump_json()\n\n# From dictionary\nmodel = HeaderInfo.model_validate(data)\n\n# From JSON\nmodel = HeaderInfo.model_validate_json(json_str)\n</code></pre>"},{"location":"guides/","title":"Guides","text":"AI Summary <p>In-depth guides for using Python Manta's features. Covers game events parsing (364 event types like kills, damage, abilities), combat log analysis (structured damage/heal/death data), entity queries (hero stats, positions, items), and modifier tracking (buffs, debuffs, auras). Each guide includes practical examples and common use cases.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":"Guide Description Unit Orders Detect attack commands, creep aggro triggers, and player inputs Game Events Parse 364 Source 1 game event types Combat Log Analyze damage, heals, deaths, and kills Entity Queries Query hero/unit state and properties Modifiers Track buffs, debuffs, and auras Universal Messages Parse any of 272 message callbacks"},{"location":"guides/#choosing-the-right-api","title":"Choosing the Right API","text":"What You Need API Guide Match metadata <code>parse_header()</code> Getting Started Draft picks/bans <code>parse_game_info()</code> Getting Started Hero positions over time <code>parse_entities(target_ticks=[...])</code> Entities Death positions <code>parse_entities(target_ticks=[death.tick])</code> Entities Creep aggro triggers <code>parse_universal(\"SpectatorPlayerUnitOrders\")</code> Unit Orders Attack commands <code>parse_universal(\"SpectatorPlayerUnitOrders\")</code> Unit Orders Chat messages <code>parse_universal(\"CDOTAUserMsg_ChatMessage\")</code> Universal Item purchases <code>parse_universal(\"CDOTAUserMsg_ItemPurchased\")</code> Universal Map pings <code>parse_universal(\"CDOTAUserMsg_LocationPing\")</code> Universal Damage dealt <code>parse_combat_log(types=[0])</code> Combat Log Deaths/kills <code>parse_combat_log(types=[4])</code> Combat Log Hero state (end of game) <code>query_entities(class_filter=\"Hero\")</code> Entities Buff tracking <code>parse_modifiers()</code> Modifiers Kill events <code>parse_game_events(event_filter=\"dota_player_kill\")</code> Game Events Rune pickups <code>parse_game_events(event_filter=\"dota_rune\")</code> Game Events Player info <code>get_string_tables(table_names=[\"userinfo\"])</code> API Reference"},{"location":"guides/combat-log/","title":"Combat Log Guide","text":"AI Summary <p>Parse structured combat log entries with <code>parse_combat_log()</code>. Use <code>CombatLogType</code> enum for filtering (DAMAGE, HEAL, MODIFIER_ADD, DEATH, ABILITY, ITEM, PURCHASE, etc.). 80+ fields per entry including health tracking, stun/slow durations, assist players, damage types, hero levels, and location. Use <code>heroes_only=True</code> for hero-related entries. Additional enums: <code>DamageType</code> (PHYSICAL, MAGICAL, PURE), <code>Team</code> (RADIANT, DIRE). The <code>game_time</code> field provides accurate in-game clock time (can be negative for pre-game events). The <code>value_name</code> field resolves item names for PURCHASE events.</p>"},{"location":"guides/combat-log/#overview","title":"Overview","text":"<p>The combat log provides structured data about damage, healing, deaths, and other combat-related events with rich metadata.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_combat_log(\"match.dem\", max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.type_name}: {entry.attacker_name} -&gt; {entry.target_name}\")\n</code></pre>"},{"location":"guides/combat-log/#combat-log-types","title":"Combat Log Types","text":"ID Type Name Description 0 DOTA_COMBATLOG_DAMAGE Damage dealt to units 1 DOTA_COMBATLOG_HEAL Healing received 2 DOTA_COMBATLOG_MODIFIER_ADD Buff/debuff applied 3 DOTA_COMBATLOG_MODIFIER_REMOVE Buff/debuff removed 4 DOTA_COMBATLOG_DEATH Unit death 5 DOTA_COMBATLOG_ABILITY Ability cast 6 DOTA_COMBATLOG_ITEM Item used 7 DOTA_COMBATLOG_LOCATION Location event 8 DOTA_COMBATLOG_GOLD Gold gained 9 DOTA_COMBATLOG_GAME_STATE Game state change 10 DOTA_COMBATLOG_XP Experience gained 11 DOTA_COMBATLOG_PURCHASE Item purchased 12 DOTA_COMBATLOG_BUYBACK Buyback used 13 DOTA_COMBATLOG_ABILITY_TRIGGER Ability triggered 14 DOTA_COMBATLOG_PLAYERSTATS Player statistics 15 DOTA_COMBATLOG_MULTIKILL Multi-kill event 16 DOTA_COMBATLOG_KILLSTREAK Kill streak 17 DOTA_COMBATLOG_TEAM_BUILDING_KILL Building destroyed 18 DOTA_COMBATLOG_FIRST_BLOOD First blood 19 DOTA_COMBATLOG_MODIFIER_REFRESH Modifier refreshed 20 DOTA_COMBATLOG_NEUTRAL_CAMP_STACK Camp stacked 21 DOTA_COMBATLOG_PICKUP_RUNE Rune picked up 22 DOTA_COMBATLOG_REVEALED_INVISIBLE Invisibility revealed 23 DOTA_COMBATLOG_HERO_SAVED Hero saved from death 24 DOTA_COMBATLOG_MANA_RESTORED Mana restored 25 DOTA_COMBATLOG_HERO_LEVELUP Hero level up 26 DOTA_COMBATLOG_BOTTLE_HEAL_ALLY Bottle heal ally 27 DOTA_COMBATLOG_ENDGAME_STATS End game statistics 28 DOTA_COMBATLOG_INTERRUPT_CHANNEL Channel interrupted 29 DOTA_COMBATLOG_ALLIED_GOLD Allied gold 30 DOTA_COMBATLOG_AEGIS_TAKEN Aegis taken 31 DOTA_COMBATLOG_MANA_DAMAGE Mana burned 32 DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED Physical damage blocked 33 DOTA_COMBATLOG_UNIT_SUMMONED Unit summoned 34 DOTA_COMBATLOG_ATTACK_EVADE Attack evaded 35 DOTA_COMBATLOG_TREE_CUT Tree cut 36 DOTA_COMBATLOG_SUCCESSFUL_SCAN Successful scan 37 DOTA_COMBATLOG_END_KILLSTREAK Kill streak ended 38 DOTA_COMBATLOG_BLOODSTONE_CHARGE Bloodstone charge 39 DOTA_COMBATLOG_CRITICAL_DAMAGE Critical damage 40 DOTA_COMBATLOG_SPELL_ABSORB Spell absorbed 41 DOTA_COMBATLOG_UNIT_TELEPORTED Unit teleported 42 DOTA_COMBATLOG_KILL_EATER_EVENT Kill eater (gem) event 43 DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED Neutral item earned 44 DOTA_COMBATLOG_TELEPORT_INTERRUPTED Teleport interrupted"},{"location":"guides/combat-log/#filtering-by-type","title":"Filtering by Type","text":""},{"location":"guides/combat-log/#damage-only","title":"Damage Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[0], max_entries=500)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.attacker_name} dealt {entry.value} damage to {entry.target_name}\")\n    if entry.inflictor_name:\n        print(f\"  via {entry.inflictor_name}\")\n</code></pre>"},{"location":"guides/combat-log/#healing-only","title":"Healing Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=200)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.target_name} healed for {entry.value}\")\n    if entry.inflictor_name:\n        print(f\"  from {entry.inflictor_name}\")\n</code></pre>"},{"location":"guides/combat-log/#deaths-only","title":"Deaths Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[4], max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.target_name} was killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"guides/combat-log/#multiple-types","title":"Multiple Types","text":"<pre><code># Damage and deaths together\nresult = parser.parse_combat_log(\"match.dem\", types=[0, 4], max_entries=500)\n\nfor entry in result.entries:\n    if entry.type == 0:\n        print(f\"[{entry.timestamp:.1f}s] DAMAGE: {entry.attacker_name} -&gt; {entry.target_name} ({entry.value})\")\n    elif entry.type == 4:\n        print(f\"[{entry.timestamp:.1f}s] DEATH: {entry.target_name} killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"guides/combat-log/#hero-only-filtering","title":"Hero-Only Filtering","text":"<p>Filter to only include entries where the attacker or target is a hero:</p> <pre><code>result = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\n\nfor entry in result.entries:\n    hero_indicator = \"\"\n    if entry.is_attacker_hero:\n        hero_indicator += \"[HERO ATK] \"\n    if entry.is_target_hero:\n        hero_indicator += \"[HERO TGT] \"\n\n    print(f\"{hero_indicator}{entry.attacker_name} -&gt; {entry.target_name}\")\n</code></pre>"},{"location":"guides/combat-log/#combining-filters","title":"Combining Filters","text":"<pre><code># Hero damage only\nresult = parser.parse_combat_log(\n    \"match.dem\",\n    types=[0],           # Damage\n    heroes_only=True,    # Hero involvement\n    max_entries=500\n)\n</code></pre>"},{"location":"guides/combat-log/#entry-fields-80-total","title":"Entry Fields (80+ Total)","text":"<p>Each <code>CombatLogEntry</code> contains comprehensive data for fight analysis:</p>"},{"location":"guides/combat-log/#core-fields","title":"Core Fields","text":"Field Type Description <code>tick</code> int Game tick <code>net_tick</code> int Network tick <code>type</code> int Combat log type ID (0-44) <code>type_name</code> str Human-readable type name <code>timestamp</code> float Replay time in seconds (includes draft/pre-game) <code>timestamp_raw</code> float Raw timestamp value <code>game_time</code> float In-game clock time (0:00 = creep spawn, can be negative for pre-game)"},{"location":"guides/combat-log/#participant-fields","title":"Participant Fields","text":"Field Type Description <code>target_name</code> str Target unit name (e.g., \"npc_dota_hero_pudge\") <code>target_source_name</code> str Target's source name <code>attacker_name</code> str Attacker unit name <code>damage_source_name</code> str Damage source name <code>inflictor_name</code> str Ability/item that caused this"},{"location":"guides/combat-log/#participant-flags","title":"Participant Flags","text":"Field Type Description <code>is_attacker_illusion</code> bool Attacker is an illusion <code>is_attacker_hero</code> bool Attacker is a hero <code>is_target_illusion</code> bool Target is an illusion <code>is_target_hero</code> bool Target is a hero <code>is_target_building</code> bool Target is a building"},{"location":"guides/combat-log/#combat-values","title":"Combat Values","text":"Field Type Description <code>value</code> int Damage/heal amount (or string table index for PURCHASE events) <code>value_name</code> str Resolved name from CombatLogNames (e.g., item name for PURCHASE) <code>health</code> int Target HP after this event <code>damage_type</code> int Damage type (physical/magical/pure) <code>damage_category</code> int Damage category"},{"location":"guides/combat-log/#cc-durations","title":"CC Durations","text":"Field Type Description <code>stun_duration</code> float Stun duration in seconds <code>slow_duration</code> float Slow duration in seconds <code>modifier_duration</code> float Total modifier duration <code>modifier_elapsed_duration</code> float How long modifier has been active"},{"location":"guides/combat-log/#location","title":"Location","text":"Field Type Description <code>location_x</code> float X coordinate on map <code>location_y</code> float Y coordinate on map"},{"location":"guides/combat-log/#assist-tracking","title":"Assist Tracking","text":"Field Type Description <code>assist_player0</code> int First assist player ID <code>assist_player1</code> int Second assist player ID <code>assist_player2</code> int Third assist player ID <code>assist_player3</code> int Fourth assist player ID <code>assist_players</code> List[int] All assist player IDs"},{"location":"guides/combat-log/#modifier-fields","title":"Modifier Fields","text":"Field Type Description <code>root_modifier</code> bool Is a root effect <code>silence_modifier</code> bool Is a silence effect <code>aura_modifier</code> bool Is an aura <code>armor_debuff_modifier</code> bool Is armor reduction <code>motion_controller_modifier</code> bool Is motion control (knockback) <code>invisibility_modifier</code> bool Grants invisibility <code>hidden_modifier</code> bool Is hidden modifier <code>modifier_hidden</code> bool Modifier is hidden from UI <code>modifier_purged</code> bool Modifier was purged <code>no_physical_damage_modifier</code> bool Blocks physical damage <code>modifier_ability</code> int Ability index in CombatLogNames <code>modifier_ability_name</code> str Resolved ability name that applied this modifier <code>modifier_purge_ability</code> int Ability index that purged this modifier <code>modifier_purge_ability_name</code> str Resolved ability name that purged this modifier <code>modifier_purge_npc</code> int NPC index that purged this modifier <code>modifier_purge_npc_name</code> str Resolved NPC name that purged this modifier"},{"location":"guides/combat-log/#ability-info","title":"Ability Info","text":"Field Type Description <code>ability_level</code> int Ability level (1-4+) <code>is_ability_toggle_on</code> bool Ability toggled on <code>is_ability_toggle_off</code> bool Ability toggled off <code>is_ultimate_ability</code> bool Is an ultimate ability <code>inflictor_is_stolen_ability</code> bool Ability was stolen (Rubick) <code>spell_generated_attack</code> bool Attack from spell <code>uses_charges</code> bool Ability uses charges"},{"location":"guides/combat-log/#killdeath-info","title":"Kill/Death Info","text":"Field Type Description <code>spell_evaded</code> bool Spell was evaded <code>long_range_kill</code> bool Long range kill <code>will_reincarnate</code> bool Target will reincarnate (Aegis/WK) <code>total_unit_death_count</code> int Total deaths of this unit type <code>heal_from_lifesteal</code> bool Heal is from lifesteal <code>is_heal_save</code> bool Heal prevented death"},{"location":"guides/combat-log/#hero-state","title":"Hero State","text":"Field Type Description <code>attacker_hero_level</code> int Attacker's hero level <code>target_hero_level</code> int Target's hero level <code>attacker_has_scepter</code> bool Attacker has Aghanim's Scepter <code>attacker_team</code> int Attacker team (2=Radiant, 3=Dire) <code>target_team</code> int Target team"},{"location":"guides/combat-log/#visibility","title":"Visibility","text":"Field Type Description <code>is_visible_radiant</code> bool Visible to Radiant team <code>is_visible_dire</code> bool Visible to Dire team <code>at_night_time</code> bool Event occurred at night"},{"location":"guides/combat-log/#economy","title":"Economy","text":"Field Type Description <code>xp</code> int XP gained/reason <code>gold</code> int Gold gained/reason <code>last_hits</code> int Last hits at time <code>networth</code> int Player networth <code>xpm</code> int XP per minute <code>gpm</code> int Gold per minute"},{"location":"guides/combat-log/#additional","title":"Additional","text":"Field Type Description <code>stack_count</code> int Modifier stack count <code>building_type</code> int Building type ID <code>neutral_camp_type</code> int Neutral camp type <code>neutral_camp_team</code> int Neutral camp team <code>rune_type</code> int Rune type <code>obs_wards_placed</code> int Observer wards placed <code>regenerated_health</code> float Health regenerated <code>target_is_self</code> bool Target is self"},{"location":"guides/combat-log/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/combat-log/#dps-analysis","title":"DPS Analysis","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=5000)\n\ndamage_dealt = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.is_attacker_hero:\n        damage_dealt[entry.attacker_name] += entry.value\n\nprint(\"Total Damage Dealt by Hero:\")\nfor hero, damage in sorted(damage_dealt.items(), key=lambda x: -x[1]):\n    print(f\"  {hero}: {damage:,}\")\n</code></pre>"},{"location":"guides/combat-log/#kill-feed-reconstruction","title":"Kill Feed Reconstruction","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[4], heroes_only=True, max_entries=100)\n\nprint(\"Kill Feed:\")\nprint(\"-\" * 60)\n\nfor entry in result.entries:\n    timestamp_min = int(entry.timestamp // 60)\n    timestamp_sec = int(entry.timestamp % 60)\n    print(f\"[{timestamp_min:02d}:{timestamp_sec:02d}] {entry.attacker_name} killed {entry.target_name}\")\n</code></pre>"},{"location":"guides/combat-log/#ability-usage-tracking","title":"Ability Usage Tracking","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[5], max_entries=1000)\n\nability_usage = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.inflictor_name:\n        ability_usage[entry.inflictor_name] += 1\n\nprint(\"Most Used Abilities:\")\nfor ability, count in sorted(ability_usage.items(), key=lambda x: -x[1])[:20]:\n    print(f\"  {ability}: {count}\")\n</code></pre>"},{"location":"guides/combat-log/#gold-economy","title":"Gold Economy","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[7], max_entries=2000)\n\ngold_gained = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.is_target_hero:\n        gold_gained[entry.target_name] += entry.gold\n\nprint(\"Gold Gained:\")\nfor hero, gold in sorted(gold_gained.items(), key=lambda x: -x[1]):\n    print(f\"  {hero}: {gold:,}\")\n</code></pre>"},{"location":"guides/combat-log/#healing-analysis","title":"Healing Analysis","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=2000)\n\nhealing_received = defaultdict(int)\nhealing_sources = defaultdict(lambda: defaultdict(int))\n\nfor entry in result.entries:\n    healing_received[entry.target_name] += entry.value\n    if entry.inflictor_name:\n        healing_sources[entry.target_name][entry.inflictor_name] += entry.value\n\nprint(\"Healing Received:\")\nfor unit, total in sorted(healing_received.items(), key=lambda x: -x[1])[:10]:\n    print(f\"\\n{unit}: {total:,} total\")\n    for source, amount in sorted(healing_sources[unit].items(), key=lambda x: -x[1])[:3]:\n        print(f\"    {source}: {amount:,}\")\n</code></pre>"},{"location":"guides/combat-log/#important-notes","title":"Important Notes","text":""},{"location":"guides/combat-log/#game-time-vs-replay-time","title":"Game Time vs Replay Time","text":"<p>The combat log provides two timing fields:</p> Field Description <code>timestamp</code> Replay time - seconds since replay recording started (includes draft/pre-game) <code>game_time</code> In-game clock time - what you see on the game clock (0:00 = creep spawn) <p>Use <code>game_time</code> for game clock</p> <p>The <code>game_time</code> field automatically calculates the in-game clock time. It detects when the game transitions to <code>GAME_IN_PROGRESS</code> state and computes the offset.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_combat_log(\"match.dem\", types=[11], max_entries=100)  # PURCHASE events\n\nfor entry in result.entries:\n    # game_time is already the in-game clock time\n    mins = int(abs(entry.game_time) // 60)\n    secs = int(abs(entry.game_time)) % 60\n    sign = \"-\" if entry.game_time &lt; 0 else \"\"\n    print(f\"{sign}{mins:02d}:{secs:02d} - {entry.value_name}\")\n</code></pre>"},{"location":"guides/combat-log/#pre-game-events-negative-game-time","title":"Pre-Game Events (Negative Game Time)","text":"<p>Events during the 90-second pre-game countdown have negative <code>game_time</code> values:</p> <pre><code>result = parser.parse_combat_log(\"match.dem\", types=[11], max_entries=200)  # PURCHASE\n\n# Pre-game purchases (during countdown)\npregame = [e for e in result.entries if e.game_time &lt; 0]\nprint(f\"Pre-game purchases: {len(pregame)}\")\n\nfor entry in pregame[:5]:\n    mins = int(abs(entry.game_time) // 60)\n    secs = int(abs(entry.game_time)) % 60\n    hero = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n    item = entry.value_name.replace(\"item_\", \"\")\n    print(f\"-{mins:02d}:{secs:02d} - {hero}: {item}\")\n# Output:\n# -01:29 - antimage: ward_observer\n# -01:28 - troll_warlord: tango\n# -01:27 - crystal_maiden: blood_grenade\n</code></pre>"},{"location":"guides/combat-log/#game-start-time","title":"Game Start Time","text":"<p>The <code>CombatLogResult</code> includes <code>game_start_time</code> which is the replay timestamp when the game clock hit 0:00:</p> <pre><code>result = parser.parse_combat_log(\"match.dem\", types=[18], max_entries=1)  # First blood\n\nprint(f\"Game started at replay time: {result.game_start_time:.1f}s\")\n\nif result.entries:\n    entry = result.entries[0]\n    print(f\"First blood at {entry.game_time:.0f}s game time\")\n</code></pre>"},{"location":"guides/combat-log/#illusion-filtering","title":"Illusion Filtering","text":"<pre><code># Filter out illusion damage for accurate stats\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=5000)\n\nreal_damage = [\n    entry for entry in result.entries\n    if not entry.is_attacker_illusion and not entry.is_target_illusion\n]\n\nprint(f\"Total entries: {len(result.entries)}\")\nprint(f\"Real damage entries (no illusions): {len(real_damage)}\")\n</code></pre>"},{"location":"guides/combat-log/#combat-log-vs-game-events","title":"Combat Log vs Game Events","text":"Aspect Combat Log Game Events API <code>parse_combat_log()</code> <code>parse_game_events()</code> Structure Fixed schema with 80+ fields Variable fields per event type Types 45 log types 364 event types Best for Detailed damage/heal analysis Discrete game occurrences Timing Full match (timestamp is replay time) Full match Filtering By type ID, heroes_only By event name <p>Use combat log for continuous combat data (DPS, healing totals) and game events for discrete occurrences (tower kills, rune pickups).</p>"},{"location":"guides/combat-log/#available-data-fields","title":"Available Data Fields","text":"<p>The combat log exposes raw data that can be used by other tools for analysis or narrative generation.</p>"},{"location":"guides/combat-log/#data-available-per-event","title":"Data Available Per Event","text":"Data Point Field Notes HP after event <code>health</code> Target's HP after this event Damage/heal amount <code>value</code> Raw numeric value Ability/item name <code>inflictor_name</code> Internal name (e.g., \"pugna_nether_blast\") Item name (PURCHASE) <code>value_name</code> Resolved item name for PURCHASE events Ability level <code>ability_level</code> 1-4+ Assist player IDs <code>assist_players</code> List of player IDs Stun duration <code>stun_duration</code> Seconds Slow duration <code>slow_duration</code> Seconds Root applied <code>root_modifier</code> Boolean Lifesteal heal <code>heal_from_lifesteal</code> Boolean Will reincarnate <code>will_reincarnate</code> Boolean (Aegis/WK) Night time <code>at_night_time</code> Boolean Has Aghanim's <code>attacker_has_scepter</code> Boolean Hero levels <code>attacker_hero_level</code>, <code>target_hero_level</code> Integer Position <code>location_x</code>, <code>location_y</code> Map coordinates Game time <code>game_time</code> In-game clock time (can be negative for pre-game) Replay timestamp <code>timestamp</code> Replay time in seconds"},{"location":"guides/combat-log/#data-not-available-in-combat-log","title":"Data NOT Available in Combat Log","text":"Data Point Notes <code>stack_count</code> Always 0 - Valve doesn't populate this field <code>uses_charges</code> Always false - Valve doesn't populate this field Cooldowns Not in combat log Mana costs Not in combat log Exact max HP Only current HP after event <p>Getting Item Charges</p> <p>The combat log <code>stack_count</code> field is NOT populated by Valve. To get actual item charges (e.g., Magic Stick/Wand), use entity queries instead:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\ndef get_magic_stick_charges(demo_path: str, at_tick: int = 0) -&gt; dict:\n    \"\"\"\n    Get magic stick/wand charges for all players at a specific game tick.\n\n    Args:\n        demo_path: Path to the .dem file\n        at_tick: Game tick to query (0 = end of game)\n\n    Returns:\n        Dict mapping player_id -&gt; charges\n    \"\"\"\n    result = parser.query_entities(\n        demo_path,\n        class_names=['CDOTA_Item_MagicStick', 'CDOTA_Item_MagicWand'],\n        property_filter=['m_iCurrentCharges', 'm_iPlayerOwnerID'],\n        at_tick=at_tick\n    )\n\n    player_charges = {}\n    for entity in result.entities:\n        owner = entity.properties.get('m_iPlayerOwnerID', -1)\n        charges = entity.properties.get('m_iCurrentCharges', 0)\n        if owner &gt;= 0:\n            player_charges[owner] = max(player_charges.get(owner, 0), charges)\n\n    return player_charges\n\n# Get charges at a specific tick\ncharges = get_magic_stick_charges(\"match.dem\", at_tick=50000)\n# {0: 6, 2: 18, 4: 7, 6: 6, 8: 1, 10: 15, 12: 4, 14: 20, 16: 0, 18: 5}\n</code></pre> <p>Alternative: Calculate charges from HEAL event value (Magic Stick/Wand heal 15 HP per charge):</p> <pre><code># From a combat log HEAL entry with inflictor_name containing \"magic_stick\" or \"magic_wand\"\ncharges_used = entry.value // 15  # e.g., 150 HP healed = 10 charges\n</code></pre>"},{"location":"guides/entities/","title":"Entity Queries Guide","text":"AI Summary <p>Query game entities using <code>query_entities()</code>. Filter by class name (substring or exact match) and select specific properties. Use <code>at_tick</code> to query at a specific game tick (default: end of game). Common classes: <code>Hero</code> (player heroes), <code>Tower</code>, <code>Courier</code>, <code>Creep</code>, <code>CDOTA_Item_MagicStick</code>, <code>CDOTA_Item_MagicWand</code>. Hero properties include <code>m_iHealth</code>, <code>m_iMaxHealth</code>, <code>m_flMana</code>, <code>m_vecOrigin</code> (position). Item properties include <code>m_iCurrentCharges</code>, <code>m_iPlayerOwnerID</code>. Use property_filter for performance.</p>"},{"location":"guides/entities/#overview","title":"Overview","text":"<p>Entity queries let you extract game state from the replay, including hero stats, positions, items, and unit properties.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    health = entity.properties.get(\"m_iHealth\", 0)\n    max_hp = entity.properties.get(\"m_iMaxHealth\", 0)\n    print(f\"{entity.class_name}: {health}/{max_hp} HP\")\n</code></pre>"},{"location":"guides/entities/#filtering-by-class","title":"Filtering by Class","text":""},{"location":"guides/entities/#substring-filter","title":"Substring Filter","text":"<pre><code># All entities with \"Hero\" in class name\nheroes = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=20)\n\n# All tower entities\ntowers = parser.query_entities(\"match.dem\", class_filter=\"Tower\", max_entities=30)\n\n# All courier entities\ncouriers = parser.query_entities(\"match.dem\", class_filter=\"Courier\", max_entities=10)\n</code></pre>"},{"location":"guides/entities/#exact-class-names","title":"Exact Class Names","text":"<pre><code># Specific hero classes\nresult = parser.query_entities(\n    \"match.dem\",\n    class_names=[\n        \"CDOTA_Unit_Hero_Invoker\",\n        \"CDOTA_Unit_Hero_Pudge\",\n        \"CDOTA_Unit_Hero_AntiMage\"\n    ],\n    max_entities=10\n)\n\n# Specific building types\nbuildings = parser.query_entities(\n    \"match.dem\",\n    class_names=[\n        \"CDOTA_BaseNPC_Tower\",\n        \"CDOTA_BaseNPC_Barracks\",\n        \"CDOTA_BaseNPC_Fort\"\n    ],\n    max_entities=50\n)\n</code></pre>"},{"location":"guides/entities/#property-filtering","title":"Property Filtering","text":"<p>For better performance, specify only the properties you need:</p> <pre><code># Only get health and position\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_vecOrigin\"],\n    max_entities=10\n)\n\nfor entity in result.entities:\n    pos = entity.properties.get(\"m_vecOrigin\", [0, 0, 0])\n    print(f\"{entity.class_name} at ({pos[0]:.0f}, {pos[1]:.0f})\")\n</code></pre>"},{"location":"guides/entities/#common-entity-classes","title":"Common Entity Classes","text":"Class Pattern Description <code>Hero</code> Player-controlled heroes <code>Tower</code> Tower buildings <code>Barracks</code> Barracks buildings <code>Fort</code> Ancient/Throne <code>Courier</code> Courier units <code>Creep</code> Lane creeps <code>NeutralCreep</code> Jungle creeps <code>Roshan</code> Roshan <code>Ward</code> Observer/Sentry wards"},{"location":"guides/entities/#hero-properties","title":"Hero Properties","text":""},{"location":"guides/entities/#core-stats","title":"Core Stats","text":"Property Type Description <code>m_iHealth</code> int Current health <code>m_iMaxHealth</code> int Maximum health <code>m_flMana</code> float Current mana <code>m_flMaxMana</code> float Maximum mana <code>m_iCurrentLevel</code> int Hero level <code>m_flStrength</code> float Strength attribute <code>m_flAgility</code> float Agility attribute <code>m_flIntellect</code> float Intelligence attribute"},{"location":"guides/entities/#position-and-movement","title":"Position and Movement","text":"Property Type Description <code>m_vecOrigin</code> list[float] Position [x, y, z] <code>m_angRotation</code> list[float] Rotation angles <code>m_flMovementSpeed</code> float Movement speed"},{"location":"guides/entities/#economy","title":"Economy","text":"Property Type Description <code>m_iTotalEarnedGold</code> int Total gold earned <code>m_iUnreliableGold</code> int Unreliable gold <code>m_iReliableGold</code> int Reliable gold <code>m_iLastHits</code> int Last hits <code>m_iDenies</code> int Denies"},{"location":"guides/entities/#kda","title":"KDA","text":"Property Type Description <code>m_iKills</code> int Kills <code>m_iDeaths</code> int Deaths <code>m_iAssists</code> int Assists"},{"location":"guides/entities/#combat","title":"Combat","text":"Property Type Description <code>m_flPhysicalArmorValue</code> float Armor <code>m_flMagicalResistanceValue</code> float Magic resistance <code>m_iDamageMin</code> int Minimum damage <code>m_iDamageMax</code> int Maximum damage <code>m_iAttackRange</code> int Attack range"},{"location":"guides/entities/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/entities/#end-game-scoreboard","title":"End Game Scoreboard","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\n        \"m_iCurrentLevel\",\n        \"m_iKills\", \"m_iDeaths\", \"m_iAssists\",\n        \"m_iTotalEarnedGold\", \"m_iLastHits\", \"m_iDenies\"\n    ],\n    max_entities=10\n)\n\nprint(\"End Game Scoreboard:\")\nprint(\"-\" * 70)\nprint(f\"{'Hero':&lt;30} {'Lvl':&gt;4} {'K':&gt;3} {'D':&gt;3} {'A':&gt;3} {'LH':&gt;5} {'Gold':&gt;8}\")\nprint(\"-\" * 70)\n\nfor entity in result.entities:\n    props = entity.properties\n    print(f\"{entity.class_name:&lt;30} \"\n          f\"{props.get('m_iCurrentLevel', 0):&gt;4} \"\n          f\"{props.get('m_iKills', 0):&gt;3} \"\n          f\"{props.get('m_iDeaths', 0):&gt;3} \"\n          f\"{props.get('m_iAssists', 0):&gt;3} \"\n          f\"{props.get('m_iLastHits', 0):&gt;5} \"\n          f\"{props.get('m_iTotalEarnedGold', 0):&gt;8,}\")\n</code></pre>"},{"location":"guides/entities/#hero-positions-map","title":"Hero Positions Map","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_vecOrigin\", \"m_iTeamNum\"],\n    max_entities=10\n)\n\nprint(\"Hero Positions (end of game):\")\nfor entity in result.entities:\n    pos = entity.properties.get(\"m_vecOrigin\", [0, 0, 0])\n    team = entity.properties.get(\"m_iTeamNum\", 0)\n    team_name = \"Radiant\" if team == 2 else \"Dire\" if team == 3 else \"Unknown\"\n\n    print(f\"{entity.class_name}: ({pos[0]:.0f}, {pos[1]:.0f}) - {team_name}\")\n</code></pre>"},{"location":"guides/entities/#building-status","title":"Building Status","text":"<pre><code># Check tower status\ntowers = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Tower\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_iTeamNum\"],\n    max_entities=30\n)\n\nprint(\"Tower Status:\")\nradiant_towers = 0\ndire_towers = 0\n\nfor tower in towers.entities:\n    health = tower.properties.get(\"m_iHealth\", 0)\n    max_health = tower.properties.get(\"m_iMaxHealth\", 0)\n    team = tower.properties.get(\"m_iTeamNum\", 0)\n\n    if health &gt; 0:\n        if team == 2:\n            radiant_towers += 1\n        elif team == 3:\n            dire_towers += 1\n\nprint(f\"Radiant towers remaining: {radiant_towers}\")\nprint(f\"Dire towers remaining: {dire_towers}\")\n</code></pre>"},{"location":"guides/entities/#item-slots","title":"Item Slots","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\n        \"m_hItems.0000\", \"m_hItems.0001\", \"m_hItems.0002\",\n        \"m_hItems.0003\", \"m_hItems.0004\", \"m_hItems.0005\"\n    ],\n    max_entities=10\n)\n\nfor entity in result.entities:\n    print(f\"\\n{entity.class_name} items:\")\n    for i in range(6):\n        item_handle = entity.properties.get(f\"m_hItems.{i:04d}\")\n        if item_handle and item_handle != 16777215:  # Invalid handle\n            print(f\"  Slot {i}: {item_handle}\")\n</code></pre>"},{"location":"guides/entities/#neutral-creeps","title":"Neutral Creeps","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"NeutralCreep\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_vecOrigin\"],\n    max_entities=50\n)\n\nalive_creeps = [e for e in result.entities if e.properties.get(\"m_iHealth\", 0) &gt; 0]\nprint(f\"Neutral creeps alive: {len(alive_creeps)}\")\n</code></pre>"},{"location":"guides/entities/#entity-data-structure","title":"Entity Data Structure","text":"<p>Each <code>EntityData</code> object contains:</p> <pre><code>class EntityData(BaseModel):\n    index: int                    # Entity index\n    serial: int                   # Entity serial number\n    class_name: str               # Entity class name (e.g., \"CDOTA_Unit_Hero_Invoker\")\n    properties: Dict[str, Any]    # Entity properties\n</code></pre> <p>The <code>properties</code> dictionary contains all requested or available properties for the entity.</p>"},{"location":"guides/entities/#result-information","title":"Result Information","text":"<p>The <code>EntitiesResult</code> includes metadata:</p> <pre><code>result = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nprint(f\"Total entities returned: {result.total_entities}\")\nprint(f\"Captured at tick: {result.tick}\")\nprint(f\"Network tick: {result.net_tick}\")\nprint(f\"Parse success: {result.success}\")\n</code></pre>"},{"location":"guides/entities/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use property_filter - Specify only needed properties to reduce memory and processing</li> <li>Use class_names for exact matches - More efficient than substring filter</li> <li>Set max_entities - Limit results when you only need a few entities</li> <li>Query once, process multiple times - Entity queries are at end of replay, cache results</li> </ol> <pre><code># Efficient: specific properties\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iKills\"],\n    max_entities=10\n)\n\n# Less efficient: all properties\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    max_entities=10\n)\n</code></pre>"},{"location":"guides/entities/#querying-at-specific-ticks","title":"Querying at Specific Ticks","text":"<p>Use the <code>at_tick</code> parameter to query entity state at a specific game tick instead of end of game:</p> <pre><code># Query heroes at tick 50000\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\"],\n    at_tick=50000,\n    max_entities=10\n)\n\nprint(f\"Hero health at tick {result.tick}:\")\nfor entity in result.entities:\n    health = entity.properties.get(\"m_iHealth\", 0)\n    max_hp = entity.properties.get(\"m_iMaxHealth\", 0)\n    print(f\"  {entity.class_name}: {health}/{max_hp}\")\n</code></pre>"},{"location":"guides/entities/#item-charges-at-specific-time","title":"Item Charges at Specific Time","text":"<p>Get Magic Stick/Wand charges for all players at a specific tick:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\ndef get_magic_stick_charges(demo_path: str, at_tick: int = 0) -&gt; dict:\n    \"\"\"\n    Get magic stick/wand charges for all players at a specific game tick.\n\n    Args:\n        demo_path: Path to the .dem file\n        at_tick: Game tick to query (0 = end of game)\n\n    Returns:\n        Dict mapping player_id -&gt; charges\n    \"\"\"\n    result = parser.query_entities(\n        demo_path,\n        class_names=['CDOTA_Item_MagicStick', 'CDOTA_Item_MagicWand'],\n        property_filter=['m_iCurrentCharges', 'm_iPlayerOwnerID'],\n        at_tick=at_tick\n    )\n\n    player_charges = {}\n    for entity in result.entities:\n        owner = entity.properties.get('m_iPlayerOwnerID', -1)\n        charges = entity.properties.get('m_iCurrentCharges', 0)\n        if owner &gt;= 0:\n            player_charges[owner] = max(player_charges.get(owner, 0), charges)\n\n    return player_charges\n\n# Get charges at tick 50000\ncharges = get_magic_stick_charges(\"match.dem\", at_tick=50000)\n# {0: 6, 2: 18, 4: 7, 6: 6, 8: 1, 10: 15, 12: 4, 14: 20, 16: 0, 18: 5}\n</code></pre>"},{"location":"guides/entities/#important-notes","title":"Important Notes","text":"<p>Note</p> <p>By default (<code>at_tick=0</code>), entity queries return the state at the end of the replay. Use <code>at_tick</code> to query state at a specific game tick.</p>"},{"location":"guides/entities/#entity-handles","title":"Entity Handles","text":"<p>Some properties reference other entities via handles:</p> <pre><code># Item handles reference item entities\nitem_handle = hero.properties.get(\"m_hItems.0000\")\n\n# These are internal entity references, not item IDs\n# Use string tables or item events for item identification\n</code></pre>"},{"location":"guides/entities/#team-numbers","title":"Team Numbers","text":"Team ID Team 2 Radiant 3 Dire 0/1 Neutral/Spectator"},{"location":"guides/entities/#hero-position-tracking-with-parse_entities","title":"Hero Position Tracking with parse_entities()","text":"<p>For tracking hero positions over time (not just end of game), use <code>parse_entities()</code> instead of <code>query_entities()</code>.</p>"},{"location":"guides/entities/#basic-position-tracking","title":"Basic Position Tracking","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Capture snapshots every 30 seconds (900 ticks at 30 ticks/sec)\nresult = parser.parse_entities(\"match.dem\", interval_ticks=900, max_snapshots=100)\n\nfor snapshot in result.snapshots:\n    print(f\"Game time: {snapshot.game_time:.1f}s\")\n    for player in snapshot.players:\n        print(f\"  {player.hero_name}: ({player.position_x:.0f}, {player.position_y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#position-at-specific-ticks","title":"Position at Specific Ticks","text":"<p>Use <code>target_ticks</code> to capture state at exact moments:</p> <pre><code># Get hero positions at specific ticks\nresult = parser.parse_entities(\"match.dem\", target_ticks=[30000, 45000, 60000])\n\nfor snapshot in result.snapshots:\n    print(f\"Tick {snapshot.tick}:\")\n    for player in snapshot.players:\n        print(f\"  {player.hero_name}: ({player.position_x:.0f}, {player.position_y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#filtering-by-hero","title":"Filtering by Hero","text":"<p>Use <code>target_heroes</code> to only get specific heroes. Use the <code>npc_dota_hero_*</code> format (same as combat log):</p> <pre><code># Get only specific heroes\nresult = parser.parse_entities(\n    \"match.dem\",\n    target_ticks=[50000],\n    target_heroes=[\"npc_dota_hero_axe\", \"npc_dota_hero_lina\"]\n)\n</code></pre>"},{"location":"guides/entities/#getting-death-positions","title":"Getting Death Positions","text":"<p>Combat log <code>location_x</code>/<code>location_y</code> are always 0. To get death positions, combine combat log with entity snapshots:</p> <pre><code># Get deaths from combat log\ncombat = parser.parse_combat_log(\"match.dem\", types=[1])  # type 1 = deaths\n\nfor death in combat.entries:\n    # Get victim's position at death tick\n    result = parser.parse_entities(\n        \"match.dem\",\n        target_ticks=[death.tick],\n        target_heroes=[death.target_name]  # e.g., \"npc_dota_hero_axe\"\n    )\n\n    if result.snapshots and result.snapshots[0].players:\n        victim = result.snapshots[0].players[0]\n        print(f\"{victim.hero_name} died at ({victim.position_x:.0f}, {victim.position_y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#position-coordinate-system","title":"Position Coordinate System","text":"<p>Hero positions use world coordinates centered on the map:</p> <ul> <li>X axis: West (Radiant, negative) to East (Dire, positive)</li> <li>Y axis: South (negative) to North (positive)</li> <li>Origin (0,0): Center of the map</li> <li>Range: Approximately -8000 to +8000 for both axes</li> </ul>"},{"location":"guides/entities/#playerstate-fields","title":"PlayerState Fields","text":"<p>Each player in a snapshot includes:</p> Field Type Description <code>player_id</code> int Player slot (0-9) <code>hero_id</code> int Hero ID <code>hero_name</code> str Hero name (<code>npc_dota_hero_*</code> format) <code>team</code> int 2=Radiant, 3=Dire <code>position_x</code> float X world coordinate <code>position_y</code> float Y world coordinate <code>health</code> int Current health <code>max_health</code> int Maximum health <code>mana</code> float Current mana <code>max_mana</code> float Maximum mana <code>last_hits</code> int Last hits <code>denies</code> int Denies <code>gold</code> int Current gold <code>net_worth</code> int Net worth <code>kills</code> int Kills <code>deaths</code> int Deaths <code>assists</code> int Assists"},{"location":"guides/entities/#position-data-sources-comparison","title":"Position Data Sources Comparison","text":"Method Use Case Position Data <code>parse_entities()</code> Time-series or specific ticks \u2705 <code>position_x</code>, <code>position_y</code> <code>query_entities()</code> End-of-game state \u2705 Raw <code>CBodyComponent.m_cellX/Y</code> <code>parse_combat_log()</code> Combat events \u274c <code>location_x/y</code> always 0"},{"location":"guides/game-events/","title":"Game Events Guide","text":"AI Summary <p>Dota 2 replays contain 364 Source 1 legacy game events with typed fields. Use <code>parse_game_events()</code> to capture events like player kills, rune pickups, tower destructions, and combat log entries. Filter by event name substring or specific names. Events have tick timestamps and typed field dictionaries. Common events: <code>dota_player_kill</code>, <code>dota_combatlog</code>, <code>dota_rune_activated</code>, <code>dota_tower_kill</code>, <code>dota_roshan_kill</code>. Use <code>capture_types=True</code> to get the full event type list.</p>"},{"location":"guides/game-events/#overview","title":"Overview","text":"<p>Dota 2 replays contain Source 1 legacy game events - structured notifications about game occurrences. There are 364 different event types, each with specific typed fields.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_game_events(\"match.dem\", max_events=100)\n\nfor event in result.events:\n    print(f\"[{event.tick}] {event.name}: {event.fields}\")\n</code></pre>"},{"location":"guides/game-events/#discovering-event-types","title":"Discovering Event Types","text":"<p>To see all available event types:</p> <pre><code>result = parser.parse_game_events(\"match.dem\", capture_types=True, max_events=0)\n\nprint(f\"Total event types: {len(result.event_types)}\")\nfor event_type in sorted(result.event_types):\n    print(f\"  {event_type}\")\n</code></pre> <p>This returns 364 event type names like: - <code>dota_player_kill</code> - <code>dota_combatlog</code> - <code>dota_rune_activated</code> - <code>dota_tower_kill</code> - <code>dota_roshan_kill</code> - And many more...</p>"},{"location":"guides/game-events/#filtering-events","title":"Filtering Events","text":""},{"location":"guides/game-events/#by-name-substring","title":"By Name Substring","text":"<pre><code># All events containing \"kill\"\nkills = parser.parse_game_events(\"match.dem\", event_filter=\"kill\", max_events=100)\n\n# All combatlog events\ncombatlog = parser.parse_game_events(\"match.dem\", event_filter=\"combatlog\", max_events=500)\n\n# All rune events\nrunes = parser.parse_game_events(\"match.dem\", event_filter=\"rune\", max_events=50)\n</code></pre>"},{"location":"guides/game-events/#by-specific-event-names","title":"By Specific Event Names","text":"<pre><code># Only player kills and tower kills\nresult = parser.parse_game_events(\n    \"match.dem\",\n    event_names=[\"dota_player_kill\", \"dota_tower_kill\"],\n    max_events=100\n)\n</code></pre>"},{"location":"guides/game-events/#common-event-types","title":"Common Event Types","text":""},{"location":"guides/game-events/#player-kills","title":"Player Kills","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=100)\n\nfor event in result.events:\n    victim = event.fields.get(\"victim_userid\")\n    killer = event.fields.get(\"killer1_userid\")\n    print(f\"[Tick {event.tick}] Player {killer} killed player {victim}\")\n</code></pre>"},{"location":"guides/game-events/#tower-destruction","title":"Tower Destruction","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_tower_kill\", max_events=50)\n\nfor event in result.events:\n    killer = event.fields.get(\"killer_userid\")\n    tower = event.fields.get(\"teamnumber\")\n    gold = event.fields.get(\"gold\")\n    print(f\"[Tick {event.tick}] Tower destroyed by player {killer}, gold: {gold}\")\n</code></pre>"},{"location":"guides/game-events/#roshan-kills","title":"Roshan Kills","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_roshan_kill\", max_events=10)\n\nfor event in result.events:\n    team = event.fields.get(\"teamnumber\")\n    print(f\"[Tick {event.tick}] Roshan killed by team {team}\")\n</code></pre>"},{"location":"guides/game-events/#rune-activations","title":"Rune Activations","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_rune_activated\", max_events=50)\n\nfor event in result.events:\n    player = event.fields.get(\"player_id\")\n    rune_type = event.fields.get(\"rune\")\n    print(f\"[Tick {event.tick}] Player {player} activated rune type {rune_type}\")\n</code></pre>"},{"location":"guides/game-events/#combat-log-events","title":"Combat Log Events","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_combatlog\", max_events=200)\n\nfor event in result.events:\n    log_type = event.fields.get(\"type\")\n    target = event.fields.get(\"targetname\")\n    source = event.fields.get(\"sourcename\")\n    value = event.fields.get(\"value\")\n    print(f\"[Tick {event.tick}] Type {log_type}: {source} -&gt; {target} ({value})\")\n</code></pre>"},{"location":"guides/game-events/#event-field-types","title":"Event Field Types","text":"<p>Event fields are automatically typed based on their definition:</p> Field Type Python Type string str float float long int short int byte int bool bool uint64 int"},{"location":"guides/game-events/#full-event-type-list","title":"Full Event Type List","text":"AI Summary <p>All 364 Event Types (click to expand)</p> <p>Common Dota 2 events include:</p> <p>Player Events: - <code>dota_player_kill</code> - <code>dota_player_deny</code> - <code>dota_player_pick_hero</code> - <code>dota_player_learned_ability</code> - <code>dota_player_used_ability</code> - <code>dota_player_gained_level</code> - <code>dota_player_take_tower_damage</code></p> <p>Unit Events: - <code>dota_tower_kill</code> - <code>dota_barracks_kill</code> - <code>dota_roshan_kill</code> - <code>dota_courier_lost</code> - <code>dota_npc_goal_reached</code></p> <p>Item Events: - <code>dota_item_purchased</code> - <code>dota_item_combined</code> - <code>dota_item_picked_up</code></p> <p>Rune Events: - <code>dota_rune_activated</code> - <code>dota_rune_spawned</code> - <code>dota_bounty_rune_pickup</code></p> <p>Game State: - <code>dota_match_done</code> - <code>dota_game_state_change</code> - <code>dota_team_kill_credit</code> - <code>game_rules_state_change</code></p> <p>Combat: - <code>dota_combatlog</code> - <code>dota_player_take_tower_damage</code></p> <p>Other: - <code>dota_chase_hero</code> - <code>dota_tutorial_*</code> (various tutorial events)</p> <p>Use <code>capture_types=True</code> to get the complete list for your replay.</p>"},{"location":"guides/game-events/#example-kill-timeline","title":"Example: Kill Timeline","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get all player kills\nresult = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=500)\n\nprint(\"Kill Timeline:\")\nprint(\"-\" * 50)\n\nfor event in result.events:\n    tick = event.tick\n    killer = event.fields.get(\"killer1_userid\", \"Unknown\")\n    victim = event.fields.get(\"victim_userid\", \"Unknown\")\n    assisters = []\n\n    # Check for assists\n    for i in range(2, 6):\n        assister = event.fields.get(f\"killer{i}_userid\")\n        if assister:\n            assisters.append(str(assister))\n\n    assist_str = f\" + {', '.join(assisters)}\" if assisters else \"\"\n    print(f\"[Tick {tick:6d}] Player {killer}{assist_str} killed Player {victim}\")\n</code></pre>"},{"location":"guides/game-events/#game-events-vs-combat-log","title":"Game Events vs Combat Log","text":"<p>Both provide combat information but differ:</p> Aspect Game Events Combat Log API <code>parse_game_events()</code> <code>parse_combat_log()</code> Structure Named events with typed fields Structured entries with fixed schema Types 364 event types 12 log types Best for High-level events (kills, runes) Detailed damage/heal analysis Timing Throughout match After ~12-17 minutes <p>Use game events for discrete occurrences (kills, objectives) and combat log for continuous combat data (DPS, healing).</p>"},{"location":"guides/game-events/#performance-tips","title":"Performance Tips","text":"<ol> <li>Always set <code>max_events</code> - Events can be numerous</li> <li>Use specific filters - Narrow down with <code>event_filter</code> or <code>event_names</code></li> <li>Discover first - Use <code>capture_types=True</code> to find relevant events</li> <li>Combine with other APIs - Use entity queries for context about players</li> </ol>"},{"location":"guides/modifiers/","title":"Modifiers Guide","text":"AI Summary <p>Track buffs, debuffs, and auras using <code>parse_modifiers()</code>. Each modifier entry includes parent entity, caster, ability handle, creation time, duration (-1 for permanent), stack count, and flags for aura/debuff. Use <code>auras_only=True</code> to filter aura effects. Modifiers track status effects like stuns, slows, and item buffs throughout the match. Combine with entity queries to resolve entity handles to names.</p>"},{"location":"guides/modifiers/#overview","title":"Overview","text":"<p>Modifiers represent buffs, debuffs, auras, and other status effects applied to units during the match.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    print(f\"[Tick {mod.tick}] Entity {mod.parent}: {duration_str}\")\n</code></pre>"},{"location":"guides/modifiers/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/modifiers/#all-modifiers","title":"All Modifiers","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\nprint(f\"Total modifiers captured: {result.total_modifiers}\")\n\nfor mod in result.modifiers:\n    mod_type = \"DEBUFF\" if mod.is_debuff else \"BUFF\"\n    aura_tag = \" (AURA)\" if mod.is_aura else \"\"\n\n    print(f\"[{mod.tick}] {mod_type}{aura_tag} on entity {mod.parent}\")\n</code></pre>"},{"location":"guides/modifiers/#auras-only","title":"Auras Only","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", auras_only=True, max_modifiers=200)\n\nprint(f\"Aura modifiers: {len(result.modifiers)}\")\n\nfor mod in result.modifiers:\n    print(f\"[{mod.tick}] Aura on entity {mod.parent}, stacks: {mod.stack_count}\")\n</code></pre>"},{"location":"guides/modifiers/#modifier-entry-fields","title":"Modifier Entry Fields","text":"<p>Each <code>ModifierEntry</code> contains:</p> Field Type Description <code>tick</code> int Game tick when modifier was recorded <code>net_tick</code> int Network tick <code>parent</code> int Entity handle of unit with modifier <code>caster</code> int Entity handle of caster <code>ability</code> int Ability handle that created modifier <code>modifier_class</code> int Modifier class ID <code>serial_num</code> int Serial number for tracking <code>index</code> int Modifier index <code>creation_time</code> float Game time when created <code>duration</code> float Duration in seconds (-1 = permanent) <code>stack_count</code> int Number of stacks <code>is_aura</code> bool Whether it's an aura <code>is_debuff</code> bool Whether it's a debuff"},{"location":"guides/modifiers/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/modifiers/#duration-analysis","title":"Duration Analysis","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\npermanent = []\ntimed = []\n\nfor mod in result.modifiers:\n    if mod.duration &lt; 0:\n        permanent.append(mod)\n    else:\n        timed.append(mod)\n\nprint(f\"Permanent modifiers: {len(permanent)}\")\nprint(f\"Timed modifiers: {len(timed)}\")\n\nif timed:\n    durations = [m.duration for m in timed]\n    print(f\"Duration range: {min(durations):.1f}s - {max(durations):.1f}s\")\n    print(f\"Average duration: {sum(durations)/len(durations):.1f}s\")\n</code></pre>"},{"location":"guides/modifiers/#buff-vs-debuff-count","title":"Buff vs Debuff Count","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\nbuffs = [m for m in result.modifiers if not m.is_debuff]\ndebuffs = [m for m in result.modifiers if m.is_debuff]\n\nprint(f\"Buffs: {len(buffs)}\")\nprint(f\"Debuffs: {len(debuffs)}\")\n</code></pre>"},{"location":"guides/modifiers/#stacking-modifiers","title":"Stacking Modifiers","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\nstacking = [m for m in result.modifiers if m.stack_count &gt; 1]\n\nprint(f\"Modifiers with stacks: {len(stacking)}\")\n\nfor mod in stacking[:10]:\n    print(f\"  Entity {mod.parent}: {mod.stack_count} stacks\")\n</code></pre>"},{"location":"guides/modifiers/#modifier-timeline","title":"Modifier Timeline","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\n# Group by tick ranges (every 1000 ticks)\ntimeline = defaultdict(list)\nfor mod in result.modifiers:\n    bucket = (mod.tick // 1000) * 1000\n    timeline[bucket].append(mod)\n\nprint(\"Modifier Activity Timeline:\")\nfor tick in sorted(timeline.keys()):\n    mods = timeline[tick]\n    debuff_count = sum(1 for m in mods if m.is_debuff)\n    buff_count = len(mods) - debuff_count\n    print(f\"  Tick {tick:&gt;6}: {buff_count} buffs, {debuff_count} debuffs\")\n</code></pre>"},{"location":"guides/modifiers/#entity-modifier-history","title":"Entity Modifier History","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=2000)\n\n# Group modifiers by parent entity\nentity_mods = defaultdict(list)\nfor mod in result.modifiers:\n    entity_mods[mod.parent].append(mod)\n\n# Find entities with most modifiers\nsorted_entities = sorted(entity_mods.items(), key=lambda x: -len(x[1]))\n\nprint(\"Entities with Most Modifiers:\")\nfor entity_id, mods in sorted_entities[:10]:\n    debuff_count = sum(1 for m in mods if m.is_debuff)\n    aura_count = sum(1 for m in mods if m.is_aura)\n    print(f\"  Entity {entity_id}: {len(mods)} total ({debuff_count} debuffs, {aura_count} auras)\")\n</code></pre>"},{"location":"guides/modifiers/#long-duration-debuffs","title":"Long Duration Debuffs","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\n# Find long-duration debuffs (potential stuns/silences)\nlong_debuffs = [\n    m for m in result.modifiers\n    if m.is_debuff and m.duration &gt; 2.0\n]\n\nprint(f\"Long duration debuffs (&gt;2s): {len(long_debuffs)}\")\n\nfor mod in sorted(long_debuffs, key=lambda m: -m.duration)[:10]:\n    print(f\"  Duration: {mod.duration:.1f}s on entity {mod.parent}\")\n</code></pre>"},{"location":"guides/modifiers/#combining-with-entity-queries","title":"Combining with Entity Queries","text":"<p>Since modifiers reference entities by handle, you can combine with entity queries:</p> <pre><code># Get modifiers\nmods_result = parser.parse_modifiers(\"match.dem\", max_modifiers=200)\n\n# Get hero entities for reference\nentities_result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\"],\n    max_entities=10\n)\n\n# Build entity index map\nentity_map = {e.index: e.class_name for e in entities_result.entities}\n\n# Report modifiers on known entities\nfor mod in mods_result.modifiers[:20]:\n    entity_name = entity_map.get(mod.parent, f\"Unknown({mod.parent})\")\n    mod_type = \"DEBUFF\" if mod.is_debuff else \"BUFF\"\n    print(f\"{mod_type} on {entity_name}\")\n</code></pre>"},{"location":"guides/modifiers/#aura-effects","title":"Aura Effects","text":"<p>Auras are special modifiers that affect units in an area:</p> <pre><code>result = parser.parse_modifiers(\"match.dem\", auras_only=True, max_modifiers=300)\n\nprint(\"Aura Analysis:\")\nprint(\"-\" * 50)\n\n# Group by caster\nfrom collections import defaultdict\ncaster_auras = defaultdict(list)\n\nfor mod in result.modifiers:\n    caster_auras[mod.caster].append(mod)\n\nprint(f\"Unique aura casters: {len(caster_auras)}\")\n\nfor caster, auras in sorted(caster_auras.items(), key=lambda x: -len(x[1]))[:5]:\n    affected_units = len(set(m.parent for m in auras))\n    print(f\"  Caster {caster}: {len(auras)} aura applications to {affected_units} units\")\n</code></pre>"},{"location":"guides/modifiers/#performance-tips","title":"Performance Tips","text":"<ol> <li>Set max_modifiers - Modifiers can be numerous in long matches</li> <li>Use auras_only - When only interested in aura effects</li> <li>Filter client-side - Parse once, filter the results multiple times</li> </ol> <pre><code># Efficient: get all modifiers once\nall_mods = parser.parse_modifiers(\"match.dem\", max_modifiers=2000)\n\n# Filter in Python\ndebuffs = [m for m in all_mods.modifiers if m.is_debuff]\nauras = [m for m in all_mods.modifiers if m.is_aura]\npermanent = [m for m in all_mods.modifiers if m.duration &lt; 0]\n</code></pre>"},{"location":"guides/modifiers/#common-modifier-patterns","title":"Common Modifier Patterns","text":""},{"location":"guides/modifiers/#permanent-buffs-passivesitems","title":"Permanent Buffs (Passives/Items)","text":"<pre><code>permanent_buffs = [\n    m for m in result.modifiers\n    if m.duration &lt; 0 and not m.is_debuff\n]\n</code></pre>"},{"location":"guides/modifiers/#control-effects-stunsroots","title":"Control Effects (Stuns/Roots)","text":"<pre><code># Long-duration debuffs are often control effects\ncontrol_effects = [\n    m for m in result.modifiers\n    if m.is_debuff and 0 &lt; m.duration &lt;= 5.0\n]\n</code></pre>"},{"location":"guides/modifiers/#dothot-effects","title":"DoT/HoT Effects","text":"<pre><code># Short-duration stackable effects\ndot_hot = [\n    m for m in result.modifiers\n    if m.stack_count &gt; 0 and 0 &lt; m.duration &lt; 15\n]\n</code></pre>"},{"location":"guides/modifiers/#important-notes","title":"Important Notes","text":"<p>Note</p> <p>Modifiers track when effects are applied. The <code>parent</code> and <code>caster</code> fields are entity handles, not player IDs. Use entity queries to resolve these to unit types.</p>"},{"location":"guides/modifiers/#duration-values","title":"Duration Values","text":"Duration Meaning <code>-1</code> Permanent (passives, items) <code>0</code> Instant effect <code>&gt; 0</code> Timed effect in seconds"},{"location":"guides/modifiers/#entity-handles","title":"Entity Handles","text":"<p>The <code>parent</code>, <code>caster</code>, and <code>ability</code> fields are entity handles: - Use entity queries to get entity details by index - Handles may reference entities no longer in the game - Handle 0 typically means no specific source</p>"},{"location":"guides/unit-orders/","title":"Unit Orders Guide","text":"AI Summary <p>Parse player commands using <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code>. Detect attack commands (<code>order_type=4</code>) to analyze creep aggro triggers, last-hit patterns, and harass behavior. Each order includes player entity, order type, target, position, and ability. Key for lane mechanics analysis: when a hero issues ATTACK_TARGET on enemy hero within 500 units of enemy creeps, it triggers creep aggro.</p>"},{"location":"guides/unit-orders/#overview","title":"Overview","text":"<p>The <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> callback captures every command a player issues to their units. This is essential for analyzing:</p> <ul> <li>Creep aggro triggers - When players right-click enemy heroes</li> <li>Last-hit patterns - Attack commands on creeps</li> <li>Ability usage - Cast orders with targets</li> <li>Movement patterns - Move and patrol commands</li> <li>Micro decisions - Multi-unit control</li> </ul> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=10000\n)\n\nfor msg in result.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n    target = msg.data.get(\"target_index\", 0)\n    print(f\"[{msg.tick}] Order {order_type}, target={target}\")\n</code></pre>"},{"location":"guides/unit-orders/#message-structure","title":"Message Structure","text":""},{"location":"guides/unit-orders/#fields","title":"Fields","text":"Field Type Description <code>entindex</code> int Entity index of the player/unit issuing the order <code>order_type</code> int Type of order (see Order Types below) <code>units</code> list[int] Entity indices of units receiving the order <code>target_index</code> int Target entity index (for targeted orders) <code>ability_id</code> int Ability ID (for cast orders) <code>position</code> dict Target position <code>{x, y, z}</code> (for position orders) <code>queue</code> bool Whether order is queued (shift-click) <code>sequence_number</code> int Order sequence number <code>flags</code> int Order flags"},{"location":"guides/unit-orders/#order-types","title":"Order Types","text":"<p>The <code>order_type</code> field maps to <code>dotaunitorder_t</code> enum values:</p>"},{"location":"guides/unit-orders/#movement-orders","title":"Movement Orders","text":"Value Name Description 0 <code>NONE</code> No order 1 <code>MOVE_TO_POSITION</code> Move to ground position (right-click ground) 2 <code>MOVE_TO_TARGET</code> Move to/follow a unit 28 <code>MOVE_TO_DIRECTION</code> Move in direction 29 <code>PATROL</code> Patrol command 39 <code>MOVE_RELATIVE</code> Relative movement"},{"location":"guides/unit-orders/#attack-orders","title":"Attack Orders","text":"Value Name Description 3 <code>ATTACK_MOVE</code> Attack-move (A-click ground) 4 <code>ATTACK_TARGET</code> Attack specific target (right-click enemy)"},{"location":"guides/unit-orders/#ability-orders","title":"Ability Orders","text":"Value Name Description 5 <code>CAST_POSITION</code> Cast ability on ground 6 <code>CAST_TARGET</code> Cast ability on unit 7 <code>CAST_TARGET_TREE</code> Cast ability on tree 8 <code>CAST_NO_TARGET</code> Cast ability (no target) 9 <code>CAST_TOGGLE</code> Toggle ability 20 <code>CAST_TOGGLE_AUTO</code> Toggle autocast 40 <code>CAST_TOGGLE_ALT</code> Alt toggle"},{"location":"guides/unit-orders/#control-orders","title":"Control Orders","text":"Value Name Description 10 <code>HOLD_POSITION</code> Hold position (H key) 21 <code>STOP</code> Stop command (S key) 33 <code>CONTINUE</code> Continue previous order"},{"location":"guides/unit-orders/#item-orders","title":"Item Orders","text":"Value Name Description 12 <code>DROP_ITEM</code> Drop item on ground 13 <code>GIVE_ITEM</code> Give item to ally 14 <code>PICKUP_ITEM</code> Pick up item 15 <code>PICKUP_RUNE</code> Pick up rune 16 <code>PURCHASE_ITEM</code> Purchase item 17 <code>SELL_ITEM</code> Sell item 18 <code>DISASSEMBLE_ITEM</code> Disassemble item 19 <code>MOVE_ITEM</code> Move item in inventory 41 <code>CONSUME_ITEM</code> Consume item"},{"location":"guides/unit-orders/#other-orders","title":"Other Orders","text":"Value Name Description 11 <code>TRAIN_ABILITY</code> Level up ability 22 <code>TAUNT</code> Taunt 23 <code>BUYBACK</code> Buyback 24 <code>GLYPH</code> Activate glyph 26 <code>CAST_RUNE</code> Use bottle on rune 27 <code>PING_ABILITY</code> Ping ability cooldown 30 <code>VECTOR_TARGET_POSITION</code> Vector targeted ability 31 <code>RADAR</code> Scan ability"},{"location":"guides/unit-orders/#creep-aggro-detection","title":"Creep Aggro Detection","text":""},{"location":"guides/unit-orders/#how-creep-aggro-works-in-dota-2","title":"How Creep Aggro Works in Dota 2","text":"<p>Creep aggro is triggered when: 1. A hero issues an attack command (<code>order_type=4</code>) on an enemy hero 2. The hero is within 500 units of enemy lane creeps 3. This puts creeps on a 2.5 second aggro cooldown</p>"},{"location":"guides/unit-orders/#detecting-aggro-triggers","title":"Detecting Aggro Triggers","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get all attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\nATTACK_TARGET = 4\n\nattack_commands = []\nfor msg in orders.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n\n    if order_type == ATTACK_TARGET:\n        attack_commands.append({\n            \"tick\": msg.tick,\n            \"player_entity\": msg.data.get(\"entindex\"),\n            \"target_entity\": msg.data.get(\"target_index\"),\n            \"units\": msg.data.get(\"units\", []),\n            \"queued\": msg.data.get(\"queue\", False),\n        })\n\nprint(f\"Found {len(attack_commands)} attack commands\")\n</code></pre>"},{"location":"guides/unit-orders/#identifying-hero-on-hero-attacks","title":"Identifying Hero-on-Hero Attacks","text":"<p>To determine if an attack triggers creep aggro, you need to: 1. Check if the attacker is a hero 2. Check if the target is an enemy hero 3. Check proximity to enemy creeps (requires entity position data)</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Get entity data to identify heroes\nentities = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    max_entities=20\n)\n\n# Build hero entity index set\nhero_entities = {e.index for e in entities.entities}\n\nATTACK_TARGET = 4\n\npotential_aggro_triggers = []\nfor msg in orders.messages:\n    if msg.data.get(\"order_type\") != ATTACK_TARGET:\n        continue\n\n    target = msg.data.get(\"target_index\", 0)\n\n    # Check if target is a hero (potential aggro trigger)\n    if target in hero_entities:\n        potential_aggro_triggers.append({\n            \"tick\": msg.tick,\n            \"attacker\": msg.data.get(\"entindex\"),\n            \"target_hero\": target,\n        })\n\nprint(f\"Potential aggro triggers: {len(potential_aggro_triggers)}\")\n</code></pre>"},{"location":"guides/unit-orders/#full-aggro-analysis-with-positions","title":"Full Aggro Analysis with Positions","text":"<p>For complete aggro analysis, combine orders with entity snapshots:</p> <pre><code>from python_manta import MantaParser\nimport math\n\nparser = MantaParser()\n\n# Parse attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Get attack target orders\nATTACK_TARGET = 4\nattack_ticks = []\n\nfor msg in orders.messages:\n    if msg.data.get(\"order_type\") == ATTACK_TARGET:\n        attack_ticks.append(msg.tick)\n\n# Sample entity positions at attack moments\n# Use unique ticks to avoid duplicates\nunique_ticks = sorted(set(attack_ticks))[:100]  # Limit for performance\n\nif unique_ticks:\n    snapshots = parser.parse_entities(\n        \"match.dem\",\n        target_ticks=unique_ticks,\n        max_snapshots=100\n    )\n\n    # Analyze each snapshot for creep proximity\n    AGGRO_RANGE = 500\n\n    for snapshot in snapshots.snapshots:\n        # Get hero positions\n        heroes = {p.hero: (p.x, p.y) for p in snapshot.players if p.hero}\n\n        # Would need creep positions from entity data\n        # This is a simplified example\n        print(f\"Tick {snapshot.tick}: {len(heroes)} heroes tracked\")\n</code></pre>"},{"location":"guides/unit-orders/#lane-mechanics-analysis","title":"Lane Mechanics Analysis","text":""},{"location":"guides/unit-orders/#last-hit-pattern-detection","title":"Last-Hit Pattern Detection","text":"<pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=100000\n)\n\nATTACK_TARGET = 4\nATTACK_MOVE = 3\n\nplayer_attacks = defaultdict(list)\n\nfor msg in orders.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n\n    if order_type in [ATTACK_TARGET, ATTACK_MOVE]:\n        player = msg.data.get(\"entindex\")\n        player_attacks[player].append({\n            \"tick\": msg.tick,\n            \"type\": \"target\" if order_type == ATTACK_TARGET else \"move\",\n            \"target\": msg.data.get(\"target_index\"),\n        })\n\n# Analyze attack patterns\nfor player, attacks in player_attacks.items():\n    target_attacks = [a for a in attacks if a[\"type\"] == \"target\"]\n    move_attacks = [a for a in attacks if a[\"type\"] == \"move\"]\n\n    print(f\"Player entity {player}:\")\n    print(f\"  Direct attacks: {len(target_attacks)}\")\n    print(f\"  Attack-moves: {len(move_attacks)}\")\n</code></pre>"},{"location":"guides/unit-orders/#harass-timing-analysis","title":"Harass Timing Analysis","text":"<p>Analyze when players harass vs last-hit:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get orders and combat log for correlation\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Filter to laning phase (first 10 minutes ~ 18000 ticks at 30 ticks/sec)\nLANING_END_TICK = 18000\nATTACK_TARGET = 4\n\nlaning_attacks = []\nfor msg in orders.messages:\n    if msg.tick &gt; LANING_END_TICK:\n        break\n\n    if msg.data.get(\"order_type\") == ATTACK_TARGET:\n        laning_attacks.append({\n            \"tick\": msg.tick,\n            \"player\": msg.data.get(\"entindex\"),\n            \"target\": msg.data.get(\"target_index\"),\n        })\n\nprint(f\"Laning phase attacks: {len(laning_attacks)}\")\n\n# Group by time windows (30 second intervals)\nfrom collections import defaultdict\nTICKS_PER_30_SEC = 900\n\ntime_windows = defaultdict(int)\nfor attack in laning_attacks:\n    window = attack[\"tick\"] // TICKS_PER_30_SEC\n    time_windows[window] += 1\n\nprint(\"\\nAttack frequency by 30-second windows:\")\nfor window, count in sorted(time_windows.items()):\n    minutes = (window * 30) // 60\n    seconds = (window * 30) % 60\n    print(f\"  {minutes}:{seconds:02d}: {count} attacks\")\n</code></pre>"},{"location":"guides/unit-orders/#multi-unit-control-analysis","title":"Multi-Unit Control Analysis","text":"<p>For heroes with summons or illusions:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Find orders with multiple units\nmulti_unit_orders = []\nfor msg in orders.messages:\n    units = msg.data.get(\"units\", [])\n    if len(units) &gt; 1:\n        multi_unit_orders.append({\n            \"tick\": msg.tick,\n            \"order_type\": msg.data.get(\"order_type\"),\n            \"unit_count\": len(units),\n            \"units\": units,\n        })\n\nprint(f\"Multi-unit orders: {len(multi_unit_orders)}\")\n\n# Analyze micro patterns\nfrom collections import Counter\norder_types = Counter(o[\"order_type\"] for o in multi_unit_orders)\nprint(\"\\nMulti-unit order types:\")\nfor order_type, count in order_types.most_common():\n    print(f\"  Type {order_type}: {count}\")\n</code></pre>"},{"location":"guides/unit-orders/#queued-commands-analysis","title":"Queued Commands Analysis","text":"<p>Detect shift-queued commands:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\nqueued_orders = []\nfor msg in orders.messages:\n    if msg.data.get(\"queue\", False):\n        queued_orders.append({\n            \"tick\": msg.tick,\n            \"order_type\": msg.data.get(\"order_type\"),\n            \"player\": msg.data.get(\"entindex\"),\n        })\n\nprint(f\"Queued orders: {len(queued_orders)}\")\nprint(f\"Queue usage rate: {len(queued_orders) / len(orders.messages) * 100:.1f}%\")\n</code></pre>"},{"location":"guides/unit-orders/#performance-considerations","title":"Performance Considerations","text":"<p>High Volume Callback</p> <p><code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> fires frequently - expect 10,000-50,000+ messages per match. Always set <code>max_messages</code> appropriately.</p>"},{"location":"guides/unit-orders/#recommended-limits","title":"Recommended Limits","text":"<pre><code># For full match analysis\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 100000)\n\n# For laning phase only\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 20000)\n\n# For sampling/overview\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 5000)\n</code></pre>"},{"location":"guides/unit-orders/#efficient-filtering","title":"Efficient Filtering","text":"<p>Filter early to reduce memory:</p> <pre><code>ATTACK_TARGET = 4\nATTACK_MOVE = 3\n\n# Process in batches if needed\nattack_orders = []\nresult = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 50000)\n\nfor msg in result.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n    if order_type in [ATTACK_TARGET, ATTACK_MOVE]:\n        attack_orders.append(msg)\n\n# Now work with filtered subset\nprint(f\"Attack orders: {len(attack_orders)} of {len(result.messages)} total\")\n</code></pre>"},{"location":"guides/unit-orders/#related-apis","title":"Related APIs","text":"Task API Entity positions <code>parse_entities()</code> Combat damage <code>parse_combat_log()</code> Hero state <code>query_entities(class_filter=\"Hero\")</code> Ability usage <code>parse_universal(\"CDOTAUserMsg_UnitEvent\")</code>"},{"location":"guides/unit-orders/#order-type-reference","title":"Order Type Reference","text":"<p>Complete <code>dotaunitorder_t</code> enum:</p> <pre><code>0  = DOTA_UNIT_ORDER_NONE\n1  = DOTA_UNIT_ORDER_MOVE_TO_POSITION\n2  = DOTA_UNIT_ORDER_MOVE_TO_TARGET\n3  = DOTA_UNIT_ORDER_ATTACK_MOVE\n4  = DOTA_UNIT_ORDER_ATTACK_TARGET\n5  = DOTA_UNIT_ORDER_CAST_POSITION\n6  = DOTA_UNIT_ORDER_CAST_TARGET\n7  = DOTA_UNIT_ORDER_CAST_TARGET_TREE\n8  = DOTA_UNIT_ORDER_CAST_NO_TARGET\n9  = DOTA_UNIT_ORDER_CAST_TOGGLE\n10 = DOTA_UNIT_ORDER_HOLD_POSITION\n11 = DOTA_UNIT_ORDER_TRAIN_ABILITY\n12 = DOTA_UNIT_ORDER_DROP_ITEM\n13 = DOTA_UNIT_ORDER_GIVE_ITEM\n14 = DOTA_UNIT_ORDER_PICKUP_ITEM\n15 = DOTA_UNIT_ORDER_PICKUP_RUNE\n16 = DOTA_UNIT_ORDER_PURCHASE_ITEM\n17 = DOTA_UNIT_ORDER_SELL_ITEM\n18 = DOTA_UNIT_ORDER_DISASSEMBLE_ITEM\n19 = DOTA_UNIT_ORDER_MOVE_ITEM\n20 = DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO\n21 = DOTA_UNIT_ORDER_STOP\n22 = DOTA_UNIT_ORDER_TAUNT\n23 = DOTA_UNIT_ORDER_BUYBACK\n24 = DOTA_UNIT_ORDER_GLYPH\n25 = DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH\n26 = DOTA_UNIT_ORDER_CAST_RUNE\n27 = DOTA_UNIT_ORDER_PING_ABILITY\n28 = DOTA_UNIT_ORDER_MOVE_TO_DIRECTION\n29 = DOTA_UNIT_ORDER_PATROL\n30 = DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION\n31 = DOTA_UNIT_ORDER_RADAR\n32 = DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK\n33 = DOTA_UNIT_ORDER_CONTINUE\n34 = DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED\n35 = DOTA_UNIT_ORDER_CAST_RIVER_PAINT\n36 = DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT\n37 = DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN\n38 = DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH\n39 = DOTA_UNIT_ORDER_MOVE_RELATIVE\n40 = DOTA_UNIT_ORDER_CAST_TOGGLE_ALT\n41 = DOTA_UNIT_ORDER_CONSUME_ITEM\n42 = DOTA_UNIT_ORDER_SET_ITEM_MARK_FOR_SELL\n</code></pre>"},{"location":"guides/universal/","title":"Universal Messages Guide","text":"AI Summary <p>Parse any of 272 message types using <code>parse_universal()</code>. Filter by callback name (substring match). Common messages: <code>CDOTAUserMsg_ChatMessage</code> (chat), <code>CDOTAUserMsg_LocationPing</code> (pings), <code>CDOTAUserMsg_ItemPurchased</code> (items), <code>CDOTAUserMsg_UnitEvent</code> (abilities), <code>CDOTAUserMsg_OverheadEvent</code> (damage numbers). Each message has tick, net_tick, type, and data dict. Always set max_messages to avoid memory issues. Message data structure varies by type.</p>"},{"location":"guides/universal/#overview","title":"Overview","text":"<p>The universal parser can extract any of the 272 message callback types from a replay. It's the most flexible parsing method.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    print(f\"[{msg.tick}] {msg.type}: {msg.data}\")\n</code></pre>"},{"location":"guides/universal/#message-filtering","title":"Message Filtering","text":""},{"location":"guides/universal/#substring-matching","title":"Substring Matching","text":"<p>The filter matches callback names as substrings:</p> <pre><code># Matches CDOTAUserMsg_ChatMessage, CDOTAUserMsg_ChatEvent, etc.\nchat = parser.parse_universal(\"match.dem\", \"Chat\", 100)\n\n# Matches CDOTAUserMsg_LocationPing\npings = parser.parse_universal(\"match.dem\", \"Ping\", 50)\n\n# Matches multiple message types containing \"Unit\"\nunits = parser.parse_universal(\"match.dem\", \"Unit\", 200)\n</code></pre>"},{"location":"guides/universal/#exact-callback-names","title":"Exact Callback Names","text":"<p>For precise matching, use the full callback name:</p> <pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n</code></pre>"},{"location":"guides/universal/#all-messages","title":"All Messages","text":"<p>Use empty string to capture all message types (use with caution):</p> <pre><code># WARNING: Can produce millions of messages!\nall_messages = parser.parse_universal(\"match.dem\", \"\", 1000)\n\n# See what types were captured\ntypes = set(msg.type for msg in all_messages.messages)\nprint(f\"Captured {len(types)} different message types\")\n</code></pre>"},{"location":"guides/universal/#common-message-types","title":"Common Message Types","text":""},{"location":"guides/universal/#chat-messages","title":"Chat Messages","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 200)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"source_player_id\")\n    text = msg.data.get(\"message_text\", \"\")\n    chat_type = msg.data.get(\"chat_type\", 0)  # 1=all, 2=team, etc.\n\n    type_name = {1: \"All\", 2: \"Team\", 3: \"Spectator\"}.get(chat_type, \"Unknown\")\n    print(f\"[{msg.tick}] Player {player_id} ({type_name}): {text}\")\n</code></pre>"},{"location":"guides/universal/#map-pings","title":"Map Pings","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_LocationPing\", 100)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    ping_data = msg.data.get(\"location_ping\", {})\n    x = ping_data.get(\"x\", 0)\n    y = ping_data.get(\"y\", 0)\n    ping_type = ping_data.get(\"type\", 0)\n\n    print(f\"[{msg.tick}] Player {player_id} pinged ({x}, {y}) type={ping_type}\")\n</code></pre>"},{"location":"guides/universal/#item-purchases","title":"Item Purchases","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ItemPurchased\", 500)\n\nfrom collections import defaultdict\npurchases = defaultdict(list)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    item_id = msg.data.get(\"item_ability\")\n\n    purchases[player_id].append(item_id)\n\nfor player_id, items in purchases.items():\n    print(f\"Player {player_id}: {len(items)} items purchased\")\n</code></pre>"},{"location":"guides/universal/#unit-events-ability-usage","title":"Unit Events (Ability Usage)","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_UnitEvent\", 200)\n\nfor msg in result.messages:\n    event_type = msg.data.get(\"msg_type\", 0)\n    entity = msg.data.get(\"entity_index\")\n\n    # Event types: 1=spawn, 2=speech, 3=add_gesture, etc.\n    print(f\"[{msg.tick}] Entity {entity}: event type {event_type}\")\n</code></pre>"},{"location":"guides/universal/#overhead-events-damage-numbers","title":"Overhead Events (Damage Numbers)","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_OverheadEvent\", 300)\n\nfor msg in result.messages:\n    event_type = msg.data.get(\"message_type\", 0)\n    value = msg.data.get(\"value\", 0)\n    target = msg.data.get(\"target_player_entindex\")\n\n    # Types: 1=gold, 2=crit, 3=heal, 4=damage, 5=mana, 6=miss, etc.\n    print(f\"[{msg.tick}] Type {event_type}: {value} on entity {target}\")\n</code></pre>"},{"location":"guides/universal/#game-rules-state","title":"Game Rules State","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_GamerulesStateChanged\", 20)\n\nfor msg in result.messages:\n    state = msg.data.get(\"state\", 0)\n\n    state_names = {\n        0: \"INIT\", 1: \"WAIT_FOR_PLAYERS_TO_LOAD\", 2: \"HERO_SELECTION\",\n        3: \"STRATEGY_TIME\", 4: \"PRE_GAME\", 5: \"GAME_IN_PROGRESS\",\n        6: \"POST_GAME\", 7: \"DISCONNECT\"\n    }\n    name = state_names.get(state, f\"UNKNOWN({state})\")\n    print(f\"[{msg.tick}] Game state changed to: {name}\")\n</code></pre>"},{"location":"guides/universal/#message-data-structure","title":"Message Data Structure","text":"<p>Each <code>MessageEvent</code> contains:</p> Field Type Description <code>type</code> str Callback name (e.g., \"CDOTAUserMsg_ChatMessage\") <code>tick</code> int Game tick when message occurred <code>net_tick</code> int Network tick <code>data</code> dict Message-specific payload <code>timestamp</code> int Unix timestamp in milliseconds (if available) <p>The <code>data</code> dictionary structure varies by message type.</p>"},{"location":"guides/universal/#message-categories","title":"Message Categories","text":""},{"location":"guides/universal/#user-messages-cdotausermsg_","title":"User Messages (CDOTAUserMsg_*)","text":"<p>Game events visible to players: - <code>CDOTAUserMsg_ChatMessage</code> - Chat text - <code>CDOTAUserMsg_ChatEvent</code> - Chat events (kills, items) - <code>CDOTAUserMsg_LocationPing</code> - Map pings - <code>CDOTAUserMsg_ItemPurchased</code> - Item buys - <code>CDOTAUserMsg_UnitEvent</code> - Unit actions - <code>CDOTAUserMsg_OverheadEvent</code> - Floating numbers - <code>CDOTAUserMsg_ParticleManager</code> - Visual effects - <code>CDOTAUserMsg_CreateLinearProjectile</code> - Projectiles</p>"},{"location":"guides/universal/#network-messages-cnetmsg_","title":"Network Messages (CNETMsg_*)","text":"<p>Low-level network data: - <code>CNETMsg_Tick</code> - Tick sync (very frequent!) - <code>CNETMsg_SetConVar</code> - Console variables - <code>CNETMsg_StringCmd</code> - String commands</p>"},{"location":"guides/universal/#service-messages-csvcmsg_","title":"Service Messages (CSVCMsg_*)","text":"<p>Server-to-client: - <code>CSVCMsg_ServerInfo</code> - Server info - <code>CSVCMsg_CreateStringTable</code> - String tables - <code>CSVCMsg_UpdateStringTable</code> - Table updates - <code>CSVCMsg_PacketEntities</code> - Entity updates</p>"},{"location":"guides/universal/#demo-messages-cdemo","title":"Demo Messages (CDemo*)","text":"<p>Recording-related: - <code>CDemoFileHeader</code> - File header - <code>CDemoFileInfo</code> - Match info - <code>CDemoFullPacket</code> - Full state snapshot</p>"},{"location":"guides/universal/#analysis-examples","title":"Analysis Examples","text":""},{"location":"guides/universal/#chat-timeline","title":"Chat Timeline","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 500)\n\nprint(\"Chat Timeline:\")\nprint(\"-\" * 60)\n\nfor msg in result.messages:\n    tick = msg.tick\n    player = msg.data.get(\"source_player_id\", \"?\")\n    text = msg.data.get(\"message_text\", \"\")\n\n    if text:  # Skip empty messages\n        print(f\"[{tick:&gt;7}] Player {player}: {text}\")\n</code></pre>"},{"location":"guides/universal/#ping-heatmap-data","title":"Ping Heatmap Data","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_LocationPing\", 500)\n\nfrom collections import defaultdict\nping_locations = defaultdict(int)\n\nfor msg in result.messages:\n    ping = msg.data.get(\"location_ping\", {})\n    # Bucket to 500-unit grid\n    x = (ping.get(\"x\", 0) // 500) * 500\n    y = (ping.get(\"y\", 0) // 500) * 500\n    ping_locations[(x, y)] += 1\n\nprint(\"Ping Hotspots:\")\nfor loc, count in sorted(ping_locations.items(), key=lambda x: -x[1])[:10]:\n    print(f\"  ({loc[0]}, {loc[1]}): {count} pings\")\n</code></pre>"},{"location":"guides/universal/#message-type-statistics","title":"Message Type Statistics","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"\", 10000)\n\nfrom collections import Counter\ntype_counts = Counter(msg.type for msg in result.messages)\n\nprint(\"Message Type Distribution:\")\nfor msg_type, count in type_counts.most_common(20):\n    print(f\"  {msg_type}: {count}\")\n</code></pre>"},{"location":"guides/universal/#item-build-order","title":"Item Build Order","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ItemPurchased\", 1000)\n\nfrom collections import defaultdict\nplayer_items = defaultdict(list)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    item_id = msg.data.get(\"item_ability\")\n\n    player_items[player_id].append({\n        \"tick\": msg.tick,\n        \"item\": item_id\n    })\n\n# Print build order for each player\nfor player_id, items in sorted(player_items.items()):\n    print(f\"\\nPlayer {player_id} item order:\")\n    for i, item in enumerate(items, 1):\n        print(f\"  {i}. Item {item['item']} at tick {item['tick']}\")\n</code></pre>"},{"location":"guides/universal/#performance-warning","title":"Performance Warning","text":"<p>Warning</p> <p>Some message types generate thousands or millions of entries per match. Always set <code>max_messages</code> to prevent memory exhaustion.</p>"},{"location":"guides/universal/#high-frequency-messages","title":"High-Frequency Messages","text":"Message Type Frequency Notes <code>CNETMsg_Tick</code> ~1M+ Every network tick <code>CSVCMsg_PacketEntities</code> ~500K+ Entity updates <code>CDOTAUserMsg_ParticleManager</code> ~100K+ Visual effects <code>CDOTAUserMsg_OverheadEvent</code> ~50K+ Damage/heal numbers"},{"location":"guides/universal/#recommended-limits","title":"Recommended Limits","text":"<pre><code># Safe limits for common types\nchat = parser.parse_universal(\"match.dem\", \"ChatMessage\", 1000)\npings = parser.parse_universal(\"match.dem\", \"LocationPing\", 500)\nitems = parser.parse_universal(\"match.dem\", \"ItemPurchased\", 2000)\n\n# For analysis, sample large types\ntick_sample = parser.parse_universal(\"match.dem\", \"CNETMsg_Tick\", 100)\n</code></pre>"},{"location":"guides/universal/#all-272-callbacks-reference","title":"All 272 Callbacks Reference","text":"<p>For a complete list of all available callbacks, see the Callbacks Reference.</p> <p>Common useful callbacks:</p> Callback Use Case <code>CDOTAUserMsg_ChatMessage</code> Player chat <code>CDOTAUserMsg_LocationPing</code> Map pings <code>CDOTAUserMsg_ItemPurchased</code> Item builds <code>CDOTAUserMsg_UnitEvent</code> Unit actions <code>CDOTAUserMsg_OverheadEvent</code> Combat numbers <code>CDOTAUserMsg_GamerulesStateChanged</code> Game phase changes <code>CDOTAUserMsg_ChatEvent</code> Kill/event notifications <code>CMsgDOTACombatLogEntry</code> Detailed combat data <code>CDemoFileInfo</code> Match metadata"},{"location":"reference/","title":"Reference","text":"AI Summary <p>Complete reference materials for Python Manta. Includes: 272 message callbacks (Dota User Messages, Demo Messages, Network Messages), 364 game event types (player kills, tower events, rune pickups), 12 combat log entry types, modifier/buff fields, entity properties and classes, and string table structures.</p>"},{"location":"reference/#reference-materials","title":"Reference Materials","text":"Reference Description Callbacks Complete list of all 272 message callbacks Game Events All 364 game event types and fields Combat Log 12 combat log entry types Modifiers Buff/debuff modifier fields Entities Entity classes and properties String Tables String table structure and common tables"},{"location":"reference/callbacks/","title":"Callbacks Reference","text":"AI Summary <p>Complete reference of all 272 message callbacks available in Python Manta. Use with <code>parse_universal(demo_path, callback_name, max_messages)</code>. Callbacks are categorized: Dota User Messages (143 types for game events, chat, pings, items), Demo Messages (16 types for recording metadata), Network Messages (31 types for low-level networking), and misc messages. Filter matches substrings: \"Chat\" matches ChatMessage, ChatEvent, ChatWheel.</p>"},{"location":"reference/callbacks/#overview","title":"Overview","text":"<p>Python Manta supports 272 message callbacks inherited from the dotabuff/manta Go library. Use <code>parse_universal()</code> to capture any of these message types.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Filter by exact callback name\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\n# Filter by substring (matches multiple)\nresult = parser.parse_universal(\"match.dem\", \"Chat\", 200)  # ChatMessage, ChatEvent, etc.\n</code></pre>"},{"location":"reference/callbacks/#dota-user-messages-143","title":"Dota User Messages (143)","text":"<p>Game-related messages visible to players.</p>"},{"location":"reference/callbacks/#communication","title":"Communication","text":"Callback Description <code>CDOTAUserMsg_ChatMessage</code> Player chat messages <code>CDOTAUserMsg_ChatEvent</code> Chat events (kills, items, etc.) <code>CDOTAUserMsg_ChatWheel</code> Chat wheel phrases <code>CDOTAUserMsg_ChatWheelCooldown</code> Chat wheel cooldown <code>CDOTAUserMsg_BotChat</code> Bot chat messages <code>CDOTAUserMsg_BeastChat</code> Beast chat (custom game) <code>CDOTAUserMsg_SpeechBubble</code> Speech bubbles"},{"location":"reference/callbacks/#pings-and-alerts","title":"Pings and Alerts","text":"Callback Description <code>CDOTAUserMsg_LocationPing</code> Map location pings <code>CDOTAUserMsg_Ping</code> General ping <code>CDOTAUserMsg_PingConfirmation</code> Ping confirmation <code>CDOTAUserMsg_AbilityPing</code> Ability ping <code>CDOTAUserMsg_InnatePing</code> Innate ability ping <code>CDOTAUserMsg_FacetPing</code> Facet ping <code>CDOTAUserMsg_MinimapEvent</code> Minimap events <code>CDOTAUserMsg_MinimapDebugPoint</code> Debug minimap points <code>CDOTAUserMsg_MapLine</code> Map drawing lines <code>CDOTAUserMsg_WorldLine</code> World drawing lines <code>CDOTAUserMsg_CoachHUDPing</code> Coach HUD pings <code>CDOTAUserMsg_RadarAlert</code> Radar alerts"},{"location":"reference/callbacks/#item-events","title":"Item Events","text":"Callback Description <code>CDOTAUserMsg_ItemPurchased</code> Item purchases <code>CDOTAUserMsg_ItemSold</code> Item sales <code>CDOTAUserMsg_ItemFound</code> Items found <code>CDOTAUserMsg_ItemAlert</code> Item alerts <code>CDOTAUserMsg_EnemyItemAlert</code> Enemy item alerts <code>CDOTAUserMsg_QuickBuyAlert</code> Quick buy alerts <code>CDOTAUserMsg_WillPurchaseAlert</code> Will purchase alerts <code>CDOTAUserMsg_SetNextAutobuyItem</code> Auto-buy settings <code>CDOTAUserMsg_EmptyItemSlotAlert</code> Empty slot alerts <code>CDOTAUserMsg_FoundNeutralItem</code> Neutral item found"},{"location":"reference/callbacks/#combat-and-abilities","title":"Combat and Abilities","text":"Callback Description <code>CDOTAUserMsg_UnitEvent</code> Unit events (spawn, death, etc.) <code>CDOTAUserMsg_OverheadEvent</code> Overhead numbers (damage, heal) <code>CDOTAUserMsg_DamageReport</code> Damage reports <code>CDOTAUserMsg_KillcamDamageTaken</code> Killcam damage <code>CDOTAUserMsg_MiniKillCamInfo</code> Mini killcam info <code>CDOTAUserMsg_AbilitySteal</code> Ability steal (Rubick) <code>CDOTAUserMsg_ModifierAlert</code> Modifier alerts <code>CDOTAUserMsg_SharedCooldown</code> Shared cooldowns <code>CDOTAUserMsg_DodgeTrackingProjectiles</code> Projectile dodging"},{"location":"reference/callbacks/#projectiles","title":"Projectiles","text":"Callback Description <code>CDOTAUserMsg_CreateLinearProjectile</code> Create projectile <code>CDOTAUserMsg_DestroyLinearProjectile</code> Destroy projectile <code>CDOTAUserMsg_UpdateLinearProjectileCPData</code> Update projectile <code>CDOTAUserMsg_TE_Projectile</code> Projectile effect <code>CDOTAUserMsg_TE_ProjectileLoc</code> Projectile location <code>CDOTAUserMsg_TE_DestroyProjectile</code> Destroy projectile effect <code>CDOTAUserMsg_TE_DotaBloodImpact</code> Blood impact effect"},{"location":"reference/callbacks/#animation","title":"Animation","text":"Callback Description <code>CDOTAUserMsg_TE_UnitAnimation</code> Unit animation <code>CDOTAUserMsg_TE_UnitAnimationEnd</code> Animation end <code>CDOTAUserMsg_MiniTaunt</code> Mini taunt <code>CDOTAUserMsg_HighFiveCompleted</code> High five complete <code>CDOTAUserMsg_HighFiveLeftHanging</code> High five missed <code>CDOTAUserMsg_SalutePlayer</code> Player salute"},{"location":"reference/callbacks/#game-state","title":"Game State","text":"Callback Description <code>CDOTAUserMsg_GamerulesStateChanged</code> Game state change <code>CDOTAUserMsg_SendFinalGold</code> Final gold amounts <code>CDOTAUserMsg_SelectPenaltyGold</code> Penalty gold <code>CDOTAUserMsg_RoshanTimer</code> Roshan timer <code>CDOTAUserMsg_SendRoshanPopup</code> Roshan popup <code>CDOTAUserMsg_SendRoshanSpectatorPhase</code> Roshan phase <code>CDOTAUserMsg_OutpostCaptured</code> Outpost captured <code>CDOTAUserMsg_OutpostGrantedXP</code> Outpost XP <code>CDOTAUserMsg_XPAlert</code> XP alerts"},{"location":"reference/callbacks/#draft-and-hero-selection","title":"Draft and Hero Selection","text":"Callback Description <code>CDOTAUserMsg_AbilityDraftRequestAbility</code> Ability draft request <code>CDOTAUserMsg_PlayerDraftPick</code> Draft pick <code>CDOTAUserMsg_PlayerDraftSuggestPick</code> Draft suggestion <code>CDOTAUserMsg_SuggestHeroPick</code> Hero suggestion <code>CDOTAUserMsg_SuggestHeroRole</code> Role suggestion <code>CDOTAUserMsg_SwapVerify</code> Swap verification"},{"location":"reference/callbacks/#stats-and-progress","title":"Stats and Progress","text":"Callback Description <code>CDOTAUserMsg_StatsMatchDetails</code> Match statistics <code>CDOTAUserMsg_StatsHeroMinuteDetails</code> Per-minute hero stats <code>CDOTAUserMsg_HeroRelicProgress</code> Hero relic progress <code>CDOTAUserMsg_QuestStatus</code> Quest status <code>CDOTAUserMsg_UpdateQuestProgress</code> Quest progress update <code>CDOTAUserMsg_AddQuestLogEntry</code> Quest log entry <code>CDOTAUserMsg_GuildChallenge_Progress</code> Guild challenge <code>CDOTAUserMsg_CompendiumState</code> Compendium state"},{"location":"reference/callbacks/#spectator-and-player-input","title":"Spectator and Player Input","text":"Callback Description <code>CDOTAUserMsg_SpectatorPlayerClick</code> Spectator clicks <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> Player commands - attack, move, cast, items. See Unit Orders Guide <code>CDOTAUserMsg_MoveCameraToUnit</code> Camera movement <code>CDOTAUserMsg_CombatHeroPositions</code> Hero positions <p>Creep Aggro Detection</p> <p>Use <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> with <code>order_type=4</code> (ATTACK_TARGET) to detect attack commands that trigger creep aggro. See the Unit Orders Guide for detailed examples.</p>"},{"location":"reference/callbacks/#alerts","title":"Alerts","text":"Callback Description <code>CDOTAUserMsg_HPManaAlert</code> HP/Mana alerts <code>CDOTAUserMsg_GlyphAlert</code> Glyph alerts <code>CDOTAUserMsg_NeutralCampAlert</code> Neutral camp alerts <code>CDOTAUserMsg_CourierKilledAlert</code> Courier killed <code>CDOTAUserMsg_BuyBackStateAlert</code> Buyback state <code>CDOTAUserMsg_AghsStatusAlert</code> Aghanim's status <code>CDOTAUserMsg_TalentTreeAlert</code> Talent alerts <code>CDOTAUserMsg_TimerAlert</code> Timer alerts <code>CDOTAUserMsg_TipAlert</code> Tip alerts <code>CDOTAUserMsg_MadstoneAlert</code> Madstone alerts <code>CDOTAUserMsg_EmptyTeleportAlert</code> Empty TP scroll"},{"location":"reference/callbacks/#duel-and-combat","title":"Duel and Combat","text":"Callback Description <code>CDOTAUserMsg_DuelRequested</code> Duel request <code>CDOTAUserMsg_DuelAccepted</code> Duel accepted <code>CDOTAUserMsg_DuelOpponentKilled</code> Duel kill <code>CDOTAUserMsg_NevermoreRequiem</code> SF Requiem <code>CDOTAUserMsg_MarsArenaOfBloodAttack</code> Mars Arena"},{"location":"reference/callbacks/#arcana-and-cosmetics","title":"Arcana and Cosmetics","text":"Callback Description <code>CDOTAUserMsg_ESArcanaCombo</code> Earth Spirit Arcana <code>CDOTAUserMsg_ESArcanaComboSummary</code> ES Arcana summary <code>CDOTAUserMsg_WRArcanaProgress</code> Windranger Arcana <code>CDOTAUserMsg_WRArcanaSummary</code> WR Arcana summary <code>CDOTAUserMsg_QoP_ArcanaSummary</code> QoP Arcana <code>CDOTAUserMsg_OMArcanaCombo</code> Ogre Magi Arcana <code>CDOTAUserMsg_WK_Arcana_Progress</code> Wraith King Arcana <code>CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled</code> Muerta event"},{"location":"reference/callbacks/#voting-and-social","title":"Voting and Social","text":"Callback Description <code>CDOTAUserMsg_VoteStart</code> Vote start <code>CDOTAUserMsg_VoteUpdate</code> Vote update <code>CDOTAUserMsg_VoteEnd</code> Vote end <code>CDOTAUserMsg_FlipCoinResult</code> Coin flip <code>CDOTAUserMsg_RollDiceResult</code> Dice roll <code>CDOTAUserMsg_RockPaperScissorsStarted</code> RPS started <code>CDOTAUserMsg_RockPaperScissorsFinished</code> RPS finished <code>CDOTAUserMsg_GiftPlayer</code> Gift player"},{"location":"reference/callbacks/#ui-and-hud","title":"UI and HUD","text":"Callback Description <code>CDOTAUserMsg_HudError</code> HUD errors <code>CDOTAUserMsg_SendStatPopup</code> Stat popup <code>CDOTAUserMsg_SendGenericToolTip</code> Generic tooltip <code>CDOTAUserMsg_ShowGenericPopup</code> Generic popup <code>CDOTAUserMsg_DismissAllStatPopups</code> Dismiss popups <code>CDOTAUserMsg_CustomMsg</code> Custom message <code>CDOTAUserMsg_CustomHeaderMessage</code> Custom header <code>CDOTAUserMsg_CustomHudElement_Create</code> Custom HUD create <code>CDOTAUserMsg_CustomHudElement_Modify</code> Custom HUD modify <code>CDOTAUserMsg_CustomHudElement_Destroy</code> Custom HUD destroy <code>CDOTAUserMsg_ContextualTip</code> Contextual tips <code>CDOTAUserMsg_ShowSurvey</code> Survey popup <code>CDOTAUserMsg_InvalidCommand</code> Invalid command"},{"location":"reference/callbacks/#tutorial","title":"Tutorial","text":"Callback Description <code>CDOTAUserMsg_TutorialTipInfo</code> Tutorial tips <code>CDOTAUserMsg_TutorialFade</code> Tutorial fade <code>CDOTAUserMsg_TutorialFinish</code> Tutorial finish <code>CDOTAUserMsg_TutorialMinimapPosition</code> Minimap position <code>CDOTAUserMsg_TutorialPingMinimap</code> Minimap ping <code>CDOTAUserMsg_TutorialRequestExp</code> Request XP"},{"location":"reference/callbacks/#misc-dota","title":"Misc Dota","text":"Callback Description <code>CDOTAUserMsg_BoosterState</code> Booster state <code>CDOTAUserMsg_HalloweenDrops</code> Halloween drops <code>CDOTAUserMsg_ReceivedXmasGift</code> Xmas gift <code>CDOTAUserMsg_MutedPlayers</code> Muted players <code>CDOTAUserMsg_PauseMinigameData</code> Pause minigame <code>CDOTAUserMsg_ReplaceQueryUnit</code> Replace query unit <code>CDOTAUserMsg_UpdateSharedContent</code> Shared content <code>CDOTAUserMsg_QueuedOrderRemoved</code> Queued order <code>CDOTAUserMsg_ProjectionAbility</code> Projection ability <code>CDOTAUserMsg_ProjectionEvent</code> Projection event <code>CDOTAUserMsg_VersusScene_PlayerBehavior</code> Versus scene <code>CDOTAUserMsg_AIDebugLine</code> AI debug <code>CDOTAUserMsg_CombatLogBulkData</code> Combat log bulk <code>CDOTAUserMsg_AllStarEvent</code> All-Star event <code>CDOTAUserMsg_DebugChallenge</code> Debug challenge <code>CDOTAUserMsg_ClientLoadGridNav</code> Grid nav <code>CDOTAUserMsg_GlobalLightColor</code> Global light color <code>CDOTAUserMsg_GlobalLightDirection</code> Global light direction <code>CDOTAUserMsg_ShovelUnearth</code> Shovel unearth <code>CDOTAUserMsg_NeutralCraftAvailable</code> Neutral craft <code>CDOTAUserMsg_HotPotato_Created</code> Hot potato created <code>CDOTAUserMsg_HotPotato_Exploded</code> Hot potato exploded"},{"location":"reference/callbacks/#demo-messages-16","title":"Demo Messages (16)","text":"<p>Recording-related messages from the demo file.</p> Callback Description <code>CDemoFileHeader</code> File header <code>CDemoFileInfo</code> Match info (picks/bans) <code>CDemoPacket</code> Demo packet <code>CDemoFullPacket</code> Full state snapshot <code>CDemoSyncTick</code> Sync tick <code>CDemoStop</code> Demo stop <code>CDemoStringTables</code> String tables <code>CDemoSendTables</code> Send tables <code>CDemoClassInfo</code> Class info <code>CDemoSignonPacket</code> Signon packet <code>CDemoConsoleCmd</code> Console command <code>CDemoCustomData</code> Custom data <code>CDemoCustomDataCallbacks</code> Custom callbacks <code>CDemoUserCmd</code> User command <code>CDemoSaveGame</code> Save game <code>CDemoSpawnGroups</code> Spawn groups <code>CDemoAnimationData</code> Animation data <code>CDemoAnimationHeader</code> Animation header <code>CDemoRecovery</code> Recovery data <code>CDOTAMatchMetadataFile</code> Match metadata"},{"location":"reference/callbacks/#network-messages-31","title":"Network Messages (31)","text":"<p>Low-level network protocol messages.</p>"},{"location":"reference/callbacks/#net-messages","title":"NET Messages","text":"Callback Description <code>CNETMsg_Tick</code> Network tick (very frequent!) <code>CNETMsg_NOP</code> No operation <code>CNETMsg_SetConVar</code> Set console variable <code>CNETMsg_SignonState</code> Signon state <code>CNETMsg_StringCmd</code> String command <code>CNETMsg_SplitScreenUser</code> Split screen <code>CNETMsg_DebugOverlay</code> Debug overlay"},{"location":"reference/callbacks/#spawn-group-messages","title":"Spawn Group Messages","text":"Callback Description <code>CNETMsg_SpawnGroup_Load</code> Load spawn group <code>CNETMsg_SpawnGroup_Unload</code> Unload spawn group <code>CNETMsg_SpawnGroup_LoadCompleted</code> Load complete <code>CNETMsg_SpawnGroup_ManifestUpdate</code> Manifest update <code>CNETMsg_SpawnGroup_SetCreationTick</code> Creation tick"},{"location":"reference/callbacks/#svc-messages","title":"SVC Messages","text":"Callback Description <code>CSVCMsg_ServerInfo</code> Server information <code>CSVCMsg_ClassInfo</code> Class information <code>CSVCMsg_CreateStringTable</code> Create string table <code>CSVCMsg_UpdateStringTable</code> Update string table <code>CSVCMsg_ClearAllStringTables</code> Clear string tables <code>CSVCMsg_PacketEntities</code> Entity updates <code>CSVCMsg_PacketReliable</code> Reliable packet <code>CSVCMsg_FlattenedSerializer</code> Serializer data <code>CSVCMsg_Prefetch</code> Prefetch <code>CSVCMsg_SetView</code> Set view <code>CSVCMsg_SetPause</code> Set pause <code>CSVCMsg_Sounds</code> Sound events <code>CSVCMsg_VoiceInit</code> Voice init <code>CSVCMsg_VoiceData</code> Voice data <code>CSVCMsg_Print</code> Print message <code>CSVCMsg_Menu</code> Menu <code>CSVCMsg_GetCvarValue</code> Get cvar value <code>CSVCMsg_UserMessage</code> User message <code>CSVCMsg_SplitScreen</code> Split screen <code>CSVCMsg_BSPDecal</code> BSP decal <code>CSVCMsg_CmdKeyValues</code> Key values <code>CSVCMsg_Broadcast_Command</code> Broadcast command <code>CSVCMsg_FullFrameSplit</code> Frame split <code>CSVCMsg_HLTVStatus</code> HLTV status <code>CSVCMsg_HltvFixupOperatorStatus</code> HLTV fixup <code>CSVCMsg_PeerList</code> Peer list <code>CSVCMsg_RconServerDetails</code> RCON details <code>CSVCMsg_ServerSteamID</code> Server Steam ID <code>CSVCMsg_StopSound</code> Stop sound"},{"location":"reference/callbacks/#combat-log-message","title":"Combat Log Message","text":"Callback Description <code>CMsgDOTACombatLogEntry</code> Combat log entry <p>Note</p> <p>For structured combat log parsing, use <code>parse_combat_log()</code> instead of <code>parse_universal()</code>.</p>"},{"location":"reference/callbacks/#entity-messages-6","title":"Entity Messages (6)","text":"<p>Entity-related messages.</p> Callback Description <code>CEntityMessageDoSpark</code> Spark effect <code>CEntityMessageFixAngle</code> Fix angle <code>CEntityMessagePlayJingle</code> Play jingle <code>CEntityMessagePropagateForce</code> Propagate force <code>CEntityMessageRemoveAllDecals</code> Remove decals <code>CEntityMessageScreenOverlay</code> Screen overlay"},{"location":"reference/callbacks/#general-user-messages-25","title":"General User Messages (25)","text":"<p>Generic Source 2 user messages.</p> Callback Description <code>CUserMessageSayText</code> Say text <code>CUserMessageSayText2</code> Say text 2 <code>CUserMessageSayTextChannel</code> Say text channel <code>CUserMessageTextMsg</code> Text message <code>CUserMessageHudMsg</code> HUD message <code>CUserMessageHudText</code> HUD text <code>CUserMessageShake</code> Screen shake <code>CUserMessageShakeDir</code> Directional shake <code>CUserMessageFade</code> Screen fade <code>CUserMessageScreenTilt</code> Screen tilt <code>CUserMessageRumble</code> Rumble <code>CUserMessageCloseCaption</code> Closed caption <code>CUserMessageCloseCaptionDirect</code> Direct caption <code>CUserMessageCloseCaptionPlaceholder</code> Caption placeholder <code>CUserMessageSendAudio</code> Send audio <code>CUserMessageAudioParameter</code> Audio parameter <code>CUserMessageVoiceMask</code> Voice mask <code>CUserMessageRequestState</code> Request state <code>CUserMessageRequestInventory</code> Request inventory <code>CUserMessageRequestDiagnostic</code> Request diagnostic <code>CUserMessageRequestDllStatus</code> Request DLL status <code>CUserMessageRequestUtilAction</code> Request util action <code>CUserMessageResetHUD</code> Reset HUD <code>CUserMessageItemPickup</code> Item pickup <code>CUserMessageShowMenu</code> Show menu <code>CUserMessageColoredText</code> Colored text <code>CUserMessageCreditsMsg</code> Credits <code>CUserMessageAchievementEvent</code> Achievement <code>CUserMessageCurrentTimescale</code> Current timescale <code>CUserMessageDesiredTimescale</code> Desired timescale <code>CUserMessageGameTitle</code> Game title <code>CUserMessageAmmoDenied</code> Ammo denied <code>CUserMessageCameraTransition</code> Camera transition <code>CUserMessageHapticsManagerEffect</code> Haptics effect <code>CUserMessageHapticsManagerPulse</code> Haptics pulse <code>CUserMessageLagCompensationError</code> Lag compensation <code>CUserMessageServerFrameTime</code> Server frame time <code>CUserMessageUpdateCssClasses</code> Update CSS <code>CUserMessageWaterShake</code> Water shake"},{"location":"reference/callbacks/#misc-messages-15","title":"Misc Messages (15)","text":"<p>Other message types.</p> Callback Description <code>CMsgSource1LegacyGameEvent</code> Legacy game event <code>CMsgSource1LegacyGameEventList</code> Game event list <code>CMsgSource1LegacyListenEvents</code> Listen events <code>CMsgDOTACombatLogEntry</code> Combat log <code>CMsgGCToClientTournamentItemDrop</code> Tournament drop <code>CMsgVDebugGameSessionIDEvent</code> Debug session ID <code>CMsgPlaceDecalEvent</code> Place decal <code>CMsgClearWorldDecalsEvent</code> Clear world decals <code>CMsgClearEntityDecalsEvent</code> Clear entity decals <code>CMsgClearDecalsForSkeletonInstanceEvent</code> Clear skeleton decals <code>CMsgSosStartSoundEvent</code> Start sound <code>CMsgSosStopSoundEvent</code> Stop sound <code>CMsgSosStopSoundEventHash</code> Stop sound hash <code>CMsgSosSetSoundEventParams</code> Sound params <code>CMsgSosSetLibraryStackFields</code> Library stack"},{"location":"reference/callbacks/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/callbacks/#common-filters","title":"Common Filters","text":"<pre><code># Chat and communication\nchat = parser.parse_universal(\"match.dem\", \"ChatMessage\", 100)\npings = parser.parse_universal(\"match.dem\", \"LocationPing\", 100)\nwheel = parser.parse_universal(\"match.dem\", \"ChatWheel\", 100)\n\n# Items\npurchases = parser.parse_universal(\"match.dem\", \"ItemPurchased\", 500)\nalerts = parser.parse_universal(\"match.dem\", \"ItemAlert\", 100)\n\n# Combat\noverhead = parser.parse_universal(\"match.dem\", \"OverheadEvent\", 500)\nunit_events = parser.parse_universal(\"match.dem\", \"UnitEvent\", 200)\n\n# Game state\nstate_changes = parser.parse_universal(\"match.dem\", \"GamerulesStateChanged\", 20)\n</code></pre>"},{"location":"reference/callbacks/#filtering-multiple-types","title":"Filtering Multiple Types","text":"<pre><code># Substring \"Alert\" matches many alert types\nalerts = parser.parse_universal(\"match.dem\", \"Alert\", 500)\n\n# Common matched types:\n# - CDOTAUserMsg_ItemAlert\n# - CDOTAUserMsg_EnemyItemAlert\n# - CDOTAUserMsg_GlyphAlert\n# - CDOTAUserMsg_NeutralCampAlert\n# - etc.\n</code></pre>"},{"location":"reference/combat-log/","title":"Combat Log Reference","text":"AI Summary <p>Complete reference for 12 combat log entry types parsed from Dota 2 replays. Types include: DAMAGE (0), HEAL (1), MODIFIER_ADD (2), MODIFIER_REMOVE (3), DEATH (4), ABILITY (5), ITEM (6), LOCATION (7), GOLD (8), GAME_STATE (9), XP (10), PURCHASE (11). Each entry contains attacker/target info, damage values, timestamps, and team visibility flags.</p>"},{"location":"reference/combat-log/#combat-log-types","title":"Combat Log Types","text":"Type ID Name Description 0 DAMAGE Damage dealt to a unit 1 HEAL Health restored to a unit 2 MODIFIER_ADD Buff/debuff applied 3 MODIFIER_REMOVE Buff/debuff removed 4 DEATH Unit death 5 ABILITY Ability used 6 ITEM Item used 7 LOCATION Location event 8 GOLD Gold gained/lost 9 GAME_STATE Game state change 10 XP Experience gained 11 PURCHASE Item purchased"},{"location":"reference/combat-log/#entry-fields","title":"Entry Fields","text":"<p>Every <code>CombatLogEntry</code> contains these fields:</p>"},{"location":"reference/combat-log/#identification","title":"Identification","text":"Field Type Description <code>tick</code> <code>int</code> Game tick <code>net_tick</code> <code>int</code> Network tick <code>type</code> <code>int</code> Combat log type ID (0-11) <code>type_name</code> <code>str</code> Human-readable type name <code>timestamp</code> <code>float</code> Game time in seconds"},{"location":"reference/combat-log/#participants","title":"Participants","text":"Field Type Description <code>attacker_name</code> <code>str</code> Attacker unit name <code>target_name</code> <code>str</code> Target unit name <code>target_source_name</code> <code>str</code> Target source name <code>damage_source_name</code> <code>str</code> Damage source name <code>inflictor_name</code> <code>str</code> Ability/item causing the effect"},{"location":"reference/combat-log/#unit-flags","title":"Unit Flags","text":"Field Type Description <code>is_attacker_hero</code> <code>bool</code> Attacker is a hero <code>is_attacker_illusion</code> <code>bool</code> Attacker is an illusion <code>is_target_hero</code> <code>bool</code> Target is a hero <code>is_target_illusion</code> <code>bool</code> Target is an illusion <code>attacker_team</code> <code>int</code> Attacker team ID <code>target_team</code> <code>int</code> Target team ID"},{"location":"reference/combat-log/#visibility","title":"Visibility","text":"Field Type Description <code>is_visible_radiant</code> <code>bool</code> Visible to Radiant team <code>is_visible_dire</code> <code>bool</code> Visible to Dire team"},{"location":"reference/combat-log/#values","title":"Values","text":"Field Type Description <code>value</code> <code>int</code> Primary value (damage, heal, gold, XP) <code>health</code> <code>int</code> Target health after event <code>gold</code> <code>int</code> Gold value <code>xp</code> <code>int</code> XP value <code>last_hits</code> <code>int</code> Last hits at time of event"},{"location":"reference/combat-log/#ability-info","title":"Ability Info","text":"Field Type Description <code>ability_level</code> <code>int</code> Level of ability used <code>is_ability_toggle_on</code> <code>bool</code> Ability toggled on <code>is_ability_toggle_off</code> <code>bool</code> Ability toggled off"},{"location":"reference/combat-log/#duration-effects","title":"Duration Effects","text":"Field Type Description <code>stun_duration</code> <code>float</code> Stun duration in seconds <code>slow_duration</code> <code>float</code> Slow duration in seconds"},{"location":"reference/combat-log/#type-specific-usage","title":"Type-Specific Usage","text":""},{"location":"reference/combat-log/#damage-type-0","title":"DAMAGE (Type 0)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.attacker_name} -&gt; {entry.target_name}: {entry.value} damage\")\n    if entry.inflictor_name:\n        print(f\"  via {entry.inflictor_name}\")\n</code></pre>"},{"location":"reference/combat-log/#heal-type-1","title":"HEAL (Type 1)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.target_name} healed for {entry.value}\")\n</code></pre>"},{"location":"reference/combat-log/#modifier_add-type-2","title":"MODIFIER_ADD (Type 2)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[2], max_entries=100)\n\nfor entry in result.entries:\n    if entry.inflictor_name:\n        print(f\"[{entry.timestamp:.1f}s] {entry.inflictor_name} applied to {entry.target_name}\")\n</code></pre>"},{"location":"reference/combat-log/#death-type-4","title":"DEATH (Type 4)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[4], heroes_only=True, max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.timestamp:.1f}s] {entry.target_name} died\")\n    if entry.attacker_name:\n        print(f\"  killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"reference/combat-log/#gold-type-8","title":"GOLD (Type 8)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[8], max_entries=100)\n\nfor entry in result.entries:\n    if entry.gold &gt; 0:\n        print(f\"[{entry.timestamp:.1f}s] {entry.target_name} gained {entry.gold} gold\")\n</code></pre>"},{"location":"reference/combat-log/#xp-type-10","title":"XP (Type 10)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[10], max_entries=100)\n\nfor entry in result.entries:\n    if entry.xp &gt; 0:\n        print(f\"[{entry.timestamp:.1f}s] {entry.target_name} gained {entry.xp} XP\")\n</code></pre>"},{"location":"reference/combat-log/#filtering","title":"Filtering","text":""},{"location":"reference/combat-log/#by-type","title":"By Type","text":"<pre><code># Only damage and death\nresult = parser.parse_combat_log(\"match.dem\", types=[0, 4], max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#by-hero","title":"By Hero","text":"<pre><code># Only hero-to-hero combat\nresult = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#combined","title":"Combined","text":"<pre><code># Hero damage only\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#unit-name-format","title":"Unit Name Format","text":"<p>Unit names follow Dota 2's internal naming:</p> Pattern Example Description <code>npc_dota_hero_*</code> <code>npc_dota_hero_axe</code> Hero <code>npc_dota_creep_*</code> <code>npc_dota_creep_badguys_melee</code> Lane creep <code>npc_dota_neutral_*</code> <code>npc_dota_neutral_centaur_khan</code> Neutral creep <code>npc_dota_*tower*</code> <code>npc_dota_badguys_tower1_mid</code> Tower <code>npc_dota_roshan</code> <code>npc_dota_roshan</code> Roshan"},{"location":"reference/combat-log/#timing-note","title":"Timing Note","text":"<p>Combat log entries typically appear after 12-17 minutes of game time. For early-game events, use <code>parse_game_events()</code> instead.</p>"},{"location":"reference/entities/","title":"Entities Reference","text":"AI Summary <p>Reference for querying game entities from Dota 2 replays. Entities represent all game objects: heroes, creeps, buildings, items, abilities, and more. Use <code>query_entities()</code> to get entity data at a specific tick with optional class filtering. Each entity has an index, serial, class name, and property dictionary. Common properties include health, mana, position, level, gold, and KDA stats.</p>"},{"location":"reference/entities/#entity-data-fields","title":"Entity Data Fields","text":"<p>Every <code>EntityData</code> contains:</p> Field Type Description <code>index</code> <code>int</code> Entity index (unique identifier) <code>serial</code> <code>int</code> Entity serial number <code>class_name</code> <code>str</code> Entity class name (e.g., <code>CDOTA_Unit_Hero_Axe</code>) <code>properties</code> <code>Dict[str, Any]</code> Entity properties dictionary"},{"location":"reference/entities/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    print(f\"{entity.class_name} (index={entity.index})\")\n    print(f\"  Health: {entity.properties.get('m_iHealth')}\")\n    print(f\"  Level: {entity.properties.get('m_iCurrentLevel')}\")\n</code></pre>"},{"location":"reference/entities/#entity-classes","title":"Entity Classes","text":""},{"location":"reference/entities/#heroes","title":"Heroes","text":"Class Pattern Description <code>CDOTA_Unit_Hero_*</code> Hero units <code>CDOTA_Unit_Hero_Axe</code> Axe specifically <code>CDOTA_Unit_Hero_Invoker</code> Invoker specifically"},{"location":"reference/entities/#creeps","title":"Creeps","text":"Class Pattern Description <code>CDOTA_BaseNPC_Creep_*</code> Lane creeps <code>CDOTA_BaseNPC_Creep_Neutral</code> Neutral creeps"},{"location":"reference/entities/#buildings","title":"Buildings","text":"Class Pattern Description <code>CDOTA_BaseNPC_Tower</code> Towers <code>CDOTA_BaseNPC_Barracks</code> Barracks <code>CDOTA_BaseNPC_Building</code> Ancient and other buildings <code>CDOTA_BaseNPC_Fort</code> Ancient (throne)"},{"location":"reference/entities/#other-units","title":"Other Units","text":"Class Pattern Description <code>CDOTA_BaseNPC_Courier</code> Couriers <code>CDOTA_Unit_Roshan</code> Roshan <code>CDOTA_NPC_Observer_Ward</code> Observer wards <code>CDOTA_NPC_Sentry_Ward</code> Sentry wards"},{"location":"reference/entities/#items","title":"Items","text":"Class Pattern Description <code>CDOTA_Item_*</code> Items <code>CDOTA_Item_Physical</code> Dropped items"},{"location":"reference/entities/#abilities","title":"Abilities","text":"Class Pattern Description <code>CDOTA_Ability_*</code> Ability instances"},{"location":"reference/entities/#common-hero-properties","title":"Common Hero Properties","text":""},{"location":"reference/entities/#health-mana","title":"Health &amp; Mana","text":"Property Type Description <code>m_iHealth</code> <code>int</code> Current health <code>m_iMaxHealth</code> <code>int</code> Maximum health <code>m_flMana</code> <code>float</code> Current mana <code>m_flMaxMana</code> <code>float</code> Maximum mana <code>m_flHealthThinkRegen</code> <code>float</code> Health regeneration <code>m_flManaThinkRegen</code> <code>float</code> Mana regeneration"},{"location":"reference/entities/#position-movement","title":"Position &amp; Movement","text":"Property Type Description <code>m_vecOrigin</code> <code>[x, y, z]</code> Position in world coordinates <code>m_angRotation</code> <code>[pitch, yaw, roll]</code> Rotation angles <code>m_flSpeed</code> <code>float</code> Current movement speed"},{"location":"reference/entities/#combat-stats","title":"Combat Stats","text":"Property Type Description <code>m_iCurrentLevel</code> <code>int</code> Hero level <code>m_iKills</code> <code>int</code> Kills <code>m_iDeaths</code> <code>int</code> Deaths <code>m_iAssists</code> <code>int</code> Assists <code>m_iDamageMin</code> <code>int</code> Minimum attack damage <code>m_iDamageMax</code> <code>int</code> Maximum attack damage <code>m_flPhysicalArmorValue</code> <code>float</code> Armor value <code>m_flMagicalResistanceValue</code> <code>float</code> Magic resistance"},{"location":"reference/entities/#economy","title":"Economy","text":"Property Type Description <code>m_iGold</code> <code>int</code> Reliable + unreliable gold <code>m_iGoldReliable</code> <code>int</code> Reliable gold <code>m_iGoldUnreliable</code> <code>int</code> Unreliable gold <code>m_iTotalEarnedGold</code> <code>int</code> Total gold earned <code>m_iLastHitCount</code> <code>int</code> Total last hits <code>m_iDenyCount</code> <code>int</code> Total denies"},{"location":"reference/entities/#team-player","title":"Team &amp; Player","text":"Property Type Description <code>m_iTeamNum</code> <code>int</code> Team number (2=Radiant, 3=Dire) <code>m_iPlayerID</code> <code>int</code> Player ID (0-9) <code>m_hAbilities</code> <code>list</code> Ability handles <code>m_hItems</code> <code>list</code> Item handles"},{"location":"reference/entities/#filtering","title":"Filtering","text":""},{"location":"reference/entities/#by-class-name","title":"By Class Name","text":"<pre><code># All heroes\nheroes = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\n# All towers\ntowers = parser.query_entities(\"match.dem\", class_filter=\"Tower\", max_entities=20)\n\n# All couriers\ncouriers = parser.query_entities(\"match.dem\", class_filter=\"Courier\", max_entities=4)\n</code></pre>"},{"location":"reference/entities/#by-tick","title":"By Tick","text":"<pre><code># Get state at specific tick\nearly_game = parser.query_entities(\"match.dem\", tick=10000, class_filter=\"Hero\")\nlate_game = parser.query_entities(\"match.dem\", tick=50000, class_filter=\"Hero\")\n</code></pre>"},{"location":"reference/entities/#by-property","title":"By Property","text":"<pre><code># Get all entities, then filter in Python\nresult = parser.query_entities(\"match.dem\", max_entities=100)\n\n# Find low health heroes\nlow_health = [\n    e for e in result.entities\n    if \"Hero\" in e.class_name\n    and e.properties.get(\"m_iHealth\", 0) &lt; 500\n]\n</code></pre>"},{"location":"reference/entities/#property-name-patterns","title":"Property Name Patterns","text":"<p>Properties follow Source 2 naming conventions:</p> Prefix Meaning Example <code>m_i</code> Integer <code>m_iHealth</code> <code>m_fl</code> Float <code>m_flMana</code> <code>m_b</code> Boolean <code>m_bIsAlive</code> <code>m_sz</code> String <code>m_szName</code> <code>m_vec</code> Vector <code>m_vecOrigin</code> <code>m_ang</code> Angle <code>m_angRotation</code> <code>m_h</code> Handle <code>m_hAbilities</code> <code>m_n</code> Enum/Int <code>m_nGameState</code>"},{"location":"reference/entities/#result-metadata","title":"Result Metadata","text":"<p><code>EntitiesResult</code> includes:</p> Field Type Description <code>entities</code> <code>List[EntityData]</code> Entity data <code>total_entities</code> <code>int</code> Count of entities returned <code>tick</code> <code>int</code> Tick when captured <code>net_tick</code> <code>int</code> Network tick when captured <code>success</code> <code>bool</code> Parse success flag <code>error</code> <code>Optional[str]</code> Error message if failed"},{"location":"reference/game-events/","title":"Game Events Reference","text":"AI Summary <p>Complete reference for 364 Source 1 legacy game events in Dota 2 replays. Events are organized by category: Player (kills, denies, abilities), Unit (towers, barracks, roshan), Item (purchases, pickups), Rune (spawns, activations), Game State (match events), and Combat (combatlog). Use <code>parse_game_events()</code> with <code>capture_types=True</code> to discover all available events in a replay.</p>"},{"location":"reference/game-events/#event-categories","title":"Event Categories","text":""},{"location":"reference/game-events/#player-events","title":"Player Events","text":"Event Name Description Key Fields <code>dota_player_kill</code> Player killed another player <code>victim_userid</code>, <code>killer1_userid</code>, <code>killer2_userid</code>-<code>killer5_userid</code> <code>dota_player_deny</code> Player denied a unit <code>killer_userid</code>, <code>denied_userid</code> <code>dota_player_pick_hero</code> Player picked a hero <code>player</code>, <code>heroindex</code>, <code>hero</code> <code>dota_player_learned_ability</code> Player learned an ability <code>player</code>, <code>abilityname</code> <code>dota_player_used_ability</code> Player used an ability <code>player</code>, <code>abilityname</code> <code>dota_player_gained_level</code> Player leveled up <code>player</code>, <code>level</code> <code>dota_player_take_tower_damage</code> Player took tower damage <code>player</code>, <code>damage</code> <code>dota_player_update_hero_selection</code> Hero selection updated <code>player</code> <code>dota_player_update_selected_unit</code> Selected unit changed <code>player</code> <code>dota_player_update_query_unit</code> Query unit changed <code>player</code> <code>dota_player_update_killcam_unit</code> Killcam unit changed <code>player</code>"},{"location":"reference/game-events/#unit-events","title":"Unit Events","text":"Event Name Description Key Fields <code>dota_tower_kill</code> Tower destroyed <code>killer_userid</code>, <code>teamnumber</code>, <code>gold</code> <code>dota_barracks_kill</code> Barracks destroyed <code>killer_userid</code>, <code>teamnumber</code> <code>dota_roshan_kill</code> Roshan killed <code>teamnumber</code> <code>dota_courier_lost</code> Courier killed <code>teamnumber</code> <code>dota_npc_goal_reached</code> NPC reached goal <code>npc_entindex</code> <code>dota_hero_swap</code> Heroes swapped <code>playerid1</code>, <code>playerid2</code>"},{"location":"reference/game-events/#item-events","title":"Item Events","text":"Event Name Description Key Fields <code>dota_item_purchased</code> Item purchased <code>userid</code>, <code>itemname</code> <code>dota_item_combined</code> Items combined <code>userid</code>, <code>itemname</code> <code>dota_item_picked_up</code> Item picked up <code>userid</code>, <code>itemname</code> <code>dota_inventory_changed</code> Inventory changed <code>userid</code> <code>dota_item_given</code> Item given to another <code>userid</code>, <code>itemname</code>, <code>recipientuserid</code>"},{"location":"reference/game-events/#rune-events","title":"Rune Events","text":"Event Name Description Key Fields <code>dota_rune_activated</code> Rune activated <code>player_id</code>, <code>rune</code> <code>dota_rune_spawned</code> Rune spawned <code>rune</code>, <code>pos_x</code>, <code>pos_y</code>, <code>pos_z</code> <code>dota_bounty_rune_pickup</code> Bounty rune picked up <code>player_id</code>, <code>team</code>, <code>gold</code> <code>dota_neutral_token_pickup</code> Neutral token picked up <code>player_id</code>"},{"location":"reference/game-events/#game-state-events","title":"Game State Events","text":"Event Name Description Key Fields <code>dota_match_done</code> Match ended <code>winningteam</code>, <code>radiant_score</code>, <code>dire_score</code> <code>dota_game_state_change</code> Game state changed <code>old_state</code>, <code>new_state</code> <code>game_rules_state_change</code> Game rules changed <code>state</code> <code>dota_team_kill_credit</code> Team credited with kill <code>killer_userid</code>, <code>victim_userid</code>, <code>teamnumber</code> <code>dota_aegis_event</code> Aegis event <code>player_id</code>, <code>event</code> <code>dota_buyback</code> Player bought back <code>player_id</code>, <code>cost</code> <code>dota_glyph_used</code> Glyph activated <code>teamnumber</code>"},{"location":"reference/game-events/#combat-events","title":"Combat Events","text":"Event Name Description Key Fields <code>dota_combatlog</code> Combat log entry <code>type</code>, <code>sourcename</code>, <code>targetname</code>, <code>value</code> <code>dota_player_take_tower_damage</code> Tower damage taken <code>player</code>, <code>damage</code>"},{"location":"reference/game-events/#event-field-types","title":"Event Field Types","text":"<p>Fields in game events are automatically typed:</p> Go Type Python Type Example <code>string</code> <code>str</code> <code>\"npc_dota_hero_axe\"</code> <code>float</code> <code>float</code> <code>123.456</code> <code>long</code> <code>int</code> <code>1234567890</code> <code>short</code> <code>int</code> <code>12345</code> <code>byte</code> <code>int</code> <code>255</code> <code>bool</code> <code>bool</code> <code>True</code> <code>uint64</code> <code>int</code> <code>76561198012345678</code>"},{"location":"reference/game-events/#discovering-events","title":"Discovering Events","text":"<p>Get all event types available in a replay:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_game_events(\"match.dem\", capture_types=True, max_events=0)\n\nprint(f\"Total event types: {len(result.event_types)}\")\nfor event_type in sorted(result.event_types):\n    print(f\"  {event_type}\")\n</code></pre>"},{"location":"reference/game-events/#common-event-patterns","title":"Common Event Patterns","text":""},{"location":"reference/game-events/#kill-events","title":"Kill Events","text":"<pre><code># dota_player_kill fields\n{\n    \"victim_userid\": int,      # Victim player ID\n    \"killer1_userid\": int,     # Primary killer\n    \"killer2_userid\": int,     # Assist 1 (optional)\n    \"killer3_userid\": int,     # Assist 2 (optional)\n    \"killer4_userid\": int,     # Assist 3 (optional)\n    \"killer5_userid\": int,     # Assist 4 (optional)\n}\n</code></pre>"},{"location":"reference/game-events/#tower-kill-events","title":"Tower Kill Events","text":"<pre><code># dota_tower_kill fields\n{\n    \"killer_userid\": int,      # Killer player ID\n    \"teamnumber\": int,         # 2=Radiant, 3=Dire (tower team)\n    \"gold\": int,               # Gold awarded\n}\n</code></pre>"},{"location":"reference/game-events/#combatlog-events","title":"Combatlog Events","text":"<pre><code># dota_combatlog fields\n{\n    \"type\": int,               # Combat log type\n    \"sourcename\": str,         # Source unit\n    \"targetname\": str,         # Target unit\n    \"value\": int,              # Damage/heal amount\n}\n</code></pre>"},{"location":"reference/game-events/#all-364-event-types","title":"All 364 Event Types","text":"<p>Use <code>capture_types=True</code> to get the complete list for your specific replay. The actual events available depend on the game version and what occurred during the match.</p> <p>Common categories include:</p> <ul> <li><code>dota_player_*</code> - Player actions</li> <li><code>dota_npc_*</code> - NPC actions</li> <li><code>dota_item_*</code> - Item events</li> <li><code>dota_rune_*</code> - Rune events</li> <li><code>dota_tower_*</code> - Tower events</li> <li><code>dota_roshan_*</code> - Roshan events</li> <li><code>dota_game_*</code> - Game state events</li> <li><code>dota_tutorial_*</code> - Tutorial events</li> <li><code>dota_ability_*</code> - Ability events</li> <li><code>game_*</code> - Engine game events</li> </ul>"},{"location":"reference/modifiers/","title":"Modifiers Reference","text":"AI Summary <p>Reference for parsing buff and debuff modifiers from Dota 2 replays. Modifiers are effects applied to units including stuns, slows, auras, and ability effects. Each modifier has parent entity, caster, ability source, duration, stack count, and aura/debuff flags. Use <code>parse_modifiers()</code> to capture modifier events with optional filtering by modifier class.</p>"},{"location":"reference/modifiers/#modifier-entry-fields","title":"Modifier Entry Fields","text":"<p>Every <code>ModifierEntry</code> contains:</p> Field Type Description <code>tick</code> <code>int</code> Game tick when captured <code>net_tick</code> <code>int</code> Network tick <code>parent</code> <code>int</code> Entity handle of unit with modifier <code>caster</code> <code>int</code> Entity handle of unit that applied modifier <code>ability</code> <code>int</code> Ability handle that created modifier <code>modifier_class</code> <code>int</code> Modifier class ID <code>serial_num</code> <code>int</code> Serial number for tracking <code>index</code> <code>int</code> Modifier index on the unit <code>creation_time</code> <code>float</code> Game time when modifier was created <code>duration</code> <code>float</code> Duration in seconds (-1 = permanent) <code>stack_count</code> <code>int</code> Number of stacks <code>is_aura</code> <code>bool</code> Whether this is an aura effect <code>is_debuff</code> <code>bool</code> Whether this is a debuff"},{"location":"reference/modifiers/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    buff_type = \"debuff\" if mod.is_debuff else \"buff\"\n    aura_str = \" (aura)\" if mod.is_aura else \"\"\n\n    print(f\"Entity {mod.parent}: {buff_type}{aura_str}, duration={duration_str}, stacks={mod.stack_count}\")\n</code></pre>"},{"location":"reference/modifiers/#filtering-by-class","title":"Filtering by Class","text":"<pre><code># Filter by specific modifier class IDs\nresult = parser.parse_modifiers(\"match.dem\", modifier_class_filter=[1, 5, 10], max_modifiers=100)\n</code></pre>"},{"location":"reference/modifiers/#duration-values","title":"Duration Values","text":"Duration Meaning <code>-1</code> Permanent modifier (e.g., passive abilities) <code>0</code> Instant effect <code>&gt; 0</code> Timed duration in seconds"},{"location":"reference/modifiers/#common-modifier-types","title":"Common Modifier Types","text":"<p>Modifiers represent various game effects:</p>"},{"location":"reference/modifiers/#crowd-control","title":"Crowd Control","text":"<ul> <li>Stuns</li> <li>Silences</li> <li>Hexes</li> <li>Roots</li> <li>Disarms</li> </ul>"},{"location":"reference/modifiers/#buffs","title":"Buffs","text":"<ul> <li>Damage amplification</li> <li>Attack speed bonuses</li> <li>Move speed bonuses</li> <li>Armor bonuses</li> </ul>"},{"location":"reference/modifiers/#debuffs","title":"Debuffs","text":"<ul> <li>Damage reduction</li> <li>Slows</li> <li>Break effects</li> <li>Mutes</li> </ul>"},{"location":"reference/modifiers/#auras","title":"Auras","text":"<ul> <li>Team auras (from items like Vladmir's Offering)</li> <li>Hero auras (from abilities like Drow Ranger's Precision Aura)</li> <li>Building auras</li> </ul>"},{"location":"reference/modifiers/#entity-handles","title":"Entity Handles","text":"<p>The <code>parent</code>, <code>caster</code>, and <code>ability</code> fields are entity handles. To resolve these to actual entities, use <code>query_entities()</code>:</p> <pre><code># Get modifier data\nmods = parser.parse_modifiers(\"match.dem\", max_modifiers=50)\n\n# Get entity data at same tick\nentities = parser.query_entities(\"match.dem\", tick=mods.modifiers[0].tick)\n\n# Match entity handles to entity data\nfor mod in mods.modifiers:\n    parent_entity = next(\n        (e for e in entities.entities if e.index == mod.parent),\n        None\n    )\n    if parent_entity:\n        print(f\"Modifier on {parent_entity.class_name}\")\n</code></pre>"},{"location":"reference/modifiers/#stack-count","title":"Stack Count","text":"<p><code>stack_count</code> indicates:</p> Value Meaning <code>0</code> No stacking / single application <code>1+</code> Current number of stacks <p>Some abilities that use stacking: - Flesh Heap (Pudge) - Counter Helix (Axe) proc counter - Essence Shift (Slark) stacks - Silencer's Intelligence Steal</p>"},{"location":"reference/string-tables/","title":"String Tables Reference","text":"AI Summary <p>Reference for string tables in Dota 2 replays. String tables store key-value mappings for names, abilities, items, models, and other game data. Use <code>get_string_tables()</code> to retrieve all tables or filter by name. Common tables include <code>userinfo</code> (player info), <code>ActiveModifiers</code> (buff names), <code>CombatLogNames</code> (unit names), and <code>EntityNames</code>.</p>"},{"location":"reference/string-tables/#string-table-structure","title":"String Table Structure","text":"<p>Every <code>StringTableData</code> entry contains:</p> Field Type Description <code>table_name</code> <code>str</code> Name of the table <code>index</code> <code>int</code> Entry index in table <code>key</code> <code>str</code> Entry key <code>value</code> <code>Optional[str]</code> Entry value (may be binary/base64)"},{"location":"reference/string-tables/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.get_string_tables(\"match.dem\")\n\nprint(f\"Tables found: {result.table_names}\")\nprint(f\"Total entries: {result.total_entries}\")\n\nfor table_name, entries in result.tables.items():\n    print(f\"\\n{table_name}: {len(entries)} entries\")\n    for entry in entries[:5]:  # First 5 entries\n        print(f\"  [{entry.index}] {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#common-tables","title":"Common Tables","text":""},{"location":"reference/string-tables/#userinfo","title":"userinfo","text":"<p>Player information including Steam IDs and names.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\nfor entry in result.tables.get(\"userinfo\", []):\n    print(f\"Player {entry.index}: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#combatlognames","title":"CombatLogNames","text":"<p>Names used in combat log entries (heroes, abilities, items).</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"CombatLogNames\")\n\nfor entry in result.tables.get(\"CombatLogNames\", []):\n    print(f\"[{entry.index}] {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#activemodifiers","title":"ActiveModifiers","text":"<p>Active modifier/buff names in the game.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"ActiveModifiers\")\n\nfor entry in result.tables.get(\"ActiveModifiers\", []):\n    print(f\"Modifier: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#entitynames","title":"EntityNames","text":"<p>Entity names used in the replay.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"EntityNames\")\n\nfor entry in result.tables.get(\"EntityNames\", []):\n    print(f\"Entity: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#all-table-names","title":"All Table Names","text":"<p>Common string tables found in Dota 2 replays:</p> Table Name Description <code>userinfo</code> Player information <code>server_query_info</code> Server query data <code>instancebaseline</code> Entity baselines <code>lightstyles</code> Light styles <code>CombatLogNames</code> Names for combat log <code>ActiveModifiers</code> Active modifier names <code>EntityNames</code> Entity name mappings <code>soundprecache</code> Sound precache <code>decalprecache</code> Decal precache <code>genericprecache</code> Generic precache"},{"location":"reference/string-tables/#filtering","title":"Filtering","text":"<pre><code># Get specific table\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\n# Get multiple tables (run multiple calls)\ntables_needed = [\"userinfo\", \"CombatLogNames\", \"EntityNames\"]\nall_data = {}\n\nfor table in tables_needed:\n    result = parser.get_string_tables(\"match.dem\", table_filter=table)\n    all_data[table] = result.tables.get(table, [])\n</code></pre>"},{"location":"reference/string-tables/#binary-values","title":"Binary Values","text":"<p>Some string table values contain binary data encoded as base64. These typically appear in:</p> <ul> <li><code>instancebaseline</code> - Entity baseline data</li> <li>Some precache tables</li> </ul> <pre><code>import base64\n\nfor entry in result.tables.get(\"somtable\", []):\n    if entry.value:\n        try:\n            decoded = base64.b64decode(entry.value)\n            # Process binary data\n        except:\n            # Plain string value\n            pass\n</code></pre>"},{"location":"reference/string-tables/#use-cases","title":"Use Cases","text":""},{"location":"reference/string-tables/#player-name-resolution","title":"Player Name Resolution","text":"<pre><code># Get player names\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\nplayer_names = {}\nfor entry in result.tables.get(\"userinfo\", []):\n    player_names[entry.index] = entry.key\n\n# Use with other parsed data\nfor entity in entities:\n    player_id = entity.properties.get(\"m_iPlayerID\")\n    if player_id in player_names:\n        print(f\"Hero owned by {player_names[player_id]}\")\n</code></pre>"},{"location":"reference/string-tables/#combat-log-name-resolution","title":"Combat Log Name Resolution","text":"<pre><code># Get name mappings\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"CombatLogNames\")\n\nname_lookup = {entry.index: entry.key for entry in result.tables.get(\"CombatLogNames\", [])}\n\n# Resolve combat log names\nfor log_entry in combat_log:\n    attacker = name_lookup.get(log_entry.attacker_id, \"Unknown\")\n    target = name_lookup.get(log_entry.target_id, \"Unknown\")\n</code></pre>"},{"location":"reference/string-tables/#result-metadata","title":"Result Metadata","text":"<p><code>StringTablesResult</code> includes:</p> Field Type Description <code>tables</code> <code>Dict[str, List[StringTableData]]</code> Table name -&gt; entries <code>table_names</code> <code>List[str]</code> List of all table names <code>total_entries</code> <code>int</code> Total entries across all tables <code>success</code> <code>bool</code> Parse success flag <code>error</code> <code>Optional[str]</code> Error message if failed"}]}