{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Python Manta","text":"<p>Python bindings for the dotabuff/manta Dota 2 replay parser</p> AI Summary <pre><code>Python Manta lets you parse Dota 2 replay files (.dem) in Python. Install with `pip install python-manta`. The library wraps the Go-based manta parser and provides:\n</code></pre> <ul> <li>Single-pass parsing for header, game info, and messages</li> <li>272 message callbacks for any replay data</li> <li>Game events (364 types), combat log, modifiers, entity queries</li> <li>Pydantic models for type-safe data access</li> </ul> <p>Quick start: <code>from python_manta import Parser; parser = Parser(\"match.dem\"); result = parser.parse(header=True)</code></p>"},{"location":"#what-is-python-manta","title":"What is Python Manta?","text":"<p>Python Manta provides Python access to the Manta Go library for parsing Dota 2 replay files. All parsing is done by Manta - this library provides:</p> <ol> <li>CGO bindings - Wraps the Go parser as a shared library</li> <li>Pythonic API - Clean, intuitive interface via <code>Parser</code></li> <li>Type safety - Pydantic models for all parsed data</li> <li>Comprehensive access - All 272 Manta callbacks + specialized APIs</li> </ol>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install python-manta\n</code></pre> <p>Pre-built wheels available for Linux, macOS (Intel + Apple Silicon), and Windows.</p>"},{"location":"#version-pinning","title":"Version Pinning","text":"<p>Always use the latest release for your target Manta version:</p> <pre><code># Latest release for Manta 1.4.5.x (recommended)\npip install \"python-manta&gt;=1.4.5,&lt;1.4.6\"\n\n# Or use compatible release operator\npip install \"python-manta~=1.4.5\"\n</code></pre> <p>See Getting Started for version format details.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from python_manta import Parser\n\n# Create parser for a specific demo file\nparser = Parser(\"match.dem\")\n\n# Parse header and game info in a single pass\nresult = parser.parse(header=True, game_info=True)\n\n# Access header data\nprint(f\"Map: {result.header.map_name}, Build: {result.header.build_num}\")\n\n# Access draft picks and bans\nfor pb in result.game_info.picks_bans:\n    action = \"PICK\" if pb.is_pick else \"BAN\"\n    print(f\"{action}: Hero {pb.hero_id}\")\n\n# Parse messages separately\nresult = parser.parse(messages={\"filter\": \"CDOTAUserMsg_ChatMessage\", \"max_messages\": 100})\nfor msg in result.messages.messages:\n    print(f\"[{msg.tick}] {msg.data}\")\n</code></pre>"},{"location":"#features-overview","title":"Features Overview","text":"Feature Collector Description Header <code>header=True</code> Match metadata (map, build, server) Game Info <code>game_info=True</code> Draft, players, teams, league Messages <code>messages={...}</code> Any of 272 message types"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>API Reference - Complete API documentation</li> <li>Examples - Real-world code examples</li> <li>Reference - Callbacks, game events, combat log</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI Package</li> <li>Original Manta (Go)</li> </ul>"},{"location":"examples/","title":"Examples","text":"AI Summary <p>Complete working examples for common Dota 2 replay analysis tasks. All examples use TI 2025 Grand Finals Game 5 (XG vs Falcons, Match ID: 8461956309) as the reference replay. Includes: match summary generator (header + draft + final stats), kill timeline builder, item build tracker (via combat log type 11), item usage tracker (combat log type 6), Lotus Orb detection (ability triggers type 13), neutral item tracker (pickups via FoundNeutralItem, usage via combat log, buffs via modifiers), ward placement analyzer, damage report generator, rune tracking, and defensive item analysis (Outworld Staff vs Omnislash). Each example demonstrates combining multiple API methods for real analysis workflows.</p>"},{"location":"examples/#example-match-ti-2025-grand-finals-game-5","title":"Example Match: TI 2025 Grand Finals Game 5","text":"<p>All examples in this documentation use The International 2025 Grand Finals Game 5 as the reference replay:</p> Property Value Match ID 8461956309 Event The International 2025 Grand Finals Teams Xtreme Gaming (XG) vs Team Falcons (FLCN) Winner Falcons (Dire) Duration 1:17:54 (4674 seconds) Server Valve TI14 Server (Hamburg) <p>XG (Radiant): - Ame: Juggernaut - Xm: Shadow Fiend - Xxs: Earthshaker - XinQ: Shadow Demon - xNova: Pugna</p> <p>Falcons (Dire): - Sneyking: Naga Siren - skiter: Medusa - Malr1ne: Pangolier - AMMAR_THE_F: Magnus - Cr1t-: Disruptor</p>"},{"location":"examples/#match-summary","title":"Match Summary","text":"<p>Extract a complete match summary with draft, players, and final scores.</p> <pre><code>from python_manta import MantaParser, Hero\n\ndef generate_match_summary(demo_path: str):\n    parser = MantaParser()\n\n    # Get header\n    header = parser.parse_header(demo_path)\n    print(f\"Match Summary\")\n    print(f\"{'='*50}\")\n    print(f\"Map: {header.map_name}\")\n    print(f\"Build: {header.build_num}\")\n    print(f\"Server: {header.server_name}\")\n\n    # Get game info (draft)\n    game_info = parser.parse_game_info(demo_path)\n    print(f\"\\nDraft:\")\n    print(\"-\" * 30)\n\n    radiant_picks = []\n    dire_picks = []\n    for event in game_info.picks_bans:\n        if event.is_pick:\n            hero = Hero.from_id(event.hero_id)\n            hero_name = hero.display_name if hero else f\"Unknown({event.hero_id})\"\n            if event.team == 2:\n                radiant_picks.append(hero_name)\n            else:\n                dire_picks.append(hero_name)\n\n    print(f\"Radiant picks: {radiant_picks}\")\n    print(f\"Dire picks: {dire_picks}\")\n\n    # Get final hero stats\n    heroes = parser.query_entities(\n        demo_path,\n        class_filter=\"Hero\",\n        property_filter=[\n            \"m_iCurrentLevel\", \"m_iKills\", \"m_iDeaths\", \"m_iAssists\",\n            \"m_iTotalEarnedGold\", \"m_iLastHits\", \"m_iTeamNum\"\n        ],\n        max_entities=10\n    )\n\n    print(f\"\\nFinal Scoreboard:\")\n    print(\"-\" * 70)\n    print(f\"{'Hero':&lt;35} {'Lvl':&gt;4} {'K':&gt;3} {'D':&gt;3} {'A':&gt;3} {'LH':&gt;5} {'Gold':&gt;7}\")\n    print(\"-\" * 70)\n\n    radiant = []\n    dire = []\n    for hero in heroes.entities:\n        p = hero.properties\n        team = p.get(\"m_iTeamNum\", 0)\n        stats = (hero.class_name, p.get(\"m_iCurrentLevel\", 0), p.get(\"m_iKills\", 0),\n                 p.get(\"m_iDeaths\", 0), p.get(\"m_iAssists\", 0), p.get(\"m_iLastHits\", 0),\n                 p.get(\"m_iTotalEarnedGold\", 0))\n\n        if team == 2:\n            radiant.append(stats)\n        elif team == 3:\n            dire.append(stats)\n\n    print(\"RADIANT:\")\n    for name, lvl, k, d, a, lh, gold in radiant:\n        print(f\"  {name:&lt;33} {lvl:&gt;4} {k:&gt;3} {d:&gt;3} {a:&gt;3} {lh:&gt;5} {gold:&gt;7,}\")\n\n    print(\"\\nDIRE:\")\n    for name, lvl, k, d, a, lh, gold in dire:\n        print(f\"  {name:&lt;33} {lvl:&gt;4} {k:&gt;3} {d:&gt;3} {a:&gt;3} {lh:&gt;5} {gold:&gt;7,}\")\n\n# Usage\ngenerate_match_summary(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals Game 5): <pre><code>Match Summary\n==================================================\nMap: start\nBuild: 10512\nServer: Valve TI14 Server (srcds427-fra2.Hamburg.5)\n\nMatch ID: 8461956309\nDuration: 1:17:54\nWinner: Dire\n\nTeams:\n  Radiant: XG (ID: 8261500)\n  Dire: FLCN (ID: 9247354)\n\nDraft:\n  Radiant picks: ['Earthshaker', 'Shadow Demon', 'Shadow Fiend', 'Pugna', 'Juggernaut']\n  Dire picks: ['Naga Siren', 'Pangolier', 'Disruptor', 'Medusa', 'Magnus']\n\nPlayers:\n  [Radiant] Ame: juggernaut\n  [Radiant] Xm: nevermore\n  [Radiant] Xxs: earthshaker\n  [Radiant] XinQ: shadow_demon\n  [Radiant] xNova: pugna\n  [Dire] Sneyking: naga_siren\n  [Dire] skiter: medusa\n  [Dire] Malr1ne: pangolier\n  [Dire] AMMAR_THE_F: magnataur\n  [Dire] Cr1t-: disruptor\n</code></pre></p>"},{"location":"examples/#kill-timeline","title":"Kill Timeline","text":"<p>Build a chronological kill feed with timestamps using combat log.</p> <pre><code>from python_manta import MantaParser, CombatLogType\n\ndef build_kill_timeline(demo_path: str):\n    parser = MantaParser()\n\n    # Use combat log DEATH type for kills\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.DEATH],\n        max_entries=5000\n    )\n\n    # Filter for hero deaths only\n    hero_deaths = [e for e in result.entries if \"npc_dota_hero_\" in e.target_name]\n\n    print(\"Kill Timeline\")\n    print(\"=\" * 60)\n\n    for entry in hero_deaths:\n        mins = int(entry.game_time // 60)\n        secs = int(entry.game_time % 60)\n        victim = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n        killer = entry.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        print(f\"[{mins:02d}:{secs:02d}] {killer} killed {victim}\")\n\n    print(f\"\\nTotal hero deaths: {len(hero_deaths)}\")\n\n# Usage\nbuild_kill_timeline(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Kill Timeline\n============================================================\n[04:48] disruptor killed earthshaker\n[05:28] naga_siren killed shadow_demon\n[06:06] nevermore killed pangolier\n[06:13] shadow_demon killed disruptor\n[09:11] juggernaut killed magnataur\n[11:08] magnataur killed juggernaut\n[11:12] pangolier killed shadow_demon\n[13:39] juggernaut killed magnataur\n[14:49] pangolier killed pugna\n[15:27] juggernaut killed disruptor\n[18:20] disruptor killed pugna\n[18:35] pangolier killed earthshaker\n[27:04] magnataur killed pugna\n[27:19] medusa killed shadow_demon\n[32:30] shadow_demon killed pangolier\n[34:06] nevermore killed pangolier\n[34:17] medusa killed shadow_demon\n[35:53] medusa killed pugna\n[38:03] disruptor killed pugna\n[38:27] nevermore killed magnataur\n[53:21] pangolier killed pugna\n[64:13] pangolier killed juggernaut\n[76:25] pangolier killed juggernaut\n[76:38] medusa killed earthshaker\n[76:51] medusa killed nevermore\n\nTotal hero deaths: 25\n</code></pre></p>"},{"location":"examples/#item-build-tracker","title":"Item Build Tracker","text":"<p>Track item purchases for each player throughout the match using combat log.</p> <pre><code>from python_manta import MantaParser, CombatLogType\nfrom collections import defaultdict\n\ndef track_item_builds(demo_path: str):\n    parser = MantaParser()\n\n    # Item purchases are in combat log PURCHASE type\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.PURCHASE],\n        max_entries=2000\n    )\n\n    # Group by hero\n    hero_items = defaultdict(list)\n\n    for entry in result.entries:\n        hero = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.value_name.replace(\"item_\", \"\")\n\n        # Calculate game time\n        mins = int(abs(entry.game_time) // 60)\n        secs = int(abs(entry.game_time)) % 60\n        sign = \"-\" if entry.game_time &lt; 0 else \"\"\n\n        hero_items[hero].append({\n            \"time\": f\"{sign}{mins:02d}:{secs:02d}\",\n            \"item\": item,\n            \"game_time\": entry.game_time\n        })\n\n    print(\"Item Build Order by Hero\")\n    print(\"=\" * 60)\n\n    for hero in sorted(hero_items.keys()):\n        items = hero_items[hero]\n        print(f\"\\n{hero}: ({len(items)} items)\")\n        print(\"-\" * 50)\n\n        for i, item in enumerate(items, 1):\n            print(f\"  {i:&gt;3}. [{item['time']}] {item['item']}\")\n\n# Usage\ntrack_item_builds(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals - Ame's Juggernaut build): <pre><code>Item Build Order by Hero\n============================================================\n\njuggernaut: (54 items)\n--------------------------------------------------\n    1. [01:04] recipe_wraith_band\n    2. [01:54] wraith_band\n    3. [02:06] boots_of_elves\n    4. [03:35] gloves\n    5. [04:53] boots\n    6. [05:32] power_treads          # Power Treads at 5:32\n    7. [08:05] cornucopia\n    8. [09:36] broadsword\n    9. [12:01] broadsword\n   10. [13:17] recipe_bfury\n   11. [13:44] bfury                 # Battle Fury at 13:44\n   12. [14:18] blade_of_alacrity\n   13. [15:14] boots_of_elves\n   14. [15:31] recipe_yasha\n   15. [16:11] yasha\n   16. [16:56] diadem\n   17. [19:20] recipe_manta\n   18. [19:44] manta                 # Manta Style at 19:44\n   19. [22:56] eagle\n   20. [24:19] claymore\n   21. [25:56] talisman_of_evasion\n   22. [26:40] butterfly             # Butterfly at 26:40\n   ...\n</code></pre></p>"},{"location":"examples/#ward-placement-analyzer","title":"Ward Placement Analyzer","text":"<p>Analyze ward placement patterns from pings and events.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef analyze_wards(demo_path: str):\n    parser = MantaParser()\n\n    # Get ward-related entities at end of game\n    wards = parser.query_entities(\n        demo_path,\n        class_filter=\"Ward\",\n        property_filter=[\"m_vecOrigin\", \"m_iTeamNum\", \"m_iHealth\"],\n        max_entities=100\n    )\n\n    print(\"Ward Analysis\")\n    print(\"=\" * 50)\n\n    radiant_wards = []\n    dire_wards = []\n\n    for ward in wards.entities:\n        pos = ward.properties.get(\"m_vecOrigin\", [0, 0, 0])\n        team = ward.properties.get(\"m_iTeamNum\", 0)\n        alive = ward.properties.get(\"m_iHealth\", 0) &gt; 0\n\n        ward_info = {\n            \"class\": ward.class_name,\n            \"position\": (pos[0], pos[1]),\n            \"alive\": alive\n        }\n\n        if team == 2:\n            radiant_wards.append(ward_info)\n        elif team == 3:\n            dire_wards.append(ward_info)\n\n    print(f\"\\nRadiant wards (end of game): {len(radiant_wards)}\")\n    for w in radiant_wards:\n        status = \"ALIVE\" if w[\"alive\"] else \"dead\"\n        print(f\"  {w['class']}: ({w['position'][0]:.0f}, {w['position'][1]:.0f}) [{status}]\")\n\n    print(f\"\\nDire wards (end of game): {len(dire_wards)}\")\n    for w in dire_wards:\n        status = \"ALIVE\" if w[\"alive\"] else \"dead\"\n        print(f\"  {w['class']}: ({w['position'][0]:.0f}, {w['position'][1]:.0f}) [{status}]\")\n\n# Usage\nanalyze_wards(\"match.dem\")\n</code></pre>"},{"location":"examples/#damage-report","title":"Damage Report","text":"<p>Generate a damage breakdown by hero and ability.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef generate_damage_report(demo_path: str):\n    parser = MantaParser()\n\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[0],  # Damage only\n        heroes_only=True,\n        max_entries=10000\n    )\n\n    # Aggregate damage by attacker\n    damage_dealt = defaultdict(int)\n    damage_taken = defaultdict(int)\n    ability_damage = defaultdict(lambda: defaultdict(int))\n\n    for entry in result.entries:\n        if entry.is_attacker_hero:\n            damage_dealt[entry.attacker_name] += entry.value\n\n            if entry.inflictor_name:\n                ability_damage[entry.attacker_name][entry.inflictor_name] += entry.value\n\n        if entry.is_target_hero:\n            damage_taken[entry.target_name] += entry.value\n\n    print(\"Damage Report\")\n    print(\"=\" * 60)\n\n    print(\"\\nTotal Damage Dealt:\")\n    print(\"-\" * 40)\n    for hero, dmg in sorted(damage_dealt.items(), key=lambda x: -x[1]):\n        print(f\"  {hero:&lt;35}: {dmg:&gt;10,}\")\n\n    print(\"\\nTotal Damage Taken:\")\n    print(\"-\" * 40)\n    for hero, dmg in sorted(damage_taken.items(), key=lambda x: -x[1]):\n        print(f\"  {hero:&lt;35}: {dmg:&gt;10,}\")\n\n    print(\"\\nTop Damage Sources by Hero:\")\n    print(\"-\" * 60)\n    for hero in sorted(ability_damage.keys()):\n        abilities = ability_damage[hero]\n        top_abilities = sorted(abilities.items(), key=lambda x: -x[1])[:5]\n\n        print(f\"\\n{hero}:\")\n        for ability, dmg in top_abilities:\n            print(f\"    {ability:&lt;30}: {dmg:&gt;8,}\")\n\n# Usage\ngenerate_damage_report(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Damage Report\n============================================================\n\nTotal Damage Dealt:\n----------------------------------------\n  medusa                           :    923,091\n  juggernaut                       :    878,418\n  nevermore                        :    629,762\n  earthshaker                      :    507,264\n  pangolier                        :    421,043\n  magnataur                        :    273,972\n  naga_siren                       :    265,125\n  pugna                            :    150,655\n  shadow_demon                     :     60,697\n  disruptor                        :     45,610\n</code></pre></p> <p>Note: skiter's Medusa dealt the most damage overall (923k), while Ame's Juggernaut (878k) was the second highest. This includes all damage to heroes, not just hero-vs-hero.</p>"},{"location":"examples/#team-fight-detector","title":"Team Fight Detector","text":"<p>Detect team fights by analyzing death clusters.</p> <pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\ndef detect_team_fights(demo_path: str, tick_window: int = 600):\n    parser = MantaParser()\n\n    # Get deaths from combat log\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[4],  # Deaths\n        heroes_only=True,\n        max_entries=500\n    )\n\n    if not result.entries:\n        print(\"No hero deaths found\")\n        return\n\n    # Group deaths by time window\n    fights = []\n    current_fight = []\n\n    for entry in sorted(result.entries, key=lambda e: e.tick):\n        if not current_fight:\n            current_fight.append(entry)\n        elif entry.tick - current_fight[-1].tick &lt;= tick_window:\n            current_fight.append(entry)\n        else:\n            if len(current_fight) &gt;= 3:  # At least 3 deaths = team fight\n                fights.append(current_fight)\n            current_fight = [entry]\n\n    # Don't forget last fight\n    if len(current_fight) &gt;= 3:\n        fights.append(current_fight)\n\n    print(\"Team Fight Detection\")\n    print(\"=\" * 60)\n    print(f\"Found {len(fights)} team fights (3+ deaths within {tick_window} ticks)\")\n\n    for i, fight in enumerate(fights, 1):\n        start_tick = fight[0].tick\n        end_tick = fight[-1].tick\n        duration = end_tick - start_tick\n\n        radiant_deaths = sum(1 for e in fight if e.target_team == 2)\n        dire_deaths = sum(1 for e in fight if e.target_team == 3)\n\n        print(f\"\\nFight #{i}: Tick {start_tick} - {end_tick} ({duration} ticks)\")\n        print(f\"  Deaths: Radiant {radiant_deaths}, Dire {dire_deaths}\")\n        print(f\"  Outcome: {'Radiant' if dire_deaths &gt; radiant_deaths else 'Dire'} won\")\n\n        print(f\"  Deaths:\")\n        for entry in fight:\n            team = \"R\" if entry.target_team == 2 else \"D\"\n            print(f\"    [{team}] {entry.target_name} killed by {entry.attacker_name}\")\n\n# Usage\ndetect_team_fights(\"match.dem\")\n</code></pre>"},{"location":"examples/#chat-log-extractor","title":"Chat Log Extractor","text":"<p>Extract and format all chat messages.</p> <pre><code>from python_manta import MantaParser\n\ndef extract_chat_log(demo_path: str):\n    parser = MantaParser()\n\n    result = parser.parse_universal(\n        demo_path,\n        \"CDOTAUserMsg_ChatMessage\",\n        max_messages=1000\n    )\n\n    # Get string tables for player names (if available)\n    userinfo = parser.get_string_tables(\n        demo_path,\n        table_names=[\"userinfo\"],\n        max_entries=20\n    )\n\n    print(\"Chat Log\")\n    print(\"=\" * 60)\n\n    chat_types = {1: \"ALL\", 2: \"TEAM\", 3: \"SPEC\"}\n\n    for msg in result.messages:\n        player_id = msg.data.get(\"source_player_id\", \"?\")\n        text = msg.data.get(\"message_text\", \"\")\n        chat_type = msg.data.get(\"chat_type\", 0)\n\n        if not text:\n            continue\n\n        type_str = chat_types.get(chat_type, \"???\")\n        tick = msg.tick\n\n        print(f\"[{tick:&gt;7}] [{type_str:&gt;4}] Player {player_id}: {text}\")\n\n# Usage\nextract_chat_log(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Chat Log\n============================================================\n[  28528] Player 1: gl hf\n[  28534] Player 9: hf\n[  28590] Player 0: gl\n[  28624] Player 4: glhf\n[  29624] Player 5: the lights are too much\n[  29760] Player 7: its fine\n[  29784] Player 7: g\n[  29864] Player 4: g\n[  29898] Player 1: G\n[  65276] Player 5: teamspeak delay\n[  67360] Player 9: g\n[  67368] Player 6: g\n[  67464] Player 3: g\n[ 138941] Player 1: gg\n[ 138991] Player 0: gg\n[ 138997] Player 4: gg\n[ 139019] Player 8: gg\n\nTotal chat messages: 17\n</code></pre></p> <p>Note: The TI Grand Finals captured the pre-game \"gl hf\" exchanges, a technical pause for \"teamspeak delay\", and the final \"gg\" at match end.</p>"},{"location":"examples/#rune-tracking","title":"Rune Tracking","text":"<p>Track rune pickups throughout the match using combat log modifiers.</p> <pre><code>from python_manta import MantaParser, RuneType\nfrom collections import defaultdict\n\ndef track_runes(demo_path: str):\n    parser = MantaParser()\n\n    # Rune pickups are tracked via combat log modifiers\n    # When a hero picks up a rune, they receive a modifier_rune_* buff\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[2],  # MODIFIER_ADD only\n        heroes_only=True,\n        max_entries=50000\n    )\n\n    # Filter for rune modifiers using the RuneType enum\n    rune_pickups = [\n        e for e in result.entries\n        if RuneType.is_rune_modifier(e.inflictor_name)\n    ]\n\n    print(\"Rune Tracking\")\n    print(\"=\" * 50)\n    print(f\"\\nTotal Rune Pickups: {len(rune_pickups)}\")\n    print(\"-\" * 40)\n\n    # Group by hero\n    hero_runes = defaultdict(list)\n    for pickup in rune_pickups:\n        hero = pickup.target_name.replace(\"npc_dota_hero_\", \"\")\n        rune = RuneType.from_modifier(pickup.inflictor_name)\n        rune_name = rune.display_name if rune else pickup.inflictor_name\n        hero_runes[hero].append({\n            \"time\": pickup.game_time,\n            \"rune\": rune_name\n        })\n\n    # Print timeline\n    print(\"\\nRune Pickup Timeline:\")\n    print(\"-\" * 60)\n    for pickup in rune_pickups:\n        hero = pickup.target_name.replace(\"npc_dota_hero_\", \"\")\n        rune = RuneType.from_modifier(pickup.inflictor_name)\n        rune_name = rune.display_name if rune else pickup.inflictor_name\n        print(f\"[{pickup.game_time_str}] {hero:&lt;20} picked up {rune_name}\")\n\n    # Print summary by hero\n    print(\"\\nRunes by Hero:\")\n    print(\"-\" * 40)\n    for hero, runes in sorted(hero_runes.items()):\n        rune_summary = \", \".join(r[\"rune\"] for r in runes)\n        print(f\"  {hero}: {len(runes)} runes ({rune_summary})\")\n\n# Usage\ntrack_runes(\"match.dem\")\n</code></pre> <p>Expected Output (TI 2025 Grand Finals): <pre><code>Rune Tracking\n==================================================\n\nTotal Rune Pickups: 19\n----------------------------------------\n\nRune Pickup Timeline:\n------------------------------------------------------------\n[23:30] naga_siren           picked up Arcane\n[26:05] pangolier            picked up Invisibility\n[28:44] pangolier            picked up Haste\n[30:45] pangolier            picked up Double Damage\n[35:56] pangolier            picked up Regeneration\n[37:17] naga_siren           picked up Double Damage\n[40:29] pangolier            picked up Invisibility\n[41:24] pugna                picked up Shield\n[44:55] pangolier            picked up Regeneration\n[45:57] naga_siren           picked up Haste\n[49:02] pangolier            picked up Arcane\n[51:25] medusa               picked up Arcane\n[53:40] medusa               picked up Double Damage\n[58:01] pangolier            picked up Shield\n[59:24] magnataur            picked up Invisibility\n[63:44] pangolier            picked up Regeneration\n[67:22] magnataur            picked up Shield\n[71:20] magnataur            picked up Invisibility\n[73:34] medusa               picked up Arcane\n\nRunes by Hero:\n----------------------------------------\n  magnataur: 3 runes (Invisibility, Shield, Invisibility)\n  medusa: 3 runes (Arcane, Double Damage, Arcane)\n  naga_siren: 3 runes (Arcane, Double Damage, Haste)\n  pangolier: 9 runes (Invisibility, Haste, Double Damage, Regeneration, Invisibility, Regeneration, Arcane, Shield, Regeneration)\n  pugna: 1 runes (Shield)\n</code></pre></p>"},{"location":"examples/#item-usage-tracker","title":"Item Usage Tracker","text":"<p>Track when heroes use active items (smoke, wards, BKB, etc.).</p> <pre><code>from python_manta import MantaParser, CombatLogType\nfrom collections import defaultdict\n\ndef track_item_usage(demo_path: str):\n    parser = MantaParser()\n\n    # Item usage is in combat log ITEM type\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ITEM],\n        heroes_only=True,\n        max_entries=2000\n    )\n\n    print(\"Item Usage Tracking\")\n    print(\"=\" * 60)\n    print(f\"Total item activations: {result.total_entries}\\n\")\n\n    # Group by hero\n    hero_usage = defaultdict(lambda: defaultdict(int))\n\n    for entry in result.entries:\n        hero = entry.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.inflictor_name.replace(\"item_\", \"\")\n        hero_usage[hero][item] += 1\n\n    # Print usage by hero\n    for hero in sorted(hero_usage.keys()):\n        items = hero_usage[hero]\n        print(f\"\\n{hero}:\")\n        for item, count in sorted(items.items(), key=lambda x: -x[1]):\n            print(f\"  {item}: {count}x\")\n\n# Usage\ntrack_item_usage(\"match.dem\")\n</code></pre>"},{"location":"examples/#lotus-orb-detection","title":"Lotus Orb Detection","text":"<p>Detect Lotus Orb spell reflections using ability triggers.</p> <pre><code>from python_manta import MantaParser, CombatLogType\n\ndef detect_lotus_orb(demo_path: str):\n    parser = MantaParser()\n\n    # Ability triggers include Lotus Orb reflections\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ABILITY_TRIGGER],\n        max_entries=500\n    )\n\n    print(\"Lotus Orb / Ability Trigger Detection\")\n    print(\"=\" * 60)\n\n    lotus_events = []\n    other_triggers = []\n\n    for entry in result.entries:\n        hero = entry.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        target = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n        item = entry.inflictor_name\n\n        # Calculate time\n        mins = int(entry.game_time // 60)\n        secs = int(entry.game_time % 60)\n\n        event = {\n            \"time\": f\"{mins:02d}:{secs:02d}\",\n            \"hero\": hero,\n            \"target\": target,\n            \"item\": item\n        }\n\n        if \"lotus_orb\" in item:\n            lotus_events.append(event)\n        else:\n            other_triggers.append(event)\n\n    if lotus_events:\n        print(f\"\\nLotus Orb Reflections ({len(lotus_events)} total):\")\n        print(\"-\" * 50)\n        for e in lotus_events:\n            print(f\"[{e['time']}] {e['hero']} reflected spell to {e['target']}\")\n\n    if other_triggers:\n        print(f\"\\nOther Ability Triggers ({len(other_triggers)} total):\")\n        print(\"-\" * 50)\n        for e in other_triggers[:10]:  # Show first 10\n            print(f\"[{e['time']}] {e['hero']} -&gt; {e['target']} ({e['item']})\")\n\n# Usage\ndetect_lotus_orb(\"match.dem\")\n</code></pre>"},{"location":"examples/#neutral-item-tracker","title":"Neutral Item Tracker","text":"<p>Track neutral item drops, pickups, and usage throughout the game.</p> <pre><code>from python_manta import MantaParser, NeutralItem, NeutralItemTier, CombatLogType\n\ndef track_neutral_items(demo_path: str):\n    parser = MantaParser()\n\n    print(\"Neutral Item Analysis\")\n    print(\"=\" * 60)\n\n    # 1. Track neutral item pickups via CDOTAUserMsg_FoundNeutralItem\n    found_result = parser.parse_universal(demo_path, \"FoundNeutralItem\", max_messages=100)\n\n    print(f\"\\nNeutral Items Found: {len(found_result.messages)}\")\n    print(\"-\" * 40)\n\n    items_by_tier = {t: [] for t in NeutralItemTier}\n\n    for msg in found_result.messages:\n        player_id = msg.data.get('player_id')\n        item_tier_value = msg.data.get('item_tier', 0)\n        tier = NeutralItemTier.from_value(item_tier_value)\n\n        if tier:\n            mins = int(msg.tick / 30 / 60)  # Approximate game time\n            items_by_tier[tier].append({\n                \"player\": player_id,\n                \"time_approx\": f\"~{mins}m\",\n                \"tick\": msg.tick\n            })\n\n    for tier in NeutralItemTier:\n        items = items_by_tier[tier]\n        if items:\n            print(f\"\\n{tier.display_name} (unlocks at {tier.unlock_time_minutes}min): {len(items)} drops\")\n            for item in items[:5]:  # Show first 5\n                print(f\"  Player {item['player']} at {item['time_approx']}\")\n\n    # 2. Track neutral item USAGE via combat log\n    result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.ITEM],\n        max_entries=1000\n    )\n\n    print(f\"\\n\\nNeutral Item Active Usage\")\n    print(\"-\" * 40)\n\n    usage_count = {}\n    for entry in result.entries:\n        if NeutralItem.is_neutral_item(entry.inflictor_name):\n            item = NeutralItem.from_item_name(entry.inflictor_name)\n            if item:\n                key = (entry.attacker_name, item.display_name)\n                usage_count[key] = usage_count.get(key, 0) + 1\n\n    # Sort by usage count\n    sorted_usage = sorted(usage_count.items(), key=lambda x: x[1], reverse=True)\n    for (hero, item_name), count in sorted_usage[:15]:\n        hero_short = hero.replace(\"npc_dota_hero_\", \"\")\n        print(f\"  {hero_short}: {item_name} x{count}\")\n\n    # 3. Track neutral item modifiers/buffs\n    mod_result = parser.parse_combat_log(\n        demo_path,\n        types=[CombatLogType.MODIFIER_ADD],\n        max_entries=2000\n    )\n\n    print(f\"\\n\\nNeutral Item Buffs Applied\")\n    print(\"-\" * 40)\n\n    buff_count = {}\n    for entry in mod_result.entries:\n        inflictor = entry.inflictor_name\n        # Check if it's a neutral item modifier\n        if inflictor and inflictor.startswith(\"modifier_item_\"):\n            # Extract item name from modifier\n            item_name = inflictor.replace(\"modifier_\", \"\")\n            if NeutralItem.is_neutral_item(item_name):\n                buff_count[inflictor] = buff_count.get(inflictor, 0) + 1\n\n    for mod, count in sorted(buff_count.items(), key=lambda x: x[1], reverse=True)[:10]:\n        print(f\"  {mod}: {count} applications\")\n\n# Usage\ntrack_neutral_items(\"match.dem\")\n</code></pre>"},{"location":"examples/#defensive-item-vs-ultimate-analysis","title":"Defensive Item vs Ultimate Analysis","text":"<p>Analyze how defensive items counter ultimates. This example shows how skiter's Outworld Staff nullified Ame's Omnislash in a crucial teamfight at 64:08.</p> <pre><code>from python_manta import Parser, CombatLogType, NeutralItem\n\ndef analyze_defensive_counter(demo_path: str, start_time: float, end_time: float):\n    \"\"\"Analyze a specific window for ability vs defensive item interactions.\"\"\"\n    parser = Parser(demo_path)\n\n    print(\"Defensive Item Analysis\")\n    print(\"=\" * 60)\n    print(f\"Window: {start_time/60:.0f}:{start_time%60:02.0f} - {end_time/60:.0f}:{end_time%60:02.0f}\")\n\n    # Get abilities cast in window\n    abilities = parser.parse(combat_log={\"types\": [CombatLogType.ABILITY], \"max_entries\": 100000})\n    items = parser.parse(combat_log={\"types\": [CombatLogType.ITEM], \"max_entries\": 100000})\n    damage = parser.parse(combat_log={\"types\": [CombatLogType.DAMAGE], \"max_entries\": 500000})\n    mods = parser.parse(combat_log={\"types\": [CombatLogType.MODIFIER_ADD], \"max_entries\": 100000})\n\n    window_abilities = [e for e in abilities.combat_log.entries if start_time &lt;= e.game_time &lt;= end_time]\n    window_items = [e for e in items.combat_log.entries if start_time &lt;= e.game_time &lt;= end_time]\n    window_damage = [e for e in damage.combat_log.entries if start_time &lt;= e.game_time &lt;= end_time]\n    window_mods = [e for e in mods.combat_log.entries if start_time &lt;= e.game_time &lt;= end_time]\n\n    print(\"\\n--- Abilities Cast ---\")\n    for e in window_abilities:\n        caster = e.attacker_name.replace('npc_dota_hero_', '')\n        ability = e.inflictor_name\n        target = e.target_name.replace('npc_dota_hero_', '')\n        print(f\"  [{e.game_time_str}] {caster} -&gt; {ability} on {target}\")\n\n    print(\"\\n--- Items Used ---\")\n    for e in window_items:\n        user = e.attacker_name.replace('npc_dota_hero_', '')\n        item = e.inflictor_name\n        print(f\"  [{e.game_time_str}] {user} -&gt; {item}\")\n\n    print(\"\\n--- Key Modifiers ---\")\n    defensive_mods = [e for e in window_mods\n                      if 'ethereal' in e.inflictor_name.lower()\n                      or 'invulnerable' in e.inflictor_name.lower()\n                      or 'outworld' in e.inflictor_name.lower()\n                      or 'aeon' in e.inflictor_name.lower()]\n    for e in defensive_mods:\n        target = e.target_name.replace('npc_dota_hero_', '')\n        mod = e.inflictor_name\n        print(f\"  [{e.game_time_str}] {mod} on {target}\")\n\n    # Check for Omnislash damage specifically\n    omni_damage = [e for e in window_damage\n                   if 'omni' in e.inflictor_name.lower() or 'swift' in e.inflictor_name.lower()]\n    print(f\"\\n--- Omnislash Damage: {len(omni_damage)} hits ---\")\n    for e in omni_damage[:5]:\n        target = e.target_name.replace('npc_dota_hero_', '')\n        dmg = e.value\n        print(f\"  [{e.game_time_str}] Hit {target} for {dmg}\")\n\n# Usage - Analyze the 64:08 Omnislash vs Outworld Staff moment\n# At 64:08, Ame Omnislashes Medusa, but she uses Outworld Staff at 64:09\n# The ethereal form nullifies the Omnislash, leading to Juggernaut's death at 64:13\nanalyze_defensive_counter(\"match.dem\", start_time=3848, end_time=3855)\n</code></pre> <p>Expected Output (TI 2025 Grand Finals - 64:08 fight): <pre><code>Defensive Item Analysis\n============================================================\nWindow: 64:08 - 64:15\n\n--- Abilities Cast ---\n  [64:08] juggernaut -&gt; juggernaut_omni_slash on medusa\n  [64:10] juggernaut -&gt; juggernaut_blade_fury on dota_unknown\n  [64:10] shadow_demon -&gt; shadow_demon_demonic_cleanse on juggernaut\n  [64:11] pangolier -&gt; pangolier_gyroshell on dota_unknown\n\n--- Items Used ---\n  [64:09] medusa -&gt; item_outworld_staff\n\n--- Key Modifiers ---\n  [64:09] modifier_item_outworld_staff on medusa\n\n--- Omnislash Damage: 0 hits ---\n</code></pre></p> <p>Analysis: Ame's Omnislash targeted Medusa at 64:08, but skiter immediately used Outworld Staff at 64:09. The <code>modifier_item_outworld_staff</code> made Medusa ethereal (untargetable by physical attacks), causing Omnislash to deal zero damage and end prematurely. This forced Juggernaut into Blade Fury defensively, and he was killed at 64:13.</p> <p>This demonstrates how: 1. Ability casts are tracked via <code>CombatLogType.ABILITY</code> 2. Defensive items are tracked via <code>CombatLogType.ITEM</code> 3. Buff effects are tracked via <code>CombatLogType.MODIFIER_ADD</code> 4. Missing damage indicates the counter was successful</p>"},{"location":"examples/#complete-analysis-pipeline","title":"Complete Analysis Pipeline","text":"<p>Combine multiple analyses into a single comprehensive report.</p> <pre><code>from python_manta import MantaParser, CombatLogType\n\ndef full_analysis(demo_path: str):\n    parser = MantaParser()\n\n    print(\"=\" * 70)\n    print(\"COMPREHENSIVE MATCH ANALYSIS\")\n    print(\"=\" * 70)\n\n    # 1. Basic Info\n    header = parser.parse_header(demo_path)\n    info = parser.get_parser_info(demo_path)\n\n    print(f\"\\n[1] Match Information\")\n    print(f\"    Build: {header.build_num}\")\n    print(f\"    Duration: {info.tick} ticks\")\n    print(f\"    Entities: {info.entity_count}\")\n\n    # 2. Draft\n    game_info = parser.parse_game_info(demo_path)\n    picks = [e for e in game_info.picks_bans if e.is_pick]\n    bans = [e for e in game_info.picks_bans if not e.is_pick]\n\n    print(f\"\\n[2] Draft\")\n    print(f\"    Picks: {len(picks)}\")\n    print(f\"    Bans: {len(bans)}\")\n\n    # 3. Kill Summary\n    kills = parser.parse_game_events(demo_path, event_filter=\"dota_player_kill\", max_events=500)\n    print(f\"\\n[3] Kills\")\n    print(f\"    Total: {len(kills.events)}\")\n\n    # 4. Combat Log Stats\n    combat = parser.parse_combat_log(demo_path, heroes_only=True, max_entries=5000)\n    damage_entries = [e for e in combat.entries if e.type == 0]\n    death_entries = [e for e in combat.entries if e.type == 4]\n\n    print(f\"\\n[4] Combat Log\")\n    print(f\"    Damage events: {len(damage_entries)}\")\n    print(f\"    Death events: {len(death_entries)}\")\n\n    # 5. Chat Activity\n    chat = parser.parse_universal(demo_path, \"CDOTAUserMsg_ChatMessage\", max_messages=500)\n    print(f\"\\n[5] Communication\")\n    print(f\"    Chat messages: {chat.count}\")\n\n    # 6. Item Economy (via combat log)\n    items = parser.parse_combat_log(demo_path, types=[CombatLogType.PURCHASE], max_entries=2000)\n    print(f\"\\n[6] Economy\")\n    print(f\"    Item purchases: {items.total_entries}\")\n\n    print(\"\\n\" + \"=\" * 70)\n    print(\"Analysis complete\")\n\n# Usage\nfull_analysis(\"match.dem\")\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"AI Summary <pre><code>This page covers installation and basic usage of Python Manta. Install via `pip install python-manta` (no Go required). For development from source, either download pre-built libraries with `python scripts/download_library.py` or build with Go using `./build.sh`. The main entry point is `Parser(demo_path)` which provides methods for parsing headers, drafts, and any message type from .dem replay files.\n</code></pre>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#from-pypi-recommended","title":"From PyPI (Recommended)","text":"<pre><code>pip install python-manta\n</code></pre> <p>Pre-built wheels include the compiled library for:</p> <ul> <li>Linux x86_64</li> <li>macOS Intel (x86_64) and Apple Silicon (arm64)</li> <li>Windows AMD64</li> </ul> <p>No Go installation required when installing from PyPI.</p>"},{"location":"getting-started/#version-pinning","title":"Version Pinning","text":"<p>Python Manta versions follow the format <code>X.Y.Z.M-devN</code> where:</p> <ul> <li><code>X.Y.Z</code> - Python Manta major/minor/patch</li> <li><code>M</code> - Manta (Go) library version compatibility</li> <li><code>devN</code> - Development release number</li> </ul> <p>Always use the latest release for your target Manta version to get bug fixes and improvements:</p> <pre><code># Latest release for Manta 1.4.5.x (recommended)\npip install \"python-manta&gt;=1.4.5,&lt;1.4.6\"\n\n# Or use compatible release operator\npip install \"python-manta~=1.4.5\"\n\n# Exact version (not recommended - misses updates)\npip install \"python-manta==1.4.5.2\"\n</code></pre>"},{"location":"getting-started/#from-source","title":"From Source","text":"<p>If you're developing or need to build from source:</p>"},{"location":"getting-started/#option-1-download-pre-built-library","title":"Option 1: Download Pre-built Library","text":"<pre><code>git clone https://github.com/DeepBlueCoding/python-manta.git\ncd python-manta\npython scripts/download_library.py\npip install -e '.[dev]'\n</code></pre>"},{"location":"getting-started/#option-2-build-with-go","title":"Option 2: Build with Go","text":"<p>Requires Go 1.19+ installed.</p> <pre><code>git clone https://github.com/DeepBlueCoding/python-manta.git\ncd python-manta\ngit clone https://github.com/dotabuff/manta.git ../manta\n./build.sh\npip install -e '.[dev]'\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"from python_manta import Parser; print('Success!')\"\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#import-the-library","title":"Import the Library","text":"<pre><code>from python_manta import Parser\n\n# Create a parser instance for a demo file\nparser = Parser(\"match.dem\")\n</code></pre>"},{"location":"getting-started/#parse-match-header","title":"Parse Match Header","text":"<p>The header contains match metadata available without parsing the full replay:</p> <pre><code>result = parser.parse(header=True)\nheader = result.header\n\nprint(f\"Map: {header.map_name}\")\nprint(f\"Server: {header.server_name}\")\nprint(f\"Build: {header.build_num}\")\nprint(f\"Network Protocol: {header.network_protocol}\")\n</code></pre>"},{"location":"getting-started/#parse-game-info-draft-players-teams","title":"Parse Game Info (Draft, Players, Teams)","text":"<pre><code>result = parser.parse(game_info=True)\ngame_info = result.game_info\n\n# Match basics\nprint(f\"Match ID: {game_info.match_id}\")\nprint(f\"Winner: {'Radiant' if game_info.game_winner == 2 else 'Dire'}\")\n\n# Draft picks and bans\nfor event in game_info.picks_bans:\n    action = \"PICK\" if event.is_pick else \"BAN\"\n    team = \"Radiant\" if event.team == 2 else \"Dire\"\n    print(f\"{team} {action}: Hero ID {event.hero_id}\")\n\n# Team data (pro/league matches)\nif game_info.league_id &gt; 0:\n    print(f\"League: {game_info.league_id}\")\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n\n# Player info\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n</code></pre>"},{"location":"getting-started/#parse-multiple-data-types-in-single-pass","title":"Parse Multiple Data Types in Single Pass","text":"<pre><code># Parse header and game info together\nresult = parser.parse(header=True, game_info=True)\n\nprint(f\"Map: {result.header.map_name}\")\nprint(f\"Match ID: {result.game_info.match_id}\")\n</code></pre>"},{"location":"getting-started/#parse-messages","title":"Parse Messages","text":"<p>Use the messages collector to capture any of the 272 supported message types:</p> <pre><code># Get chat messages\nresult = parser.parse(messages={\n    \"filter\": \"CDOTAUserMsg_ChatMessage\",\n    \"max_messages\": 100\n})\n\nfor msg in result.messages.messages:\n    player = msg.data.get('source_player_id', 'Unknown')\n    text = msg.data.get('message_text', '')\n    print(f\"[{msg.tick}] Player {player}: {text}\")\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>from python_manta import Parser\n\ntry:\n    parser = Parser(\"match.dem\")\n    result = parser.parse(header=True)\n\n    if result.success:\n        print(f\"Parsed: {result.header.map_name}\")\n    else:\n        print(\"Parse failed\")\n\nexcept FileNotFoundError:\n    print(\"Demo file not found\")\nexcept ValueError as e:\n    print(f\"Invalid file: {e}\")\n</code></pre>"},{"location":"getting-started/#getting-replay-files","title":"Getting Replay Files","text":"<p>Dota 2 replay files (<code>.dem</code>) can be obtained from:</p> <ol> <li>Local replays - <code>Steam/steamapps/common/dota 2 beta/game/dota/replays/</code></li> <li>OpenDota API - api.opendota.com</li> <li>Valve API - Match history endpoints provide replay URLs</li> </ol> <p>Replay files are typically 100-200MB for a full match.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Complete method documentation</li> <li>Examples - Real-world code samples</li> </ul>"},{"location":"api/","title":"API Reference","text":"AI Summary <p>Complete API documentation for Python Manta. The main class is <code>Parser</code> which provides a unified <code>parse()</code> method with collectors for different data types. Data is returned as Pydantic models (<code>HeaderInfo</code>, <code>GameInfo</code>, <code>ParseResult</code>, etc.) for type safety and easy serialization. Main usage: <code>Parser(\"match.dem\").parse(header=True, game_info=True)</code>.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>Python Manta provides a single main class and several data models:</p>"},{"location":"api/#main-class","title":"Main Class","text":"Class Description <code>Parser</code> Main parser class with unified <code>parse()</code> method"},{"location":"api/#data-models","title":"Data Models","text":"Model Description <code>ParseResult</code> Result from <code>parse()</code> containing all collected data <code>HeaderInfo</code> Demo file header metadata <code>GameInfo</code> Game information (draft, players, teams) <code>DraftEvent</code> Single pick/ban event <code>PlayerInfo</code> Player information from match <code>MessagesResult</code> Messages parsing results <code>MessageEvent</code> Single message from replay"},{"location":"api/#quick-reference","title":"Quick Reference","text":"<pre><code>from python_manta import Parser\n\n# Create parser for a demo file\nparser = Parser(\"match.dem\")\n\n# Parse header only\nresult = parser.parse(header=True)\nprint(f\"Map: {result.header.map_name}\")\n\n# Parse multiple data types in single pass\nresult = parser.parse(header=True, game_info=True)\nprint(f\"Map: {result.header.map_name}\")\nprint(f\"Match ID: {result.game_info.match_id}\")\n\n# Parse messages with filtering\nresult = parser.parse(messages={\n    \"filter\": \"CDOTAUserMsg_ChatMessage\",\n    \"max_messages\": 100\n})\nfor msg in result.messages.messages:\n    print(f\"[{msg.tick}] {msg.data}\")\n</code></pre>"},{"location":"api/#collector-options","title":"Collector Options","text":"<p>The <code>parse()</code> method accepts these collector options:</p> Collector Type Description <code>header</code> <code>bool</code> Enable header parsing <code>game_info</code> <code>bool</code> Enable game info parsing (draft, players, teams) <code>messages</code> <code>bool</code> or <code>dict</code> Enable message parsing with optional filter"},{"location":"api/#message-options","title":"Message Options","text":"<p>When using <code>messages</code>, you can pass a dictionary with:</p> Key Type Description <code>filter</code> <code>str</code> Substring match for message types <code>max_messages</code> <code>int</code> Maximum messages to capture <pre><code># All messages (limited)\nresult = parser.parse(messages={\"max_messages\": 100})\n\n# Filtered messages\nresult = parser.parse(messages={\"filter\": \"Chat\", \"max_messages\": 50})\n</code></pre>"},{"location":"api/models/","title":"Data Models","text":"AI Summary <p>All parsed data is returned as Pydantic models for type safety and easy serialization. Models include: <code>HeaderInfo</code> (match metadata), <code>GameInfo</code>/<code>DraftEvent</code>/<code>PlayerInfo</code> (game data with draft, teams, players), <code>UniversalParseResult</code>/<code>MessageEvent</code> (messages), <code>GameEventsResult</code>/<code>GameEventData</code> (events), <code>CombatLogResult</code>/<code>CombatLogEntry</code> (combat), <code>ModifiersResult</code>/<code>ModifierEntry</code> (buffs), <code>EntitiesResult</code>/<code>EntityData</code> (entities), <code>HeroSnapshot</code>/<code>EntityStateSnapshot</code> (hero state with armor, damage, attributes at specific ticks), <code>StringTablesResult</code> (tables), <code>ParserInfo</code> (state). Enums include <code>RuneType</code> (rune tracking), <code>EntityType</code> (hero, creep, summon, building), <code>CombatLogType</code> (45 combat log event types), <code>DamageType</code> (physical/magical/pure/hp_removal), <code>Team</code> (Radiant/Dire/Neutral), <code>NeutralCampType</code> (small/medium/hard/ancient camps for multi-camp farming detection), <code>NeutralItemTier</code> (tier unlock times), <code>NeutralItem</code> (100+ neutral items), <code>ChatWheelMessage</code> (voice line IDs), and <code>GameActivity</code> (animation/taunt detection). All models have <code>.model_dump()</code> for dict conversion and <code>.model_dump_json()</code> for JSON.</p>"},{"location":"api/models/#utility-functions","title":"Utility Functions","text":""},{"location":"api/models/#time-utilities","title":"Time Utilities","text":"Function Description <code>TICKS_PER_SECOND</code> Constant: 30.0 ticks per second <code>format_game_time(seconds)</code> Format game time as <code>\"-0:40\"</code> or <code>\"3:07\"</code> <code>game_time_to_tick(game_time, game_start_tick)</code> Convert game time (seconds) to tick <code>tick_to_game_time(tick, game_start_tick)</code> Convert tick to game time (seconds) <p>Example: <pre><code>from python_manta import format_game_time, TICKS_PER_SECOND\n\n# Format game time\nprint(format_game_time(187))   # \"3:07\"\nprint(format_game_time(-40))   # \"-0:40\"\n\n# Convert between ticks and game time\ngame_start_tick = 27000\ntick = game_time_to_tick(300, game_start_tick)  # 5:00 -&gt; tick 36000\ntime = tick_to_game_time(36000, game_start_tick)  # tick 36000 -&gt; 300.0\n</code></pre></p>"},{"location":"api/models/#hero-name-utilities","title":"Hero Name Utilities","text":"Function Description <code>normalize_hero_name(name)</code> Normalize hero names by replacing double underscores with single <p>Entity snapshots may use double underscores (<code>npc_dota_hero_shadow__demon</code>) while combat log uses single (<code>npc_dota_hero_shadow_demon</code>). This function ensures consistency for matching.</p> <p>Example: <pre><code>from python_manta import normalize_hero_name\n\n# Normalize hero names for consistent matching\nname = normalize_hero_name(\"npc_dota_hero_shadow__demon\")\nprint(name)  # \"npc_dota_hero_shadow_demon\"\n\n# Works with just the hero key too\nkey = normalize_hero_name(\"shadow__demon\")\nprint(key)  # \"shadow_demon\"\n\n# No change if already normalized\nprint(normalize_hero_name(\"shadow_demon\"))  # \"shadow_demon\"\n</code></pre></p>"},{"location":"api/models/#enums","title":"Enums","text":""},{"location":"api/models/#runetype","title":"RuneType","text":"<p>Enum for Dota 2 power rune types with helper methods for combat log analysis.</p> <pre><code>class RuneType(str, Enum):\n    DOUBLE_DAMAGE = \"modifier_rune_doubledamage\"\n    HASTE = \"modifier_rune_haste\"\n    ILLUSION = \"modifier_rune_illusion\"\n    INVISIBILITY = \"modifier_rune_invis\"\n    REGENERATION = \"modifier_rune_regen\"\n    ARCANE = \"modifier_rune_arcane\"\n    SHIELD = \"modifier_rune_shield\"\n    WATER = \"modifier_rune_water\"\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Double Damage\") <code>modifier_name</code> str Combat log modifier name <p>Class Methods:</p> Method Returns Description <code>from_modifier(name)</code> <code>RuneType \\| None</code> Get RuneType from modifier name <code>is_rune_modifier(name)</code> <code>bool</code> Check if modifier is a rune <code>all_modifiers()</code> <code>List[str]</code> Get all rune modifier names <p>Example: <pre><code>from python_manta import RuneType\n\n# Check if a combat log entry is a rune pickup\nif RuneType.is_rune_modifier(entry.inflictor_name):\n    rune = RuneType.from_modifier(entry.inflictor_name)\n    print(f\"Picked up {rune.display_name}\")\n\n# Direct enum access\nprint(RuneType.HASTE.display_name)  # \"Haste\"\nprint(RuneType.HASTE.modifier_name)  # \"modifier_rune_haste\"\n\n# Get all rune modifiers for filtering\nrune_modifiers = RuneType.all_modifiers()\n</code></pre></p>"},{"location":"api/models/#entitytype","title":"EntityType","text":"<p>Enum for classifying Dota 2 entity types from entity name strings. Useful for filtering combat log entries by attacker/target type.</p> <pre><code>class EntityType(str, Enum):\n    HERO = \"hero\"\n    LANE_CREEP = \"lane_creep\"\n    NEUTRAL_CREEP = \"neutral_creep\"\n    SUMMON = \"summon\"\n    BUILDING = \"building\"\n    WARD = \"ward\"\n    COURIER = \"courier\"\n    ROSHAN = \"roshan\"\n    UNKNOWN = \"unknown\"\n</code></pre> <p>Properties:</p> Property Type Description <code>is_hero</code> bool True if this is a hero <code>is_creep</code> bool True if lane or neutral creep <code>is_unit</code> bool True if controllable unit (not building/ward) <code>is_structure</code> bool True if building or ward <p>Class Methods:</p> Method Returns Description <code>from_name(entity_name)</code> <code>EntityType</code> Get EntityType from entity name string <p>Example: <pre><code>from python_manta import MantaParser, EntityType\n\nparser = MantaParser()\nresult = parser.parse_combat_log(demo_path, types=[0], max_entries=1000)\n\nfor entry in result.entries:\n    attacker_type = EntityType.from_name(entry.attacker_name)\n    target_type = EntityType.from_name(entry.target_name)\n\n    # Self-buff detection\n    is_self = entry.attacker_name == entry.target_name\n\n    # Hero vs hero combat\n    if attacker_type.is_hero and target_type.is_hero and not is_self:\n        print(f\"Hero combat: {entry.attacker_name} -&gt; {entry.target_name}\")\n\n    # Hero farming creeps\n    if attacker_type.is_hero and target_type.is_creep:\n        print(f\"Farming: {entry.attacker_name} hit {entry.target_name}\")\n\n    # Building damage\n    if target_type == EntityType.BUILDING:\n        print(f\"Structure damage: {entry.target_name}\")\n</code></pre></p>"},{"location":"api/models/#combatlogtype","title":"CombatLogType","text":"<p>Enum for all 45+ combat log event types. Use this instead of magic numbers when filtering combat log entries.</p> <pre><code>class CombatLogType(int, Enum):\n    DAMAGE = 0\n    HEAL = 1\n    MODIFIER_ADD = 2\n    MODIFIER_REMOVE = 3\n    DEATH = 4\n    ABILITY = 5\n    ITEM = 6\n    LOCATION = 7\n    GOLD = 8\n    GAME_STATE = 9\n    XP = 10\n    PURCHASE = 11\n    BUYBACK = 12\n    ABILITY_TRIGGER = 13\n    PLAYERSTATS = 14\n    MULTIKILL = 15\n    KILLSTREAK = 16\n    TEAM_BUILDING_KILL = 17\n    FIRST_BLOOD = 18\n    MODIFIER_REFRESH = 19\n    NEUTRAL_CAMP_STACK = 20\n    PICKUP_RUNE = 21\n    REVEALED_INVISIBLE = 22\n    HERO_SAVED = 23\n    MANA_RESTORED = 24\n    HERO_LEVELUP = 25\n    BOTTLE_HEAL_ALLY = 26\n    ENDGAME_STATS = 27\n    INTERRUPT_CHANNEL = 28\n    ALLIED_GOLD = 29\n    AEGIS_TAKEN = 30\n    MANA_DAMAGE = 31\n    PHYSICAL_DAMAGE_PREVENTED = 32\n    UNIT_SUMMONED = 33\n    ATTACK_EVADE = 34\n    TREE_CUT = 35\n    SUCCESSFUL_SCAN = 36\n    END_KILLSTREAK = 37\n    BLOODSTONE_CHARGE = 38\n    CRITICAL_DAMAGE = 39\n    SPELL_ABSORB = 40\n    UNIT_TELEPORTED = 41\n    KILL_EATER_EVENT = 42\n    NEUTRAL_ITEM_EARNED = 43\n    TELEPORT_INTERRUPTED = 44\n    MODIFIER_STACK_EVENT = 45\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Purchase\") <code>is_damage_related</code> bool True if type is damage/heal related <code>is_modifier_related</code> bool True if type is buff/debuff related <code>is_economy_related</code> bool True if type is gold/XP/item related <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>CombatLogType \\| None</code> Get CombatLogType from integer value <p>Example: <pre><code>from python_manta import MantaParser, CombatLogType\n\nparser = MantaParser()\n\n# Use enum instead of magic numbers\nresult = parser.parse_combat_log(\n    demo_path,\n    types=[CombatLogType.PURCHASE, CombatLogType.ITEM],\n    max_entries=100\n)\n\nfor entry in result.entries:\n    log_type = CombatLogType.from_value(entry.type)\n    if log_type == CombatLogType.PURCHASE:\n        print(f\"{entry.target_name} bought {entry.value_name}\")\n    elif log_type == CombatLogType.ITEM:\n        print(f\"{entry.attacker_name} used {entry.inflictor_name}\")\n\n# Check type categories\nif log_type.is_economy_related:\n    print(\"Economy event\")\n</code></pre></p>"},{"location":"api/models/#damagetype","title":"DamageType","text":"<p>Enum for Dota 2 damage types.</p> <pre><code>class DamageType(int, Enum):\n    PHYSICAL = 0    # Right-click attacks, physical spells\n    MAGICAL = 1     # Most spells, reduced by magic resistance\n    PURE = 2        # Ignores armor and magic resistance\n    COMPOSITE = 3   # Legacy: removed from Dota 2, was reduced by both armor and magic resistance\n    HP_REMOVAL = 4  # Blood Grenade, Heart stopper aura, etc.\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Physical\") <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>DamageType \\| None</code> Get DamageType from integer value <p>Example: <pre><code>from python_manta import Parser, DamageType, CombatLogType\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [CombatLogType.DAMAGE.value], \"max_entries\": 100})\n\nfor entry in result.combat_log.entries:\n    dmg_type = DamageType.from_value(entry.damage_type)\n    if dmg_type == DamageType.PURE:\n        print(f\"Pure damage: {entry.value} from {entry.inflictor_name}\")\n    elif dmg_type == DamageType.HP_REMOVAL:\n        print(f\"HP Removal: {entry.value} from {entry.inflictor_name}\")\n</code></pre></p>"},{"location":"api/models/#team","title":"Team","text":"<p>Enum for Dota 2 team identifiers.</p> <pre><code>class Team(int, Enum):\n    SPECTATOR = 0   # Spectator/observer\n    UNASSIGNED = 1  # Not yet assigned\n    RADIANT = 2     # Radiant team (bottom-left)\n    DIRE = 3        # Dire team (top-right)\n    NEUTRAL = 4     # Neutral creeps, Roshan, jungle camps\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Radiant\") <code>is_playing</code> bool True if Radiant or Dire <code>is_neutral</code> bool True if neutral unit <code>opposite</code> <code>Team \\| None</code> The opposing team (None for non-playing) <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>Team \\| None</code> Get Team from integer value <p>Example: <pre><code>from python_manta import Parser, Team, CombatLogType\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [CombatLogType.DEATH.value], \"heroes_only\": True})\n\nfor entry in result.combat_log.entries:\n    attacker_team = Team.from_value(entry.attacker_team)\n    target_team = Team.from_value(entry.target_team)\n\n    if attacker_team and target_team and attacker_team != target_team:\n        print(f\"{attacker_team.display_name} killed {target_team.display_name} hero\")\n\n    # Check for neutral creep kills\n    if target_team == Team.NEUTRAL:\n        print(f\"{attacker_team.display_name} killed neutral creep\")\n\n    # Use opposite property\n    if attacker_team == Team.RADIANT:\n        enemy = attacker_team.opposite  # Team.DIRE\n</code></pre></p>"},{"location":"api/models/#neutralcamptype","title":"NeutralCampType","text":"<p>Enum for neutral creep camp types. Used in combat log events (DEATH, MODIFIER_ADD, etc.) to identify which type of neutral camp a creep belongs to. Useful for detecting multi-camp farming.</p> <pre><code>class NeutralCampType(int, Enum):\n    SMALL = 0   # Small camps: kobolds, harpies, ghosts, forest trolls, gnolls\n    MEDIUM = 1  # Medium camps: wolves, ogres, mud golems\n    HARD = 2    # Hard/Large camps: hellbears, dark trolls, wildkin, satyr hellcaller, centaurs\n    ANCIENT = 3 # Ancient camps: dragons, thunderhides, prowlers, rock golems\n</code></pre> <p>SMALL (0) includes non-neutrals</p> <p>The value 0 is also used for non-neutral units (lane creeps, wards). Filter by <code>\"neutral\" in target_name</code> to get only neutral creeps.</p> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Hard Camp\") <code>is_ancient</code> bool True if this is an ancient camp <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>NeutralCampType</code> Get NeutralCampType from integer value <p>Example - Multi-camp farming detection: <pre><code>from python_manta import Parser, NeutralCampType\nfrom collections import defaultdict\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={})\n\n# Filter neutral creep deaths by heroes\nneutral_deaths = [\n    e for e in result.combat_log.entries\n    if e.type_name == \"DOTA_COMBATLOG_DEATH\"\n    and \"npc_dota_neutral\" in e.target_name\n    and e.attacker_name.startswith(\"npc_dota_hero_\")\n]\n\n# Group by time window (2 seconds) + attacker\ndef time_bucket(game_time):\n    return int(game_time / 2.0)\n\nkills_by_window = defaultdict(list)\nfor e in neutral_deaths:\n    key = (time_bucket(e.game_time), e.attacker_name)\n    kills_by_window[key].append(e)\n\n# Detect multi-camp: different camp_types in same window\nfor (bucket, attacker), kills in kills_by_window.items():\n    camp_types = set(NeutralCampType.from_value(e.neutral_camp_type) for e in kills)\n\n    if len(camp_types) &gt;= 2:\n        hero = attacker.replace(\"npc_dota_hero_\", \"\")\n        types = [ct.display_name for ct in camp_types]\n        print(f\"{hero} multi-camp farming: {types}\")\n</code></pre></p> <p>Example - Camp type breakdown: <pre><code>from python_manta import Parser, NeutralCampType, Team\nfrom collections import Counter\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [1]})  # DEATH events\n\n# Count neutral kills by camp type\nneutral_deaths = [\n    e for e in result.combat_log.entries\n    if \"npc_dota_neutral\" in e.target_name\n]\n\nby_type = Counter(NeutralCampType.from_value(e.neutral_camp_type) for e in neutral_deaths)\nfor camp_type, count in by_type.most_common():\n    print(f\"{camp_type.display_name}: {count} kills\")\n\n# Also available: neutral_camp_team (2=Radiant jungle, 3=Dire jungle)\nradiant_jungle = sum(1 for e in neutral_deaths if e.neutral_camp_team == Team.RADIANT)\ndire_jungle = sum(1 for e in neutral_deaths if e.neutral_camp_team == Team.DIRE)\nprint(f\"Radiant jungle: {radiant_jungle}, Dire jungle: {dire_jungle}\")\n</code></pre></p>"},{"location":"api/models/#neutralitemtier","title":"NeutralItemTier","text":"<p>Enum for neutral item tier classification. Tiers unlock at specific game times.</p> <pre><code>class NeutralItemTier(int, Enum):\n    TIER_1 = 0  # Unlocks at 5:00\n    TIER_2 = 1  # Unlocks at 15:00\n    TIER_3 = 2  # Unlocks at 25:00\n    TIER_4 = 3  # Unlocks at 35:00\n    TIER_5 = 4  # Unlocks at 55:00\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable name (e.g., \"Tier 1\") <code>unlock_time_minutes</code> int Game time in minutes when tier unlocks <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>NeutralItemTier \\| None</code> Get tier from integer value (0-4) <p>Example: <pre><code>from python_manta import NeutralItemTier\n\ntier = NeutralItemTier.TIER_3\nprint(f\"{tier.display_name} unlocks at {tier.unlock_time_minutes} minutes\")\n# Output: Tier 3 unlocks at 25 minutes\n</code></pre></p>"},{"location":"api/models/#neutralitem","title":"NeutralItem","text":"<p>Comprehensive enum of all Dota 2 neutral items (100+ items), including both active items and retired/rotated items from previous patches. Useful for tracking neutral item pickups and usage.</p> <pre><code>class NeutralItem(str, Enum):\n    # Tier 1 - Current (7.38+)\n    CHIPPED_VEST = \"item_chipped_vest\"\n    DORMANT_CURIO = \"item_dormant_curio\"\n    KOBOLD_CUP = \"item_kobold_cup\"\n    # ... 100+ items including retired ones\n\n    # Tier 5 - Retired\n    APEX = \"item_apex\"\n    PIRATE_HAT = \"item_pirate_hat\"\n    # etc.\n</code></pre> <p>Properties:</p> Property Type Description <code>item_name</code> str Internal item name (e.g., \"item_kobold_cup\") <code>display_name</code> str Human-readable name (e.g., \"Kobold Cup\") <code>tier</code> int | None Item tier (0-4) or None for special items <code>tier_enum</code> NeutralItemTier | None Tier as enum <p>Class Methods:</p> Method Returns Description <code>from_item_name(name)</code> <code>NeutralItem \\| None</code> Get NeutralItem from internal name <code>is_neutral_item(name)</code> <code>bool</code> Check if item name is a neutral item <code>items_by_tier(tier)</code> <code>List[NeutralItem]</code> Get all items of a specific tier <code>all_item_names()</code> <code>List[str]</code> Get all neutral item internal names <p>Example: <pre><code>from python_manta import MantaParser, NeutralItem, NeutralItemTier, CombatLogType\n\nparser = MantaParser()\n\n# Track neutral item usage in combat log\nresult = parser.parse_combat_log(demo_path, types=[CombatLogType.ITEM], max_entries=1000)\n\nfor entry in result.entries:\n    if NeutralItem.is_neutral_item(entry.inflictor_name):\n        item = NeutralItem.from_item_name(entry.inflictor_name)\n        print(f\"{entry.attacker_name} used {item.display_name} (Tier {item.tier + 1})\")\n\n# Get all Tier 1 items\ntier1_items = NeutralItem.items_by_tier(0)\nprint(f\"Tier 1 has {len(tier1_items)} items\")\n\n# Check unlock times\ntier = NeutralItemTier.TIER_3\nprint(f\"{tier.display_name} items unlock at {tier.unlock_time_minutes} minutes\")\n</code></pre></p> <p>Tracking Neutral Item Drops: <pre><code># Use CDOTAUserMsg_FoundNeutralItem for neutral item pickups\nresult = parser.parse_universal(demo_path, \"FoundNeutralItem\", max_messages=100)\n\nfor msg in result.messages:\n    player_id = msg.data.get('player_id')\n    item_tier = msg.data.get('item_tier')  # 0-4\n    tier = NeutralItemTier.from_value(item_tier)\n    print(f\"Player {player_id} found a {tier.display_name} neutral item\")\n</code></pre></p>"},{"location":"api/models/#chatwheelmessage","title":"ChatWheelMessage","text":"<p>Enum for Dota 2 chat wheel message IDs. Maps voice line IDs to human-readable text.</p> <pre><code>class ChatWheelMessage(int, Enum):\n    # Standard phrases (0-232)\n    OK = 0\n    CAREFUL = 1\n    GET_BACK = 2\n    NEED_WARDS = 3\n    STUN_NOW = 4\n    HELP = 5\n    PUSH_NOW = 6\n    WELL_PLAYED = 7\n    # ... many more standard phrases\n    MY_BAD = 68\n    SPACE_CREATED = 71\n    BRUTAL_SAVAGE_REKT = 230\n    # Dota Plus lines: 11000+\n    # TI Battle Pass lines: 120000+\n    # TI talent/team lines: 401000+\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable message text <p>Class Methods:</p> Method Returns Description <code>from_id(id)</code> <code>ChatWheelMessage \\| None</code> Get enum from message ID <code>describe_id(id)</code> <code>str</code> Get description for any ID (including unmapped) <p>Example: <pre><code>from python_manta import MantaParser, ChatWheelMessage\n\nparser = MantaParser()\ngame_info = parser.parse_game_info(\"match.dem\")\nplayers = {i: p.player_name for i, p in enumerate(game_info.players)}\n\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatWheel\", 100)\n\nfor msg in result.messages:\n    player_id = msg.data.get('player_id', -1)\n    player_name = players.get(player_id, f'Player {player_id}')\n    msg_id = msg.data.get('chat_message_id', 0)\n\n    # Use enum for known IDs, describe_id for all\n    text = ChatWheelMessage.describe_id(msg_id)\n    print(f\"{player_name}: {text}\")\n\n# Output:\n# Malr1ne: TI Battle Pass Voice Line #120009\n# AMMAR_THE_F: &gt; Space created\n# Malr1ne: My bad\n</code></pre></p>"},{"location":"api/models/#gameactivity","title":"GameActivity","text":"<p>Enum for Dota 2 unit animation activity codes. Used in <code>CDOTAUserMsg_TE_UnitAnimation</code> messages to identify what animation a unit is playing. Useful for detecting taunts.</p> <pre><code>class GameActivity(int, Enum):\n    # Basic states\n    IDLE = 1500\n    IDLE_RARE = 1501\n    RUN = 1502\n    ATTACK = 1503\n    ATTACK2 = 1504\n    DIE = 1506\n    DISABLED = 1509\n    # Ability casting\n    CAST_ABILITY_1 = 1510\n    CAST_ABILITY_2 = 1511\n    # ... through CAST_ABILITY_6\n    # Channeling\n    CHANNEL_ABILITY_1 = 1520\n    # ... through CHANNEL_ABILITY_6\n    # Taunts\n    KILLTAUNT = 1535\n    TAUNT = 1536\n    TAUNT_SNIPER = 1641\n    TAUNT_SPECIAL = 1752\n    CUSTOM_TOWER_TAUNT = 1756\n</code></pre> <p>Properties:</p> Property Type Description <code>display_name</code> str Human-readable activity name <code>is_taunt</code> bool True if this is a taunt animation <code>is_attack</code> bool True if this is an attack animation <code>is_ability_cast</code> bool True if this is an ability cast <code>is_channeling</code> bool True if this is a channeling animation <p>Class Methods:</p> Method Returns Description <code>from_value(int)</code> <code>GameActivity \\| None</code> Get activity from integer value <code>get_taunt_activities()</code> <code>List[GameActivity]</code> Get all taunt-related activities <p>Example: <pre><code>from python_manta import MantaParser, GameActivity\n\nparser = MantaParser()\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_TE_UnitAnimation\", 10000)\n\n# Find taunts\nfor msg in result.messages:\n    activity_code = msg.data.get('activity', 0)\n    activity = GameActivity.from_value(activity_code)\n\n    if activity and activity.is_taunt:\n        print(f\"Taunt detected at tick {msg.tick}: {activity.display_name}\")\n\n# Check activity types\nactivity = GameActivity.ATTACK\nprint(activity.is_attack)      # True\nprint(activity.is_ability_cast) # False\n</code></pre></p>"},{"location":"api/models/#header-models","title":"Header Models","text":""},{"location":"api/models/#headerinfo","title":"HeaderInfo","text":"<p>Match header metadata from the demo file.</p> <pre><code>class HeaderInfo(BaseModel):\n    map_name: str              # Map name (e.g., \"dota\")\n    server_name: str           # Server identifier\n    client_name: str           # Client type\n    game_directory: str        # Game directory path\n    network_protocol: int      # Network protocol version\n    demo_file_stamp: str       # Demo file signature\n    build_num: int             # Game build number\n    game: str                  # Game identifier\n    server_start_tick: int     # Server start tick\n    success: bool              # Parse success flag\n    error: Optional[str]       # Error message if failed\n</code></pre> <p>Example: <pre><code>header = parser.parse_header(\"match.dem\")\n\n# Access fields\nprint(header.map_name)\nprint(header.build_num)\n\n# Convert to dict\ndata = header.model_dump()\n\n# Convert to JSON\njson_str = header.model_dump_json()\n</code></pre></p>"},{"location":"api/models/#game-info-models","title":"Game Info Models","text":""},{"location":"api/models/#gameinfo","title":"GameInfo","text":"<p>Complete game information including draft, players, and teams.</p> <pre><code>class GameInfo(BaseModel):\n    # Basic match info\n    match_id: int              # Match ID\n    game_mode: int             # Game mode ID\n    game_winner: int           # Winner (2=Radiant, 3=Dire)\n    league_id: int             # League ID (0 for pub matches)\n    end_time: int              # End time (Unix timestamp)\n\n    # Team info (pro matches only - 0/empty for pubs)\n    radiant_team_id: int       # Radiant team ID\n    dire_team_id: int          # Dire team ID\n    radiant_team_tag: str      # Radiant team tag (e.g., \"OG\")\n    dire_team_tag: str         # Dire team tag (e.g., \"Secret\")\n\n    # Players\n    players: List[PlayerInfo]  # All players in match\n\n    # Draft\n    picks_bans: List[DraftEvent]  # Draft sequence\n\n    # Playback info\n    playback_time: float       # Total playback time in seconds\n    playback_ticks: int        # Total ticks\n    playback_frames: int       # Total frames\n\n    success: bool              # Parse success flag\n    error: Optional[str]       # Error message if failed\n</code></pre>"},{"location":"api/models/#draftevent","title":"DraftEvent","text":"<p>Single pick or ban event in the draft.</p> <pre><code>class DraftEvent(BaseModel):\n    is_pick: bool    # True for pick, False for ban\n    team: int        # 2 = Radiant, 3 = Dire\n    hero_id: int     # Hero ID (see Dota 2 Wiki for mappings)\n</code></pre>"},{"location":"api/models/#playerinfo","title":"PlayerInfo","text":"<p>Player information from match metadata.</p> <pre><code>class PlayerInfo(BaseModel):\n    hero_name: str           # Hero internal name (e.g., \"npc_dota_hero_axe\")\n    player_name: str         # Player display name\n    is_fake_client: bool     # True for bots\n    steam_id: int            # Player Steam ID\n    team: int                # Team (2=Radiant, 3=Dire)\n</code></pre> <p>Example: <pre><code>game_info = parser.parse_game_info(\"match.dem\")\n\n# Basic match info\nprint(f\"Match {game_info.match_id}\")\n# Convert to proper time format (H:MM:SS)\nhours = int(game_info.playback_time // 3600)\nmins = int((game_info.playback_time % 3600) // 60)\nsecs = int(game_info.playback_time % 60)\nprint(f\"Duration: {hours}:{mins:02d}:{secs:02d}\")\nwinner = \"Radiant\" if game_info.game_winner == 2 else \"Dire\"\nprint(f\"Winner: {winner}\")\n\n# Team info (pro matches)\nif game_info.league_id &gt; 0:\n    print(f\"League: {game_info.league_id}\")\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n\n# Players\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n\n# Draft\nradiant_picks = [e for e in game_info.picks_bans if e.is_pick and e.team == 2]\ndire_bans = [e for e in game_info.picks_bans if not e.is_pick and e.team == 3]\n\n# Hero IDs: 1=Anti-Mage, 2=Axe, etc.\nfor pick in radiant_picks:\n    print(f\"Radiant picked hero {pick.hero_id}\")\n</code></pre></p>"},{"location":"api/models/#universal-parse-models","title":"Universal Parse Models","text":""},{"location":"api/models/#universalparseresult","title":"UniversalParseResult","text":"<p>Result container for <code>parse_universal()</code>.</p> <pre><code>class UniversalParseResult(BaseModel):\n    messages: List[MessageEvent]  # Matched messages\n    success: bool                 # Parse success flag\n    error: Optional[str]          # Error message if failed\n    count: int                    # Number of messages\n</code></pre>"},{"location":"api/models/#messageevent","title":"MessageEvent","text":"<p>Single message from the replay.</p> <pre><code>class MessageEvent(BaseModel):\n    type: str                    # Callback name (e.g., \"CDOTAUserMsg_ChatMessage\")\n    tick: int                    # Game tick when message occurred\n    net_tick: int                # Network tick\n    data: Any                    # Message-specific data (dict)\n    game_time: float             # Game time in seconds (negative before horn)\n    game_time_str: str           # Formatted game time (e.g., \"-0:40\", \"5:32\")\n</code></pre> <p>Example: <pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    # Access common fields\n    print(f\"Type: {msg.type}\")\n    print(f\"Tick: {msg.tick}\")\n\n    # Access message-specific data\n    player_id = msg.data.get('source_player_id')\n    text = msg.data.get('message_text')\n</code></pre></p>"},{"location":"api/models/#game-events-models","title":"Game Events Models","text":""},{"location":"api/models/#gameeventsresult","title":"GameEventsResult","text":"<p>Result container for <code>parse_game_events()</code>.</p> <pre><code>class GameEventsResult(BaseModel):\n    events: List[GameEventData]  # Parsed events\n    event_types: List[str]       # Event type definitions (if capture_types=True)\n    success: bool                # Parse success flag\n    error: Optional[str]         # Error message if failed\n    total_events: int            # Total events captured\n</code></pre>"},{"location":"api/models/#gameeventdata","title":"GameEventData","text":"<p>Single game event with typed fields.</p> <pre><code>class GameEventData(BaseModel):\n    name: str                     # Event name (e.g., \"dota_combatlog\")\n    tick: int                     # Game tick\n    net_tick: int                 # Network tick\n    fields: Dict[str, Any]        # Event-specific fields\n</code></pre> <p>Example: <pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=50)\n\nfor event in result.events:\n    print(f\"Event: {event.name}\")\n    print(f\"Tick: {event.tick}\")\n\n    # Fields depend on event type\n    for field_name, value in event.fields.items():\n        print(f\"  {field_name}: {value}\")\n</code></pre></p>"},{"location":"api/models/#combat-log-models","title":"Combat Log Models","text":""},{"location":"api/models/#combatlogresult","title":"CombatLogResult","text":"<p>Result container for <code>parse_combat_log()</code>.</p> <pre><code>class CombatLogResult(BaseModel):\n    entries: List[CombatLogEntry]  # Combat log entries\n    success: bool                  # Parse success flag\n    error: Optional[str]           # Error message if failed\n    total_entries: int             # Total entries captured\n</code></pre>"},{"location":"api/models/#combatlogentry","title":"CombatLogEntry","text":"<p>Single combat log entry with structured data.</p> <pre><code>class CombatLogEntry(BaseModel):\n    tick: int                     # Game tick\n    net_tick: int                 # Network tick\n    type: int                     # Combat log type ID\n    type_name: str                # Human-readable type name\n    target_name: str              # Target unit name\n    target_source_name: str       # Target source name\n    attacker_name: str            # Attacker unit name\n    damage_source_name: str       # Damage source name\n    inflictor_name: str           # Ability/item that caused this\n    is_attacker_illusion: bool    # Attacker is illusion\n    is_attacker_hero: bool        # Attacker is a hero\n    is_target_illusion: bool      # Target is illusion\n    is_target_hero: bool          # Target is a hero\n    is_visible_radiant: bool      # Visible to Radiant\n    is_visible_dire: bool         # Visible to Dire\n    value: int                    # Damage/heal value\n    health: int                   # Target health after\n    game_time: float              # Game time in seconds (negative before horn)\n    game_time_str: str            # Formatted game time (e.g., \"-0:40\", \"5:32\")\n    stun_duration: float          # Stun duration if applicable\n    slow_duration: float          # Slow duration if applicable\n    is_ability_toggle_on: bool    # Ability toggled on\n    is_ability_toggle_off: bool   # Ability toggled off\n    ability_level: int            # Ability level\n    xp: int                       # XP reason/amount\n    gold: int                     # Gold reason/amount\n    last_hits: int                # Last hits at time\n    attacker_team: int            # Attacker team ID\n    target_team: int              # Target team ID\n    attacker_hero_level: int      # Attacker's hero level (from entity state)\n    target_hero_level: int        # Target's hero level (from entity state)\n</code></pre> <p>Hero Levels Now Available (v1.4.5.4+)</p> <p><code>attacker_hero_level</code> and <code>target_hero_level</code> are now populated from entity state during parsing. 100% of hero deaths have <code>target_hero_level</code>, 94%+ have <code>attacker_hero_level</code>.</p> <p>Example: <pre><code>result = parser.parse(combat_log={\"types\": [4], \"heroes_only\": True, \"max_entries\": 100})\n\nfor entry in result.combat_log.entries:\n    if entry.type == 4:  # DEATH\n        print(f\"[{entry.game_time_str}] {entry.attacker_name} (lvl {entry.attacker_hero_level}) \"\n              f\"killed {entry.target_name} (lvl {entry.target_hero_level})\")\n</code></pre></p>"},{"location":"api/models/#attack-models","title":"Attack Models","text":"<p>Attack models capture auto-attack projectiles from <code>TE_Projectile</code> messages. Unlike combat log which only records damage/kill events, attacks capture the actual attack action including tower attacks on creeps and neutral aggro.</p>"},{"location":"api/models/#attacksresult","title":"AttacksResult","text":"<p>Result container for attacks parsing.</p> <pre><code>class AttacksResult(BaseModel):\n    events: List[AttackEvent] = []  # Attack events\n    total_events: int = 0           # Total events captured\n</code></pre>"},{"location":"api/models/#attackevent","title":"AttackEvent","text":"<p>Single attack event (ranged projectile or melee hit).</p> <pre><code>class AttackEvent(BaseModel):\n    # Timing\n    tick: int                        # Game tick when attack was registered\n    game_time: float = 0.0           # Game time in seconds\n    game_time_str: str = \"\"          # Formatted game time (e.g., \"15:34\")\n    launch_tick: int = 0             # Tick when projectile was launched (ranged only)\n\n    # Entity identification\n    source_index: int = 0            # Entity index of attacker\n    target_index: int = 0            # Entity index of target\n    source_handle: int = 0           # Raw entity handle (ranged only)\n    target_handle: int = 0           # Raw entity handle (ranged only)\n    attacker_name: str = \"\"          # Unit name (e.g., \"npc_dota_hero_troll_warlord\")\n    target_name: str = \"\"            # Target unit name\n\n    # Attack properties\n    is_melee: bool = False           # True if melee attack (from combat log)\n    projectile_speed: int = 0        # Projectile move speed (ranged only)\n    dodgeable: bool = False          # Can be disjointed (ranged only)\n    location_x: float = 0.0          # Attacker position X\n    location_y: float = 0.0          # Attacker position Y\n\n    # Melee-specific fields (from combat log DAMAGE events)\n    damage: int = 0                  # Damage dealt (melee only)\n    target_health: int = 0           # Target health AFTER attack (melee only)\n    attacker_team: int = 0           # Attacker team: 2=Radiant, 3=Dire (melee only)\n    target_team: int = 0             # Target team: 2=Radiant, 3=Dire (melee only)\n    is_attacker_hero: bool = False   # Attacker is a hero (melee only)\n    is_target_hero: bool = False     # Target is a hero (melee only)\n</code></pre> <p>Example: <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(attacks={})\n\n# Separate ranged and melee attacks\nranged = [a for a in result.attacks.events if not a.is_melee]\nmelee = [a for a in result.attacks.events if a.is_melee]\nprint(f\"Ranged: {len(ranged)}, Melee: {len(melee)}\")\n\n# Hero vs hero melee combat (uses melee-specific fields)\nhero_fights = [\n    a for a in melee\n    if a.is_attacker_hero and a.is_target_hero\n]\nfor a in hero_fights[:5]:\n    atk = a.attacker_name.replace(\"npc_dota_hero_\", \"\")\n    tgt = a.target_name.replace(\"npc_dota_hero_\", \"\")\n    print(f\"[{a.game_time_str}] {atk} -&gt; {tgt}: {a.damage} dmg, target HP: {a.target_health}\")\n\n# Ranged projectile analysis\nfast_projectiles = [a for a in ranged if a.projectile_speed &gt; 1000]\nprint(f\"Fast projectiles (&gt;1000 speed): {len(fast_projectiles)}\")\n</code></pre></p>"},{"location":"api/models/#modifier-models","title":"Modifier Models","text":""},{"location":"api/models/#modifiersresult","title":"ModifiersResult","text":"<p>Result container for <code>parse_modifiers()</code>.</p> <pre><code>class ModifiersResult(BaseModel):\n    modifiers: List[ModifierEntry]  # Modifier entries\n    success: bool                   # Parse success flag\n    error: Optional[str]            # Error message if failed\n    total_modifiers: int            # Total modifiers captured\n</code></pre>"},{"location":"api/models/#modifierentry","title":"ModifierEntry","text":"<p>Single modifier/buff entry.</p> <pre><code>class ModifierEntry(BaseModel):\n    tick: int               # Game tick\n    net_tick: int           # Network tick\n    parent: int             # Entity handle of unit with modifier\n    caster: int             # Entity handle of caster\n    ability: int            # Ability that created modifier\n    modifier_class: int     # Modifier class ID\n    serial_num: int         # Serial number\n    index: int              # Modifier index\n    creation_time: float    # When modifier was created\n    duration: float         # Duration in seconds (-1 = permanent)\n    stack_count: int        # Number of stacks\n    is_aura: bool           # Whether it's an aura\n    is_debuff: bool         # Whether it's a debuff\n</code></pre> <p>Example: <pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    print(f\"Entity {mod.parent}: duration={duration_str}, stacks={mod.stack_count}\")\n</code></pre></p>"},{"location":"api/models/#entity-models","title":"Entity Models","text":""},{"location":"api/models/#entitiesresult","title":"EntitiesResult","text":"<p>Result container for <code>query_entities()</code>.</p> <pre><code>class EntitiesResult(BaseModel):\n    entities: List[EntityData]  # Entity data\n    success: bool               # Parse success flag\n    error: Optional[str]        # Error message if failed\n    total_entities: int         # Total entities returned\n    tick: int                   # Tick when captured\n    net_tick: int               # Network tick when captured\n</code></pre>"},{"location":"api/models/#entitydata","title":"EntityData","text":"<p>Single entity with properties.</p> <pre><code>class EntityData(BaseModel):\n    index: int                    # Entity index\n    serial: int                   # Entity serial number\n    class_name: str               # Entity class name\n    properties: Dict[str, Any]    # Entity properties\n</code></pre> <p>Common Hero Properties:</p> Property Type Description <code>m_iHealth</code> int Current health <code>m_iMaxHealth</code> int Maximum health <code>m_flMana</code> float Current mana <code>m_flMaxMana</code> float Maximum mana <code>m_vecOrigin</code> list Position [x, y, z] <code>m_iCurrentLevel</code> int Hero level <code>m_iTotalEarnedGold</code> int Total gold earned <code>m_iKills</code> int Kills <code>m_iDeaths</code> int Deaths <code>m_iAssists</code> int Assists <p>Example: <pre><code>result = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    print(f\"\\n{entity.class_name} (index={entity.index})\")\n    print(f\"  Health: {entity.properties.get('m_iHealth')}/{entity.properties.get('m_iMaxHealth')}\")\n    print(f\"  Level: {entity.properties.get('m_iCurrentLevel')}\")\n</code></pre></p>"},{"location":"api/models/#snapshot-models","title":"Snapshot Models","text":""},{"location":"api/models/#abilitysnapshot","title":"AbilitySnapshot","text":"<p>State of a single hero ability at a specific tick.</p> <pre><code>class AbilitySnapshot(BaseModel):\n    slot: int = 0                 # Ability slot index (0-5 for regular abilities)\n    name: str = \"\"                # Full ability class name (e.g., \"CDOTA_Ability_Juggernaut_BladeFury\")\n    level: int = 0                # Current ability level (0-4 typically)\n    cooldown: float = 0.0         # Current cooldown remaining\n    max_cooldown: float = 0.0     # Maximum cooldown length\n    mana_cost: int = 0            # Mana cost\n    charges: int = 0              # Current charges (for charge-based abilities)\n    is_ultimate: bool = False     # True if slot 5 (ultimate)\n\n    # Properties\n    short_name: str               # Name without \"CDOTA_Ability_\" prefix\n    is_maxed: bool                # True if at max level (4 for regular, 3 for ultimate)\n    is_on_cooldown: bool          # True if cooldown &gt; 0\n</code></pre>"},{"location":"api/models/#talentchoice","title":"TalentChoice","text":"<p>Represents a talent selection at levels 10, 15, 20, or 25.</p> <pre><code>class TalentChoice(BaseModel):\n    tier: int = 0                 # Talent tier (10, 15, 20, or 25)\n    slot: int = 0                 # Raw ability slot index\n    is_left: bool = True          # True if left talent was chosen\n    name: str = \"\"                # Talent ability name\n\n    # Properties\n    side: str                     # \"left\" or \"right\"\n</code></pre>"},{"location":"api/models/#itemsnapshot","title":"ItemSnapshot","text":"<p>State of a single item in hero inventory at a specific tick.</p> <pre><code>class ItemSnapshot(BaseModel):\n    slot: int = 0                 # Inventory slot (0-16)\n    name: str = \"\"                # Item class name (e.g., \"item_blink\")\n    charges: int = 0              # Current charges (wand, wards, etc.)\n    cooldown: float = 0.0         # Remaining cooldown\n    max_cooldown: float = 0.0     # Maximum cooldown length\n\n    # Properties\n    short_name: str               # Name without \"item_\" prefix (e.g., \"blink\")\n    is_main_inventory: bool       # True if slot 0-5\n    is_backpack: bool             # True if slot 6-8\n    is_tp_slot: bool              # True if slot 9\n    is_stash: bool                # True if slot 10-15\n    is_neutral_slot: bool         # True if slot 16\n    is_on_cooldown: bool          # True if cooldown &gt; 0\n</code></pre> <p>Inventory Slot Layout:</p> Slot Location 0-5 Main Inventory 6-8 Backpack 9 TP Slot 10-15 Stash 16 Neutral Item"},{"location":"api/models/#herosnapshot","title":"HeroSnapshot","text":"<p>Hero state captured at a specific tick via <code>parser.snapshot()</code>.</p> <pre><code>class HeroSnapshot(BaseModel):\n    hero_name: str = \"\"           # Hero class name (e.g., \"CDOTA_Unit_Hero_Axe\")\n    hero_id: int = 0              # Hero ID\n    player_id: int = 0            # Player slot (0-9)\n    team: int = 0                 # Team (2=Radiant, 3=Dire)\n    x: float = 0.0                # World X position\n    y: float = 0.0                # World Y position\n    z: float = 0.0                # World Z position\n    health: int = 0               # Current health\n    max_health: int = 0           # Maximum health\n    mana: float = 0.0             # Current mana\n    max_mana: float = 0.0         # Maximum mana\n    level: int = 0                # Hero level (1-30)\n    is_alive: bool = True         # Alive status\n    is_illusion: bool = False     # True if illusion\n    is_clone: bool = False        # True if clone (Meepo, Arc Warden)\n    # Combat stats\n    armor: float = 0.0            # Physical armor value\n    magic_resistance: float = 0.0 # Magic resistance percentage\n    damage_min: int = 0           # Minimum attack damage\n    damage_max: int = 0           # Maximum attack damage\n    attack_range: int = 0         # Attack range\n    # Attributes\n    strength: float = 0.0         # Total strength (base + bonuses)\n    agility: float = 0.0          # Total agility (base + bonuses)\n    intellect: float = 0.0        # Total intellect (base + bonuses)\n    # Abilities and talents\n    abilities: List[AbilitySnapshot] = []  # All hero abilities with levels\n    talents: List[TalentChoice] = []       # Chosen talents\n    ability_points: int = 0                # Unspent ability points\n    # Inventory (slots 0-5: main, 6-8: backpack, 9: TP, 10-15: stash, 16: neutral)\n    inventory: List[ItemSnapshot] = []     # All items in inventory\n\n    # Properties and methods\n    has_ultimate: bool            # True if ultimate ability has been learned\n    talents_chosen: int           # Number of talents selected (0-4)\n    get_ability(name) -&gt; Optional[AbilitySnapshot]  # Find ability by name (partial match)\n    get_talent_at_tier(tier) -&gt; Optional[TalentChoice]  # Get talent at tier (10/15/20/25)\n    # Inventory helpers\n    main_inventory: List[ItemSnapshot]    # Items in slots 0-5\n    backpack: List[ItemSnapshot]          # Items in slots 6-8\n    stash: List[ItemSnapshot]             # Items in slots 10-15\n    neutral_item: Optional[ItemSnapshot]  # Item in slot 16\n    tp_scroll: Optional[ItemSnapshot]     # Item in slot 9\n    get_item(name) -&gt; Optional[ItemSnapshot]  # Find item by name (partial match)\n    has_item(name) -&gt; bool                # Check if hero has item\n</code></pre>"},{"location":"api/models/#entitystatesnapshot","title":"EntityStateSnapshot","text":"<p>Result container for <code>parser.snapshot()</code>.</p> <pre><code>class EntityStateSnapshot(BaseModel):\n    tick: int = 0                   # Tick when snapshot was captured\n    game_time: float = 0.0          # Game time in seconds\n    heroes: List[HeroSnapshot] = [] # All hero states\n    success: bool = True            # Parse success flag\n    error: Optional[str] = None     # Error message if failed\n</code></pre> <p>Example - Basic Hero State: <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nindex = parser.build_index(interval_ticks=1800)\n\n# Get hero state at 10 minutes\ntarget_tick = index.game_started + (10 * 60 * 30)\nsnap = parser.snapshot(target_tick=target_tick)\n\nfor hero in snap.heroes:\n    name = hero.hero_name.replace(\"CDOTA_Unit_Hero_\", \"\")\n    print(f\"{name}: Lvl {hero.level}, HP {hero.health}/{hero.max_health}\")\n    print(f\"  Armor: {hero.armor:.1f}, Magic Resist: {hero.magic_resistance:.0f}%\")\n    print(f\"  Damage: {hero.damage_min}-{hero.damage_max}\")\n    print(f\"  STR: {hero.strength:.1f}, AGI: {hero.agility:.1f}, INT: {hero.intellect:.1f}\")\n</code></pre></p> <p>Example - Abilities and Talents: <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nsnap = parser.snapshot(target_tick=60000)  # ~33 minutes\n\nfor hero in snap.heroes:\n    print(f\"{hero.hero_name} (Level {hero.level})\")\n\n    # Show all abilities with levels\n    for ability in hero.abilities:\n        status = \"[MAX]\" if ability.is_maxed else \"\"\n        cd = f\" (CD: {ability.cooldown:.1f}s)\" if ability.is_on_cooldown else \"\"\n        print(f\"  {ability.short_name}: Level {ability.level}{status}{cd}\")\n\n    # Show talent choices\n    print(f\"  Talents: {hero.talents_chosen}/4\")\n    for talent in hero.talents:\n        print(f\"    Level {talent.tier}: {talent.side}\")\n\n    # Find specific ability by name\n    omnislash = hero.get_ability(\"Omnislash\")\n    if omnislash and omnislash.level &gt; 0:\n        print(f\"  Has Omnislash level {omnislash.level}\")\n\n    # Check if ultimate is learned\n    if hero.has_ultimate:\n        print(\"  Ultimate learned!\")\n\n    # Get talent at specific tier\n    lvl20_talent = hero.get_talent_at_tier(20)\n    if lvl20_talent:\n        print(f\"  Level 20 talent: {lvl20_talent.side}\")\n</code></pre></p> <p>Example - Inventory: <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nsnap = parser.snapshot(target_tick=60000)  # ~17 minutes\n\nfor hero in snap.heroes:\n    print(f\"{hero.hero_name}\")\n\n    # Main inventory\n    for item in hero.main_inventory:\n        charges = f\" x{item.charges}\" if item.charges else \"\"\n        print(f\"  [{item.slot}] {item.short_name}{charges}\")\n\n    # Neutral item\n    if hero.neutral_item:\n        print(f\"  Neutral: {hero.neutral_item.short_name}\")\n\n    # Find specific item\n    bkb = hero.get_item(\"black_king_bar\")\n    if bkb:\n        print(f\"  Has BKB in slot {bkb.slot}\")\n\n    # Check item presence\n    if hero.has_item(\"blink\"):\n        print(\"  Has Blink Dagger!\")\n</code></pre></p>"},{"location":"api/models/#string-table-models","title":"String Table Models","text":""},{"location":"api/models/#stringtablesresult","title":"StringTablesResult","text":"<p>Result container for <code>get_string_tables()</code>.</p> <pre><code>class StringTablesResult(BaseModel):\n    tables: Dict[str, List[StringTableData]]  # Table name -&gt; entries\n    table_names: List[str]                    # List of table names\n    success: bool                             # Parse success flag\n    error: Optional[str]                      # Error message if failed\n    total_entries: int                        # Total entries\n</code></pre>"},{"location":"api/models/#stringtabledata","title":"StringTableData","text":"<p>Single string table entry.</p> <pre><code>class StringTableData(BaseModel):\n    table_name: str         # Table name\n    index: int              # Entry index\n    key: str                # Entry key\n    value: Optional[str]    # Entry value (may be binary/base64)\n</code></pre>"},{"location":"api/models/#parser-info-model","title":"Parser Info Model","text":""},{"location":"api/models/#parserinfo","title":"ParserInfo","text":"<p>Parser state information.</p> <pre><code>class ParserInfo(BaseModel):\n    game_build: int           # Game build number\n    tick: int                 # Final parser tick\n    net_tick: int             # Final network tick\n    string_tables: List[str]  # List of string table names\n    entity_count: int         # Number of entities\n    success: bool             # Parse success flag\n    error: Optional[str]      # Error message if failed\n</code></pre> <p>Example: <pre><code>info = parser.get_parser_info(\"match.dem\")\n\nprint(f\"Game lasted {info.tick} ticks\")\nprint(f\"Final entity count: {info.entity_count}\")\nprint(f\"String tables: {', '.join(info.string_tables)}\")\n</code></pre></p>"},{"location":"api/models/#serialization","title":"Serialization","text":"<p>All models support Pydantic serialization:</p> <pre><code># To dictionary\ndata = model.model_dump()\n\n# To JSON string\njson_str = model.model_dump_json()\n\n# From dictionary\nmodel = HeaderInfo.model_validate(data)\n\n# From JSON\nmodel = HeaderInfo.model_validate_json(json_str)\n</code></pre>"},{"location":"api/parser/","title":"Parser","text":"AI Summary <p><code>Parser</code> is the main class for parsing Dota 2 replays. Create an instance with <code>Parser(\"match.dem\")</code> and call <code>parse()</code> with collectors like <code>header=True</code>, <code>game_info=True</code>, <code>messages={...}</code>. The parser supports single-pass collection of multiple data types. All methods return Pydantic models for type safety.</p>"},{"location":"api/parser/#constructor","title":"Constructor","text":"<pre><code>class Parser:\n    def __init__(self, demo_path: str, library_path: Optional[str] = None)\n</code></pre> <p>Creates a new parser instance for a specific demo file.</p> <p>Parameters: - <code>demo_path</code>: Path to the <code>.dem</code> replay file - <code>library_path</code> (optional): Path to the shared library. If not provided, uses the bundled library.</p> <p>Example: <pre><code>from python_manta import Parser\n\n# Create parser for a demo file\nparser = Parser(\"match.dem\")\n\n# Use custom library path\nparser = Parser(\"match.dem\", library_path=\"/path/to/libmanta_wrapper.so\")\n</code></pre></p>"},{"location":"api/parser/#main-method","title":"Main Method","text":""},{"location":"api/parser/#parse","title":"parse","text":"<pre><code>def parse(\n    self,\n    header: bool = False,\n    game_info: bool = False,\n    messages: Optional[Union[bool, Dict[str, Any]]] = None\n) -&gt; ParseResult\n</code></pre> <p>Parses the demo file with the specified collectors enabled.</p> <p>Parameters: - <code>header</code>: Enable header collector (match metadata) - <code>game_info</code>: Enable game info collector (draft, players, teams) - <code>messages</code>: Enable messages collector. Can be:   - <code>True</code> - collect all messages   - <code>{\"filter\": \"...\", \"max_messages\": N}</code> - filter and limit messages</p> <p>Returns: <code>ParseResult</code></p> <p>Example: <pre><code># Parse header only\nresult = parser.parse(header=True)\nprint(f\"Map: {result.header.map_name}\")\n\n# Parse multiple collectors in single pass\nresult = parser.parse(header=True, game_info=True)\nprint(f\"Map: {result.header.map_name}\")\nprint(f\"Match ID: {result.game_info.match_id}\")\n\n# Parse with message filtering\nresult = parser.parse(messages={\n    \"filter\": \"CDOTAUserMsg_ChatMessage\",\n    \"max_messages\": 100\n})\nfor msg in result.messages.messages:\n    print(f\"[{msg.tick}] {msg.data}\")\n</code></pre></p>"},{"location":"api/parser/#data-models","title":"Data Models","text":""},{"location":"api/parser/#parseresult","title":"ParseResult","text":"<p>The result returned by <code>parse()</code>.</p> <pre><code>class ParseResult(BaseModel):\n    success: bool\n    header: Optional[HeaderInfo] = None\n    game_info: Optional[GameInfo] = None\n    messages: Optional[MessagesResult] = None\n</code></pre> <p>Fields: - <code>success</code>: Whether parsing completed successfully - <code>header</code>: Header data if <code>header=True</code> was specified - <code>game_info</code>: Game info if <code>game_info=True</code> was specified - <code>messages</code>: Messages if <code>messages=...</code> was specified</p>"},{"location":"api/parser/#headerinfo","title":"HeaderInfo","text":"<p>Match metadata from the demo file header.</p> <pre><code>class HeaderInfo(BaseModel):\n    demo_file_stamp: str\n    network_protocol: int\n    server_name: str\n    client_name: str\n    map_name: str\n    game_directory: str\n    fullpackets_version: int\n    allow_clientside_entities: bool\n    allow_clientside_particles: bool\n    addons: str\n    demo_version_name: str\n    demo_version_guid: str\n    build_num: int\n    game: int\n    server_start_tick: int\n</code></pre> <p>Example: <pre><code>result = parser.parse(header=True)\nheader = result.header\n\nprint(f\"Map: {header.map_name}\")\nprint(f\"Server: {header.server_name}\")\nprint(f\"Build: {header.build_num}\")\n</code></pre></p>"},{"location":"api/parser/#gameinfo","title":"GameInfo","text":"<p>Complete game information including draft, players, and teams.</p> <pre><code>class GameInfo(BaseModel):\n    match_id: int = 0\n    game_mode: int = 0\n    game_winner: int = 0             # 2=Radiant, 3=Dire\n    league_id: int = 0               # Can be 0 even for pro matches!\n    end_time: int = 0                # Unix timestamp\n    radiant_team_id: int = 0\n    dire_team_id: int = 0\n    radiant_team_tag: str = \"\"\n    dire_team_tag: str = \"\"\n    players: List[PlayerInfo] = []\n    picks_bans: List[DraftEvent] = []\n    playback_time: float = 0.0       # Match duration in seconds\n    playback_ticks: int = 0\n    playback_frames: int = 0\n\n    def is_pro_match(self) -&gt; bool:\n        \"\"\"Check if this is a pro/league match.\"\"\"\n        ...\n</code></pre> <p>Helper Methods:</p> <ul> <li><code>is_pro_match()</code>: Returns <code>True</code> if this is a professional match. Checks <code>league_id &gt; 0</code> OR <code>radiant_team_id &gt; 0</code> OR <code>dire_team_id &gt; 0</code>. Use this instead of checking <code>league_id</code> directly, as some pro matches have <code>league_id=0</code> but valid team IDs.</li> </ul> <p>league_id can be 0 for pro matches</p> <p>Don't rely on <code>league_id &gt; 0</code> to detect pro matches. Some professional matches have <code>league_id=0</code> but valid <code>radiant_team_id</code> and <code>dire_team_id</code>. Always use <code>is_pro_match()</code> instead.</p> <p>Example: <pre><code>result = parser.parse(game_info=True)\ngame_info = result.game_info\n\nprint(f\"Match ID: {game_info.match_id}\")\nprint(f\"Winner: {'Radiant' if game_info.game_winner == 2 else 'Dire'}\")\n\n# Players (10 players: 5 Radiant + 5 Dire)\nfor player in game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"  {player.player_name} ({team}): {player.hero_name}\")\n\n# Draft\nfor event in game_info.picks_bans:\n    action = \"PICK\" if event.is_pick else \"BAN\"\n    team = \"Radiant\" if event.team == 2 else \"Dire\"\n    print(f\"{team} {action}: Hero {event.hero_id}\")\n\n# Pro match info (use is_pro_match() helper - works even when league_id is 0)\nif game_info.is_pro_match():\n    print(f\"{game_info.radiant_team_tag} vs {game_info.dire_team_tag}\")\n</code></pre></p>"},{"location":"api/parser/#draftevent","title":"DraftEvent","text":"<p>A single pick or ban event.</p> <pre><code>class DraftEvent(BaseModel):\n    is_pick: bool\n    team: int\n    hero_id: int\n</code></pre> <p>Fields: - <code>is_pick</code>: True for picks, False for bans - <code>team</code>: 2 for Radiant, 3 for Dire - <code>hero_id</code>: Dota 2 hero ID</p>"},{"location":"api/parser/#playerinfo","title":"PlayerInfo","text":"<p>Information about a player in the match.</p> <pre><code>class PlayerInfo(BaseModel):\n    player_name: str = \"\"\n    hero_name: str = \"\"       # npc_dota_hero_* format\n    is_fake_client: bool = False\n    steam_id: int = 0\n    team: int = 0             # 2=Radiant, 3=Dire\n</code></pre> <p>Fields: - <code>player_name</code>: Player's display name - <code>hero_name</code>: Hero in <code>npc_dota_hero_*</code> format (e.g., \"npc_dota_hero_axe\") - <code>is_fake_client</code>: True for bots - <code>steam_id</code>: Player's Steam ID (64-bit) - <code>team</code>: 2 for Radiant, 3 for Dire</p> <p>Example: <pre><code>result = parser.parse(game_info=True)\n\n# List all players with their heroes\nfor player in result.game_info.players:\n    team = \"Radiant\" if player.team == 2 else \"Dire\"\n    print(f\"{player.player_name} ({team}): {player.hero_name}\")\n    print(f\"  Steam ID: {player.steam_id}\")\n</code></pre></p>"},{"location":"api/parser/#messagesresult","title":"MessagesResult","text":"<p>Container for parsed messages.</p> <pre><code>class MessagesResult(BaseModel):\n    messages: List[MessageEvent] = []\n    total_captured: int = 0\n</code></pre>"},{"location":"api/parser/#messageevent","title":"MessageEvent","text":"<p>A single message event from the replay.</p> <pre><code>class MessageEvent(BaseModel):\n    type: str\n    tick: int\n    net_tick: int\n    data: Dict[str, Any]\n</code></pre> <p>Fields: - <code>type</code>: Message type name (e.g., \"CDOTAUserMsg_ChatMessage\") - <code>tick</code>: Game tick when message occurred - <code>net_tick</code>: Network tick - <code>data</code>: Message payload as dictionary</p>"},{"location":"api/parser/#message-filtering","title":"Message Filtering","text":"<p>The <code>messages</code> parameter accepts a dictionary with these options:</p> Key Type Description <code>filter</code> str Substring match for message types <code>max_messages</code> int Maximum messages to capture (0 = unlimited) <p>Filter Examples: <pre><code># Chat messages only\nresult = parser.parse(messages={\"filter\": \"CDOTAUserMsg_ChatMessage\"})\n\n# All ping-related messages\nresult = parser.parse(messages={\"filter\": \"Ping\"})\n\n# First 50 messages of any type\nresult = parser.parse(messages={\"max_messages\": 50})\n\n# All messages (use with caution - can be large)\nresult = parser.parse(messages=True)\n</code></pre></p> <p>Warning</p> <p>Some message types generate thousands of entries per match. Always use <code>max_messages</code> to prevent memory issues.</p>"},{"location":"api/parser/#complete-example","title":"Complete Example","text":"<pre><code>from python_manta import Parser, Hero\n\n# Create parser\nparser = Parser(\"match.dem\")\n\n# Parse everything in single pass\nresult = parser.parse(\n    header=True,\n    game_info=True,\n    messages={\"filter\": \"CDOTAUserMsg_ChatMessage\", \"max_messages\": 50}\n)\n\n# Access header\nprint(f\"Map: {result.header.map_name}\")\nprint(f\"Server: {result.header.server_name}\")\n\n# Access draft with Hero enum for readable names\nfor event in result.game_info.picks_bans:\n    if event.is_pick:\n        hero_name = Hero(event.hero_id).name\n        team = \"Radiant\" if event.team == 2 else \"Dire\"\n        print(f\"{team} picked {hero_name}\")\n\n# Access messages\nfor msg in result.messages.messages:\n    print(f\"[{msg.tick}] {msg.type}: {msg.data}\")\n</code></pre>"},{"location":"design/v2-architecture/","title":"Python Manta v2 Architecture","text":""},{"location":"design/v2-architecture/#overview","title":"Overview","text":"<p>This document describes the redesign of python_manta from a multi-pass parsing architecture to a single-pass, streaming-capable parser with seek support.</p>"},{"location":"design/v2-architecture/#key-principles","title":"Key Principles","text":""},{"location":"design/v2-architecture/#1-one-parse-all-data","title":"1. One Parse, All Data","text":"<p>The fundamental problem with v1 is that each <code>parse_*</code> method creates a new parser and reads the entire file. If you need 5 different data types, you parse the file 5 times.</p> <p>v2 Rule: Parse the file exactly once, collect all requested data in that single pass.</p>"},{"location":"design/v2-architecture/#2-manta-like-naming","title":"2. Manta-Like Naming","text":"<p>Follow the naming conventions of the upstream manta Go library: - <code>Parser</code> (not <code>MantaParser</code>, <code>DemoParser</code>, <code>UnifiedParser</code>) - <code>on_entity</code>, <code>on_combat_log</code> (like manta's <code>OnEntity</code>) - No prefixes like <code>unified_</code>, <code>enriched_</code>, <code>enhanced_</code></p>"},{"location":"design/v2-architecture/#3-pythonic-api","title":"3. Pythonic API","text":"<ul> <li>Decorators for callbacks</li> <li>Generators for streaming</li> <li>Context managers for resource handling</li> <li>Type hints everywhere</li> </ul>"},{"location":"design/v2-architecture/#4-no-legacy-support","title":"4. No Legacy Support","text":"<p>This is a clean break. The v1 architecture was wrong. No fallbacks, no compatibility layers.</p>"},{"location":"design/v2-architecture/#5-preserve-working-code","title":"5. Preserve Working Code","text":"<p>The parsing logic (callbacks, data extraction, string resolution) already works correctly. Reuse it, don't rewrite it. Only change how it's orchestrated.</p>"},{"location":"design/v2-architecture/#6-mirror-manta-structure","title":"6. Mirror Manta Structure","text":"<p>File structure should mirror dotabuff/manta for easy comparison and debugging.</p>"},{"location":"design/v2-architecture/#current-architecture-v1-problem","title":"Current Architecture (v1) - Problem","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User Code                                                       \u2502\n\u2502                                                                  \u2502\n\u2502  parser = MantaParser()                                          \u2502\n\u2502  header = parser.parse_header(\"demo.dem\")      \u2192 FULL PARSE     \u2502\n\u2502  info = parser.parse_game_info(\"demo.dem\")     \u2192 FULL PARSE     \u2502\n\u2502  combat = parser.parse_combat_log(\"demo.dem\")  \u2192 FULL PARSE     \u2502\n\u2502  entities = parser.parse_entities(\"demo.dem\")  \u2192 FULL PARSE     \u2502\n\u2502  messages = parser.parse_universal(\"demo.dem\") \u2192 FULL PARSE     \u2502\n\u2502                                                                  \u2502\n\u2502  5 method calls = 5 complete file parses                        \u2502\n\u2502  ~500MB file \u00d7 5 = 2.5GB of I/O for one analysis                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"design/v2-architecture/#why-this-happens","title":"Why This Happens","text":"<p>Each <code>Run*</code> function in Go: 1. Opens the file 2. Creates a new <code>manta.StreamParser</code> 3. Registers callbacks 4. Calls <code>parser.Start()</code> (full parse) 5. Returns result</p> <pre><code>// Current pattern (repeated for each data type)\nfunc RunCombatLogParse(filePath string, config CombatLogConfig) (*CombatLogResult, error) {\n    file, _ := os.Open(filePath)           // Opens file\n    parser, _ := manta.NewStreamParser(file) // Creates parser\n    // ... register callbacks ...\n    parser.Start()                          // FULL PARSE\n    return result, nil\n}\n</code></pre>"},{"location":"design/v2-architecture/#new-architecture-v2-solution","title":"New Architecture (v2) - Solution","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  User Code                                                       \u2502\n\u2502                                                                  \u2502\n\u2502  parser = Parser(\"demo.dem\")                                     \u2502\n\u2502  result = parser.parse(                                          \u2502\n\u2502      header=True,                                                \u2502\n\u2502      game_info=True,                                             \u2502\n\u2502      combat_log={\"types\": [4], \"heroes_only\": True},            \u2502\n\u2502      entities={\"interval\": 900},                                 \u2502\n\u2502      messages={\"filter\": \"ChatMessage\"},                         \u2502\n\u2502  )                                                               \u2502\n\u2502                                                                  \u2502\n\u2502  # Access all results from single parse                          \u2502\n\u2502  result.header.map_name                                          \u2502\n\u2502  result.game_info.match_id                                       \u2502\n\u2502  result.combat_log.entries                                       \u2502\n\u2502  result.entities.snapshots                                       \u2502\n\u2502  result.messages.items                                           \u2502\n\u2502                                                                  \u2502\n\u2502  1 method call = 1 parse = all data                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"design/v2-architecture/#layer-architecture","title":"Layer Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         Python Layer                             \u2502\n\u2502                                                                  \u2502\n\u2502   Parser                                                         \u2502\n\u2502   \u251c\u2500\u2500 __init__(path)      Create parser for file                \u2502\n\u2502   \u251c\u2500\u2500 parse(**opts)       Single-pass, return ParseResult       \u2502\n\u2502   \u251c\u2500\u2500 run()               Execute with registered callbacks      \u2502\n\u2502   \u251c\u2500\u2500 stream()            Generator yielding events              \u2502\n\u2502   \u251c\u2500\u2500 seek(tick/time)     Jump to position (requires index)     \u2502\n\u2502   \u251c\u2500\u2500 snapshot()          Get entity state at current position  \u2502\n\u2502   \u251c\u2500\u2500 build_index()       Create keyframes for seeking          \u2502\n\u2502   \u2502                                                              \u2502\n\u2502   \u2502  Callback decorators:                                        \u2502\n\u2502   \u251c\u2500\u2500 @on_combat_log      Combat log entries                     \u2502\n\u2502   \u251c\u2500\u2500 @on_entity          Entity updates                         \u2502\n\u2502   \u251c\u2500\u2500 @on_message         Protocol messages                      \u2502\n\u2502   \u2514\u2500\u2500 @on_game_event      Game events                            \u2502\n\u2502                                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                         CGO Bridge                               \u2502\n\u2502                                                                  \u2502\n\u2502   parser.go                                                      \u2502\n\u2502   \u251c\u2500\u2500 Parse(path, config)     Single-pass with config           \u2502\n\u2502   \u251c\u2500\u2500 Open(path) \u2192 handle     Open for streaming                \u2502\n\u2502   \u251c\u2500\u2500 Next(handle) \u2192 event    Get next event                    \u2502\n\u2502   \u251c\u2500\u2500 Snapshot(handle)        Get entity state                  \u2502\n\u2502   \u251c\u2500\u2500 Seek(handle, tick)      Jump to tick                      \u2502\n\u2502   \u251c\u2500\u2500 BuildIndex(handle)      Create keyframes                  \u2502\n\u2502   \u2514\u2500\u2500 Close(handle)           Cleanup                           \u2502\n\u2502                                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                         Manta Library                            \u2502\n\u2502                                                                  \u2502\n\u2502   github.com/dotabuff/manta                                      \u2502\n\u2502   \u251c\u2500\u2500 StreamParser            Sequential parsing                 \u2502\n\u2502   \u251c\u2500\u2500 Callbacks.On*()         Event registration                 \u2502\n\u2502   \u251c\u2500\u2500 OnEntity()              Entity state changes               \u2502\n\u2502   \u251c\u2500\u2500 OnGameEvent()           Game events                        \u2502\n\u2502   \u2514\u2500\u2500 LookupStringByIndex()   String table resolution            \u2502\n\u2502                                                                  \u2502\n\u2502   Note: Manta does NOT support seeking natively.                 \u2502\n\u2502   We must build our own keyframe index.                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"design/v2-architecture/#file-structure-mirroring-manta","title":"File Structure (Mirroring Manta)","text":""},{"location":"design/v2-architecture/#manta-go-library-structure","title":"Manta Go Library Structure","text":"<pre><code>github.com/dotabuff/manta/\n\u251c\u2500\u2500 parser.go           # Parser struct, NewStreamParser, Start, Stop\n\u251c\u2500\u2500 entity.go           # Entity struct and methods\n\u251c\u2500\u2500 callbacks.go        # All callback registrations (204KB!)\n\u251c\u2500\u2500 game_event.go       # GameEvent handling\n\u251c\u2500\u2500 string_table.go     # String table handling\n\u251c\u2500\u2500 modifier.go         # Modifier handling\n\u251c\u2500\u2500 field*.go           # Field handling (decoder, path, reader, state, type)\n\u251c\u2500\u2500 class.go            # Class handling\n\u251c\u2500\u2500 stream.go           # Stream reading\n\u2514\u2500\u2500 dota/               # Protobuf types\n</code></pre>"},{"location":"design/v2-architecture/#our-wrapper-structure-mirrors-manta","title":"Our Wrapper Structure (Mirrors Manta)","text":"<pre><code>go_wrapper/\n\u2502\n\u2502  # Core files (mirror manta naming)\n\u251c\u2500\u2500 parser.go           # Parse(), Open(), Next(), Seek(), Close()\n\u251c\u2500\u2500 entity.go           # Entity snapshot collection\n\u251c\u2500\u2500 callbacks.go        # Callback setup (consolidate existing callbacks_*.go)\n\u251c\u2500\u2500 game_event.go       # Game event collection\n\u251c\u2500\u2500 string_table.go     # String table collection\n\u251c\u2500\u2500 modifier.go         # Modifier collection\n\u251c\u2500\u2500 combat_log.go       # Combat log collection (Dota-specific, no manta equivalent)\n\u251c\u2500\u2500 stream.go           # Handle management for streaming API\n\u251c\u2500\u2500 index.go            # Keyframe indexing for seek (no manta equivalent)\n\u2502\n\u2502  # Support files\n\u251c\u2500\u2500 types.go            # Shared structs (ParseConfig, ParseResult, etc.)\n\u2514\u2500\u2500 util.go             # Helper functions\n\nsrc/python_manta/\n\u2502\n\u2502  # Core files (mirror manta naming)\n\u251c\u2500\u2500 parser.py           # Parser class\n\u251c\u2500\u2500 entity.py           # Entity types and helpers\n\u251c\u2500\u2500 game_event.py       # GameEvent types\n\u251c\u2500\u2500 string_table.py     # StringTable types\n\u251c\u2500\u2500 modifier.py         # Modifier types\n\u251c\u2500\u2500 combat_log.py       # CombatLog types (Dota-specific)\n\u2502\n\u2502  # Support files\n\u251c\u2500\u2500 types.py            # Shared Pydantic models\n\u251c\u2500\u2500 enums.py            # All enums\n\u2514\u2500\u2500 __init__.py         # Public exports\n</code></pre>"},{"location":"design/v2-architecture/#file-mapping-manta-our-wrapper","title":"File Mapping: Manta \u2192 Our Wrapper","text":"Manta File Our Go Wrapper Our Python Purpose <code>parser.go</code> <code>parser.go</code> <code>parser.py</code> Main parser, entry points <code>entity.go</code> <code>entity.go</code> <code>entity.py</code> Entity handling <code>callbacks.go</code> <code>callbacks.go</code> (decorators in parser.py) Callback registration <code>game_event.go</code> <code>game_event.go</code> <code>game_event.py</code> Game events <code>string_table.go</code> <code>string_table.go</code> <code>string_table.py</code> String tables <code>modifier.go</code> <code>modifier.go</code> <code>modifier.py</code> Modifiers/buffs (none) <code>combat_log.go</code> <code>combat_log.py</code> Combat log (Dota-specific) (none) <code>stream.go</code> (in parser.py) Streaming handle mgmt (none) <code>index.go</code> (in parser.py) Seek keyframes"},{"location":"design/v2-architecture/#api-design","title":"API Design","text":""},{"location":"design/v2-architecture/#1-single-pass-parsing","title":"1. Single-Pass Parsing","text":"<pre><code>from python_manta import Parser, CombatLogType\n\nparser = Parser(\"match.dem\")\n\n# Specify what you want, get everything in one parse\nresult = parser.parse(\n    header=True,\n    game_info=True,\n    combat_log={\n        \"types\": [CombatLogType.DEATH, CombatLogType.DAMAGE],\n        \"heroes_only\": True,\n        \"max\": 1000,\n    },\n    entities={\n        \"interval\": 900,  # Every 30 seconds\n        \"max\": 100,\n    },\n    messages={\n        \"filter\": \"ChatMessage\",\n        \"max\": 500,\n    },\n)\n\n# All data available\nprint(result.header.map_name)\nprint(result.game_info.match_id)\nprint(len(result.combat_log.entries))\n</code></pre>"},{"location":"design/v2-architecture/#2-callback-based-streaming","title":"2. Callback-Based Streaming","text":"<pre><code>parser = Parser(\"match.dem\")\n\n@parser.on_combat_log\ndef handle_combat(entry):\n    if entry.type == CombatLogType.DEATH:\n        print(f\"Kill: {entry.attacker_name} \u2192 {entry.target_name}\")\n\n@parser.on_entity(class_filter=\"Hero\")\ndef handle_hero(entity, tick):\n    print(f\"Hero {entity.class_name} at tick {tick}\")\n\n@parser.on_message(\"CDOTAUserMsg_ChatMessage\")\ndef handle_chat(msg):\n    print(f\"Chat: {msg.data}\")\n\n# Run - callbacks fire as data is encountered\nparser.run()\n</code></pre>"},{"location":"design/v2-architecture/#3-generator-streaming","title":"3. Generator Streaming","text":"<pre><code>parser = Parser(\"match.dem\")\n\nfor event in parser.stream():\n    match event.kind:\n        case \"combat_log\":\n            print(event.data.attacker_name)\n        case \"entity\":\n            print(event.data.class_name)\n        case \"message\":\n            print(event.data)\n</code></pre>"},{"location":"design/v2-architecture/#4-seek-support-phase-3","title":"4. Seek Support (Phase 3)","text":"<pre><code>parser = Parser(\"match.dem\")\nparser.build_index()  # One-time cost, creates keyframes\n\n# Jump to specific tick\nparser.seek(tick=50000)\nstate = parser.snapshot()\nprint(f\"Heroes at tick 50000: {state.heroes}\")\n\n# Jump by game time\nparser.seek(time=1200.0)  # 20:00 game time\n\n# Parse specific range\nresult = parser.parse(\n    start_tick=30000,\n    end_tick=60000,\n    combat_log=True,\n)\n</code></pre>"},{"location":"design/v2-architecture/#data-flow","title":"Data Flow","text":""},{"location":"design/v2-architecture/#single-pass-parse","title":"Single-Pass Parse","text":"<pre><code>User calls parser.parse(header=True, combat_log={...}, entities={...})\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Python: Build config JSON    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  CGO: Parse(path, configJSON) \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Go: Open file ONCE           \u2502\n                    \u2502  Go: Create parser ONCE       \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502  Register callbacks based on config:        \u2502\n              \u2502  \u251c\u2500\u2500 if header: OnCDemoFileHeader          \u2502\n              \u2502  \u251c\u2500\u2500 if game_info: OnCDemoFileInfo         \u2502\n              \u2502  \u251c\u2500\u2500 if combat_log: OnCMsgDOTACombatLogEntry\u2502\n              \u2502  \u251c\u2500\u2500 if entities: OnEntity                 \u2502\n              \u2502  \u2514\u2500\u2500 if messages: setupAllCallbacks        \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  parser.Start() - SINGLE PASS \u2502\n                    \u2502  All callbacks fire during    \u2502\n                    \u2502  this one traversal           \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Finalize: resolve strings,   \u2502\n                    \u2502  build result structs         \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                    \u2502\n                                    \u25bc\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Return JSON \u2192 ParseResult    \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"design/v2-architecture/#seek-implementation","title":"Seek Implementation","text":"<p>Manta (Go) does not support seeking. Demo files are sequential. To enable seeking:</p>"},{"location":"design/v2-architecture/#option-a-keyframe-index-recommended","title":"Option A: Keyframe Index (Recommended)","text":"<pre><code>First pass: Scan file, record positions of full-state packets\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Keyframe 0: tick=0,     offset=0,       game_time=-90.0   \u2502\n\u2502  Keyframe 1: tick=1800,  offset=124532,  game_time=0.0     \u2502\n\u2502  Keyframe 2: tick=3600,  offset=248104,  game_time=60.0    \u2502\n\u2502  Keyframe 3: tick=5400,  offset=371256,  game_time=120.0   \u2502\n\u2502  ...                                                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSeek to tick 5000:\n1. Find keyframe with tick &lt;= 5000 (Keyframe 2, tick=3600)\n2. Seek file to offset 248104\n3. Parse forward from tick 3600 to tick 5000\n4. Return state at tick 5000\n</code></pre>"},{"location":"design/v2-architecture/#option-b-full-state-snapshots-memory-heavy","title":"Option B: Full State Snapshots (Memory-heavy)","text":"<p>Save complete entity state at intervals. Seek = restore snapshot. Not recommended for large files due to memory usage.</p>"},{"location":"design/v2-architecture/#implementation-phases","title":"Implementation Phases","text":""},{"location":"design/v2-architecture/#phase-1-single-pass-parsing","title":"Phase 1: Single-Pass Parsing","text":"<p>Goal: Eliminate multi-parse problem</p> <ol> <li>Refactor Go: extract collector setup functions from existing <code>Run*</code> functions</li> <li>Add <code>parser.go</code> with <code>Parse()</code> that reuses collectors</li> <li>Add Python <code>Parser</code> class with <code>parse()</code> method</li> <li>Add tests for new API</li> <li>Verify existing tests still pass</li> </ol> <p>Result: <code>parser.parse(header=True, combat_log=True, entities=True)</code> works</p>"},{"location":"design/v2-architecture/#phase-2-streaming-support","title":"Phase 2: Streaming Support","text":"<p>Goal: Enable callback and generator patterns</p> <ol> <li>Add <code>stream.go</code> with handle management</li> <li>Add <code>Open()</code>, <code>Next()</code>, <code>Close()</code> to Go</li> <li>Add <code>run()</code> and <code>stream()</code> to Python Parser</li> <li>Add callback decorator support</li> </ol> <p>Result: <code>parser.run()</code> with <code>@parser.on_combat_log</code> works</p>"},{"location":"design/v2-architecture/#phase-3-seek-support","title":"Phase 3: Seek Support","text":"<p>Goal: Enable jumping to specific ticks</p> <ol> <li>Add <code>index.go</code> with keyframe building</li> <li>Add <code>BuildIndex()</code>, <code>Seek()</code>, <code>Snapshot()</code> to Go</li> <li>Add <code>build_index()</code>, <code>seek()</code>, <code>snapshot()</code> to Python</li> </ol> <p>Result: <code>parser.seek(tick=50000)</code> works</p>"},{"location":"design/v2-architecture/#phase-4-cleanup-documentation","title":"Phase 4: Cleanup &amp; Documentation","text":"<p>Goal: Remove legacy code, update all docs</p> <ol> <li>Migrate all tests to new API</li> <li>Update all documentation</li> <li>Remove old <code>MantaParser</code> class</li> <li>Remove old <code>Parse*</code> Go functions</li> <li>Consolidate Go files to match manta structure</li> </ol>"},{"location":"design/v2-architecture/#documentation-updates-required","title":"Documentation Updates Required","text":""},{"location":"design/v2-architecture/#files-to-update","title":"Files to Update","text":"File Changes <code>docs/index.md</code> Update overview, quick start examples <code>docs/getting-started.md</code> Rewrite for new <code>Parser</code> API <code>docs/examples.md</code> Rewrite all examples for single-pass <code>docs/api/manta-parser.md</code> DELETE - Replace with <code>docs/api/parser.md</code> <code>docs/api/parser.md</code> NEW - Document <code>Parser</code> class <code>docs/api/models.md</code> Update model references <code>docs/api/index.md</code> Update API overview <code>docs/guides/combat-log.md</code> Update for new API <code>docs/guides/entities.md</code> Update for new API <code>docs/guides/game-events.md</code> Update for new API <code>docs/guides/modifiers.md</code> Update for new API <code>docs/guides/universal.md</code> Update for streaming/messages <code>docs/guides/unit-orders.md</code> Update for new API <code>docs/guides/index.md</code> Update guide overview <code>docs/reference/callbacks.md</code> Update callback registration <code>docs/reference/combat-log.md</code> Update types reference <code>docs/reference/entities.md</code> Update types reference <code>docs/reference/game-events.md</code> Update types reference <code>docs/reference/modifiers.md</code> Update types reference <code>docs/reference/string-tables.md</code> Update types reference <code>docs/reference/index.md</code> Update reference overview <code>README.md</code> Update quick start, examples <code>CLAUDE.md</code> Update API quick reference"},{"location":"design/v2-architecture/#new-documentation-files","title":"New Documentation Files","text":"File Purpose <code>docs/guides/streaming.md</code> NEW - Streaming with callbacks/generators <code>docs/guides/seeking.md</code> NEW - Seek and range parsing <code>docs/api/parser.md</code> NEW - Parser class reference <code>docs/design/v2-architecture.md</code> This document"},{"location":"design/v2-architecture/#documentation-structure-after-update","title":"Documentation Structure After Update","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md                    # Overview, installation\n\u251c\u2500\u2500 getting-started.md          # Quick start with new API\n\u251c\u2500\u2500 examples.md                 # Complete examples\n\u2502\n\u251c\u2500\u2500 api/\n\u2502   \u251c\u2500\u2500 index.md               # API overview\n\u2502   \u251c\u2500\u2500 parser.md              # NEW: Parser class reference\n\u2502   \u2514\u2500\u2500 models.md              # Pydantic models reference\n\u2502\n\u251c\u2500\u2500 guides/\n\u2502   \u251c\u2500\u2500 index.md               # Guides overview\n\u2502   \u251c\u2500\u2500 combat-log.md          # Combat log guide\n\u2502   \u251c\u2500\u2500 entities.md            # Entity tracking guide\n\u2502   \u251c\u2500\u2500 game-events.md         # Game events guide\n\u2502   \u251c\u2500\u2500 modifiers.md           # Modifiers guide\n\u2502   \u251c\u2500\u2500 streaming.md           # NEW: Streaming guide\n\u2502   \u2514\u2500\u2500 seeking.md             # NEW: Seek/range guide\n\u2502\n\u251c\u2500\u2500 reference/\n\u2502   \u251c\u2500\u2500 index.md               # Reference overview\n\u2502   \u251c\u2500\u2500 callbacks.md           # All 272 callbacks\n\u2502   \u251c\u2500\u2500 combat-log.md          # Combat log types\n\u2502   \u251c\u2500\u2500 entities.md            # Entity types\n\u2502   \u251c\u2500\u2500 game-events.md         # 364 game event types\n\u2502   \u251c\u2500\u2500 modifiers.md           # Modifier types\n\u2502   \u2514\u2500\u2500 string-tables.md       # String table reference\n\u2502\n\u2514\u2500\u2500 design/\n    \u2514\u2500\u2500 v2-architecture.md     # This document\n</code></pre>"},{"location":"design/v2-architecture/#caveats-and-considerations","title":"Caveats and Considerations","text":""},{"location":"design/v2-architecture/#1-callback-conflicts","title":"1. Callback Conflicts","text":"<p>When multiple collectors register the same callback (e.g., both combat_log and messages want <code>OnCMsgDOTACombatLogEntry</code>), we need to handle this gracefully. Solution: Each collector adds to a shared list, callbacks dispatch to all registered handlers.</p>"},{"location":"design/v2-architecture/#2-memory-usage","title":"2. Memory Usage","text":"<p>Collecting all data types simultaneously uses more memory than parsing one at a time. For very large replays with all collectors enabled, memory could be significant. Consider adding a <code>low_memory</code> mode that streams to disk.</p>"},{"location":"design/v2-architecture/#3-streaming-vs-batch","title":"3. Streaming vs Batch","text":"<p>The <code>parse()</code> method (batch) and <code>stream()</code> method (streaming) are mutually exclusive. You can't call both on the same parser instance. This is by design - they're different paradigms.</p>"},{"location":"design/v2-architecture/#4-seek-limitations","title":"4. Seek Limitations","text":"<ul> <li>Seeking requires an index (built on first pass or explicitly)</li> <li>Seeking to an arbitrary tick may require parsing forward from a keyframe</li> <li>Entity state at a tick requires parsing up to that tick (can't jump directly)</li> </ul>"},{"location":"design/v2-architecture/#5-thread-safety","title":"5. Thread Safety","text":"<p>Parser instances are NOT thread-safe. Don't share across threads. Create separate parsers per thread if needed.</p>"},{"location":"design/v2-architecture/#6-error-handling","title":"6. Error Handling","text":"<p>Following project principles: fail fast, no fallbacks. If parsing fails, the error propagates immediately. No partial results, no silent failures.</p>"},{"location":"design/v2-architecture/#migration-path","title":"Migration Path","text":"<pre><code># v1 (old) - 5 parses\nparser = MantaParser()\nh = parser.parse_header(\"demo.dem\")\ng = parser.parse_game_info(\"demo.dem\")\nc = parser.parse_combat_log(\"demo.dem\")\ne = parser.parse_entities(\"demo.dem\")\nm = parser.parse_universal(\"demo.dem\", \"Chat\")\n\n# v2 (new) - 1 parse\nparser = Parser(\"demo.dem\")\nresult = parser.parse(\n    header=True,\n    game_info=True,\n    combat_log=True,\n    entities=True,\n    messages={\"filter\": \"Chat\"},\n)\n# result.header, result.game_info, result.combat_log, etc.\n</code></pre>"},{"location":"design/v2-architecture/#performance-comparison","title":"Performance Comparison","text":"Scenario v1 (current) v2 (new) Improvement Header only 1 parse 1 parse Same Header + game_info 2 parses 1 parse 2\u00d7 Full analysis (5 types) 5 parses 1 parse 5\u00d7 Streaming with callbacks Not possible 1 parse \u221e Seek to specific tick Full parse Partial parse Variable"},{"location":"design/v2-architecture/#references","title":"References","text":"<ul> <li>dotabuff/manta - Go library we wrap</li> <li>Clarity - Java parser with seek support (inspiration for Phase 3)</li> <li>CLAUDE.md - Project principles and guidelines</li> </ul>"},{"location":"design/v2-architecture/#known-issues-future-improvements","title":"Known Issues &amp; Future Improvements","text":"<p>Issues discovered during v2 refactor that should be addressed in future iterations:</p>"},{"location":"design/v2-architecture/#phase-3-indexseek-issues","title":"Phase 3: Index/Seek Issues","text":"<ol> <li>~~<code>game_time</code> always 0.0 in keyframes and snapshots~~ \u2705 FIXED</li> <li>File: <code>go_wrapper/index.go</code></li> <li>Solution: Calculate game_time from <code>(currentTick - gameStartTick) / ticksPerSecond</code> instead of trying to read <code>m_fGameTime</code></li> <li> <p>Keyframes and snapshots now show correct game_time values</p> </li> <li> <p>~~Snapshot captures too many hero entities (includes illusions/clones)~~ \u2705 FIXED</p> </li> <li>File: <code>go_wrapper/index.go</code> - <code>getEntitySnapshot()</code></li> <li>Solution: Use <code>m_hSelectedHero</code> handle from <code>CDOTA_PlayerResource</code> to link players to heroes</li> <li>Heroes are now matched by entity index from <code>playerResource.GetUint64(\"m_vecPlayerTeamData.XXXX.m_hSelectedHero\")</code></li> <li>Snapshots now return exactly 10 heroes (one per player)</li> <li> <p>Enhancement: Added <code>include_illusions</code> parameter to <code>snapshot()</code> method</p> <ul> <li>When <code>True</code>: Returns all hero entities including illusions and clones</li> <li>Each hero has <code>is_illusion</code> and <code>is_clone</code> flags</li> <li>Clones (e.g., Monkey King ultimate) have <code>is_clone=True</code></li> <li>Illusions (e.g., Naga Siren, PL) have <code>is_illusion=True</code></li> </ul> </li> <li> <p>~~Combat log string indices not resolved in <code>parse_range()</code>~~ \u2705 FIXED</p> </li> <li>File: <code>go_wrapper/index.go</code> - <code>parseRange()</code></li> <li>Solution: Added <code>parser.LookupStringByIndex(\"CombatLogNames\", int32(idx))</code> to resolve names</li> <li>Combat log entries now show proper names like <code>npc_dota_hero_chen</code> instead of numeric indices</li> </ol>"},{"location":"design/v2-architecture/#phase-2-streaming-issues","title":"Phase 2: Streaming Issues","text":"<ol> <li>Stream sometimes returns events with no data</li> <li>File: <code>go_wrapper/stream.go</code></li> <li>When channel is empty but not done, returns empty event</li> <li>Currently handled with <code>time.sleep(0.001)</code> in Python, not ideal</li> <li> <p>Fix: Consider blocking read with timeout instead of polling</p> </li> <li> <p>No graceful handling of parser errors in streaming mode</p> </li> <li>File: <code>go_wrapper/stream.go</code></li> <li>If parser.Start() fails, error is stored but not immediately communicated</li> <li>Fix: Send error event through channel before closing</li> </ol>"},{"location":"design/v2-architecture/#phase-1-parse-issues","title":"Phase 1: Parse Issues","text":"<ol> <li>Memory leak from C.CString allocations</li> <li>File: All Go files using <code>C.CString()</code></li> <li><code>FreeString</code> exists but Python doesn't call it (commented out to avoid crashes)</li> <li>Minor leak per parse call</li> <li>Fix: Investigate why FreeString causes issues, properly manage CGO memory</li> </ol>"},{"location":"design/v2-architecture/#general-issues","title":"General Issues","text":"<ol> <li>Callback decorator API (<code>@parser.on_combat_log</code>) not implemented</li> <li>Mentioned in design doc but not yet implemented</li> <li>Currently only <code>stream()</code> generator is available for streaming</li> <li> <p>Fix: Phase 2 enhancement - add decorator-based callback registration</p> </li> <li> <p>No <code>run()</code> method on Parser class</p> </li> <li>Design doc mentions <code>parser.run()</code> with callbacks but not implemented</li> <li> <p>Fix: Add when callback decorators are implemented</p> </li> <li> <p>Entity state in build_index doesn't track all entities</p> </li> <li>Only heroes are tracked in <code>GetSnapshot()</code></li> <li>Buildings, wards, couriers, etc. not included</li> <li> <p>Fix: Add optional entity type filters to snapshot config</p> </li> <li> <p>RangeParseConfig uses snake_case but Go expects different field names</p> <ul> <li>File: <code>go_wrapper/index.go</code> vs <code>manta_python.py</code></li> <li>Pydantic aliases may be needed for proper JSON marshaling</li> <li>Fix: Verify field names match between Python and Go</li> </ul> </li> </ol>"},{"location":"design/v2-architecture/#testing-gaps","title":"Testing Gaps","text":"<ol> <li> <p>~~No unit tests for index/seek functionality~~ \u2705 FIXED</p> <ul> <li><code>tests/test_v2_parser.py</code> now includes <code>TestV2ParserIndexSeekFunctionality</code> and <code>TestV2ParserIndexSeekEdgeCases</code></li> <li>17 new tests covering <code>build_index()</code>, <code>snapshot()</code>, <code>find_keyframe()</code>, and <code>parse_range()</code></li> </ul> </li> <li> <p>Integration tests for streaming are minimal</p> <ul> <li>Only basic stream tests exist</li> <li>Fix: Add comprehensive streaming tests with real data validation</li> </ul> </li> </ol>"},{"location":"guides/","title":"Guides","text":"AI Summary <p>In-depth guides for using Python Manta's features. Covers game events parsing (364 event types like kills, damage, abilities), combat log analysis (structured damage/heal/death data), entity queries (hero stats, positions, items), and modifier tracking (buffs, debuffs, auras). Each guide includes practical examples and common use cases.</p>"},{"location":"guides/#available-guides","title":"Available Guides","text":"Guide Description MCP Use Cases Teamfight, farm tracking, gank, objective, laning analysis Unit Orders Detect attack commands, creep aggro triggers, and player inputs Game Events Parse 364 Source 1 game event types Combat Log Analyze damage, heals, deaths, and kills Entity Queries Query hero/unit state and properties Modifiers Track buffs, debuffs, and auras Universal Messages Parse any of 272 message callbacks"},{"location":"guides/#choosing-the-right-api","title":"Choosing the Right API","text":"What You Need API Guide Match metadata <code>parse_header()</code> Getting Started Draft picks/bans <code>parse_game_info()</code> Getting Started Hero positions over time <code>parse_entities(target_ticks=[...])</code> Entities Death positions <code>parse_entities(target_ticks=[death.tick])</code> Entities Creep aggro triggers <code>parse_universal(\"SpectatorPlayerUnitOrders\")</code> Unit Orders Attack commands <code>parse_universal(\"SpectatorPlayerUnitOrders\")</code> Unit Orders Chat messages <code>parse_universal(\"CDOTAUserMsg_ChatMessage\")</code> Universal Item purchases <code>parse_universal(\"CDOTAUserMsg_ItemPurchased\")</code> Universal Map pings <code>parse_universal(\"CDOTAUserMsg_LocationPing\")</code> Universal Damage dealt <code>parse_combat_log(types=[0])</code> Combat Log Deaths/kills <code>parse_combat_log(types=[4])</code> Combat Log Hero state (end of game) <code>query_entities(class_filter=\"Hero\")</code> Entities Buff tracking <code>parse_modifiers()</code> Modifiers Kill events <code>parse_game_events(event_filter=\"dota_player_kill\")</code> Game Events Rune pickups <code>parse_game_events(event_filter=\"dota_rune\")</code> Game Events Player info <code>get_string_tables(table_names=[\"userinfo\"])</code> API Reference"},{"location":"guides/combat-log/","title":"Combat Log Guide","text":"AI Summary <p>Parse structured combat log entries with <code>parse_combat_log()</code>. Use <code>CombatLogType</code> enum for filtering (DAMAGE, HEAL, MODIFIER_ADD, DEATH, ABILITY, ITEM, PURCHASE, etc.). 80+ fields per entry including health tracking, stun/slow durations, assist players, damage types, hero levels, and location. Use <code>heroes_only=True</code> for hero-related entries. Additional enums: <code>DamageType</code> (PHYSICAL, MAGICAL, PURE), <code>Team</code> (RADIANT, DIRE). The <code>game_time</code> field provides accurate in-game clock time (can be negative for pre-game events). The <code>value_name</code> field resolves item names for PURCHASE events.</p>"},{"location":"guides/combat-log/#overview","title":"Overview","text":"<p>The combat log provides structured data about damage, healing, deaths, and other combat-related events with rich metadata.</p> <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"max_entries\": 100})\n\nfor entry in result.combat_log.entries:\n    print(f\"[{entry.game_time_str}] {entry.type_name}: {entry.attacker_name} -&gt; {entry.target_name}\")\n</code></pre>"},{"location":"guides/combat-log/#combat-log-types","title":"Combat Log Types","text":"ID Type Name Description 0 DOTA_COMBATLOG_DAMAGE Damage dealt to units 1 DOTA_COMBATLOG_HEAL Healing received 2 DOTA_COMBATLOG_MODIFIER_ADD Buff/debuff applied 3 DOTA_COMBATLOG_MODIFIER_REMOVE Buff/debuff removed 4 DOTA_COMBATLOG_DEATH Unit death 5 DOTA_COMBATLOG_ABILITY Ability cast 6 DOTA_COMBATLOG_ITEM Item used 7 DOTA_COMBATLOG_LOCATION Location event 8 DOTA_COMBATLOG_GOLD Gold gained 9 DOTA_COMBATLOG_GAME_STATE Game state change 10 DOTA_COMBATLOG_XP Experience gained 11 DOTA_COMBATLOG_PURCHASE Item purchased 12 DOTA_COMBATLOG_BUYBACK Buyback used 13 DOTA_COMBATLOG_ABILITY_TRIGGER Ability triggered 14 DOTA_COMBATLOG_PLAYERSTATS Player statistics 15 DOTA_COMBATLOG_MULTIKILL Multi-kill event 16 DOTA_COMBATLOG_KILLSTREAK Kill streak 17 DOTA_COMBATLOG_TEAM_BUILDING_KILL Building destroyed 18 DOTA_COMBATLOG_FIRST_BLOOD First blood 19 DOTA_COMBATLOG_MODIFIER_REFRESH Modifier refreshed 20 DOTA_COMBATLOG_NEUTRAL_CAMP_STACK Camp stacked 21 DOTA_COMBATLOG_PICKUP_RUNE Rune picked up 22 DOTA_COMBATLOG_REVEALED_INVISIBLE Invisibility revealed 23 DOTA_COMBATLOG_HERO_SAVED Hero saved from death 24 DOTA_COMBATLOG_MANA_RESTORED Mana restored 25 DOTA_COMBATLOG_HERO_LEVELUP Hero level up 26 DOTA_COMBATLOG_BOTTLE_HEAL_ALLY Bottle heal ally 27 DOTA_COMBATLOG_ENDGAME_STATS End game statistics 28 DOTA_COMBATLOG_INTERRUPT_CHANNEL Channel interrupted 29 DOTA_COMBATLOG_ALLIED_GOLD Allied gold 30 DOTA_COMBATLOG_AEGIS_TAKEN Aegis taken 31 DOTA_COMBATLOG_MANA_DAMAGE Mana burned 32 DOTA_COMBATLOG_PHYSICAL_DAMAGE_PREVENTED Physical damage blocked 33 DOTA_COMBATLOG_UNIT_SUMMONED Unit summoned 34 DOTA_COMBATLOG_ATTACK_EVADE Attack evaded 35 DOTA_COMBATLOG_TREE_CUT Tree cut 36 DOTA_COMBATLOG_SUCCESSFUL_SCAN Successful scan 37 DOTA_COMBATLOG_END_KILLSTREAK Kill streak ended 38 DOTA_COMBATLOG_BLOODSTONE_CHARGE Bloodstone charge 39 DOTA_COMBATLOG_CRITICAL_DAMAGE Critical damage 40 DOTA_COMBATLOG_SPELL_ABSORB Spell absorbed 41 DOTA_COMBATLOG_UNIT_TELEPORTED Unit teleported 42 DOTA_COMBATLOG_KILL_EATER_EVENT Kill eater (gem) event 43 DOTA_COMBATLOG_NEUTRAL_ITEM_EARNED Neutral item earned 44 DOTA_COMBATLOG_TELEPORT_INTERRUPTED Teleport interrupted"},{"location":"guides/combat-log/#filtering-by-type","title":"Filtering by Type","text":""},{"location":"guides/combat-log/#damage-only","title":"Damage Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[0], max_entries=500)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.attacker_name} dealt {entry.value} damage to {entry.target_name}\")\n    if entry.inflictor_name:\n        print(f\"  via {entry.inflictor_name}\")\n</code></pre>"},{"location":"guides/combat-log/#healing-only","title":"Healing Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=200)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.target_name} healed for {entry.value}\")\n    if entry.inflictor_name:\n        print(f\"  from {entry.inflictor_name}\")\n</code></pre>"},{"location":"guides/combat-log/#deaths-only","title":"Deaths Only","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[4], max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.target_name} was killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"guides/combat-log/#multiple-types","title":"Multiple Types","text":"<pre><code># Damage and deaths together\nresult = parser.parse_combat_log(\"match.dem\", types=[0, 4], max_entries=500)\n\nfor entry in result.entries:\n    if entry.type == 0:\n        print(f\"[{entry.game_time_str}] DAMAGE: {entry.attacker_name} -&gt; {entry.target_name} ({entry.value})\")\n    elif entry.type == 4:\n        print(f\"[{entry.game_time_str}] DEATH: {entry.target_name} killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"guides/combat-log/#hero-only-filtering","title":"Hero-Only Filtering","text":"<p>Filter to only include entries where the attacker or target is a hero:</p> <pre><code>result = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\n\nfor entry in result.entries:\n    hero_indicator = \"\"\n    if entry.is_attacker_hero:\n        hero_indicator += \"[HERO ATK] \"\n    if entry.is_target_hero:\n        hero_indicator += \"[HERO TGT] \"\n\n    print(f\"{hero_indicator}{entry.attacker_name} -&gt; {entry.target_name}\")\n</code></pre>"},{"location":"guides/combat-log/#combining-filters","title":"Combining Filters","text":"<pre><code># Hero damage only\nresult = parser.parse_combat_log(\n    \"match.dem\",\n    types=[0],           # Damage\n    heroes_only=True,    # Hero involvement\n    max_entries=500\n)\n</code></pre>"},{"location":"guides/combat-log/#entry-fields-80-total","title":"Entry Fields (80+ Total)","text":"<p>Each <code>CombatLogEntry</code> contains comprehensive data for fight analysis:</p>"},{"location":"guides/combat-log/#core-fields","title":"Core Fields","text":"Field Type Description <code>tick</code> int Game tick (~30/second) <code>net_tick</code> int Network tick <code>type</code> int Combat log type ID (0-44) <code>type_name</code> str Human-readable type name <code>game_time</code> float Game time in seconds (0:00 = horn, negative for pre-game) <code>game_time_str</code> str Formatted game time (e.g., \"-0:40\", \"5:32\")"},{"location":"guides/combat-log/#participant-fields","title":"Participant Fields","text":"Field Type Description <code>target_name</code> str Target unit name (e.g., \"npc_dota_hero_pudge\") <code>target_source_name</code> str Target's source name <code>attacker_name</code> str Attacker unit name <code>damage_source_name</code> str Damage source name <code>inflictor_name</code> str Ability/item that caused this"},{"location":"guides/combat-log/#participant-flags","title":"Participant Flags","text":"Field Type Description <code>is_attacker_illusion</code> bool Attacker is an illusion <code>is_attacker_hero</code> bool Attacker is a hero <code>is_target_illusion</code> bool Target is an illusion <code>is_target_hero</code> bool Target is a hero <code>is_target_building</code> bool Target is a building"},{"location":"guides/combat-log/#combat-values","title":"Combat Values","text":"Field Type Description <code>value</code> int Damage/heal amount (or string table index for PURCHASE events) <code>value_name</code> str Resolved name from CombatLogNames (e.g., item name for PURCHASE) <code>health</code> int Target HP after this event <code>damage_type</code> int Damage type (physical/magical/pure) <code>damage_category</code> int Damage category"},{"location":"guides/combat-log/#cc-durations","title":"CC Durations","text":"Field Type Description <code>stun_duration</code> float Stun duration in seconds <code>slow_duration</code> float Slow duration in seconds <code>modifier_duration</code> float Total modifier duration <code>modifier_elapsed_duration</code> float How long modifier has been active"},{"location":"guides/combat-log/#location","title":"Location","text":"Field Type Description <code>location_x</code> float X coordinate on map <code>location_y</code> float Y coordinate on map"},{"location":"guides/combat-log/#assist-tracking","title":"Assist Tracking","text":"Field Type Description <code>assist_player0</code> int First assist player ID <code>assist_player1</code> int Second assist player ID <code>assist_player2</code> int Third assist player ID <code>assist_player3</code> int Fourth assist player ID <code>assist_players</code> List[int] All assist player IDs"},{"location":"guides/combat-log/#modifier-fields","title":"Modifier Fields","text":"Field Type Description <code>root_modifier</code> bool Is a root effect <code>silence_modifier</code> bool Is a silence effect <code>aura_modifier</code> bool Is an aura <code>armor_debuff_modifier</code> bool Is armor reduction <code>motion_controller_modifier</code> bool Is motion control (knockback) <code>invisibility_modifier</code> bool Grants invisibility <code>hidden_modifier</code> bool Is hidden modifier <code>modifier_hidden</code> bool Modifier is hidden from UI <code>modifier_purged</code> bool Modifier was purged <code>no_physical_damage_modifier</code> bool Blocks physical damage <code>modifier_ability</code> int Ability index in CombatLogNames <code>modifier_ability_name</code> str Resolved ability name that applied this modifier <code>modifier_purge_ability</code> int Ability index that purged this modifier <code>modifier_purge_ability_name</code> str Resolved ability name that purged this modifier <code>modifier_purge_npc</code> int NPC index that purged this modifier <code>modifier_purge_npc_name</code> str Resolved NPC name that purged this modifier"},{"location":"guides/combat-log/#ability-info","title":"Ability Info","text":"Field Type Description <code>ability_level</code> int Ability level (1-4+) <code>is_ability_toggle_on</code> bool Ability toggled on <code>is_ability_toggle_off</code> bool Ability toggled off <code>is_ultimate_ability</code> bool Is an ultimate ability <code>inflictor_is_stolen_ability</code> bool Ability was stolen (Rubick) <code>spell_generated_attack</code> bool Attack from spell <code>uses_charges</code> bool Ability uses charges"},{"location":"guides/combat-log/#killdeath-info","title":"Kill/Death Info","text":"Field Type Description <code>spell_evaded</code> bool Spell was evaded <code>long_range_kill</code> bool Long range kill <code>will_reincarnate</code> bool Target will reincarnate (Aegis/WK) <code>total_unit_death_count</code> int Total deaths of this unit type <code>heal_from_lifesteal</code> bool Heal is from lifesteal <code>is_heal_save</code> bool Heal prevented death"},{"location":"guides/combat-log/#hero-state","title":"Hero State","text":"Field Type Description <code>attacker_hero_level</code> int Attacker's hero level (from entity state) <code>target_hero_level</code> int Target's hero level (from entity state) <code>attacker_has_scepter</code> bool Attacker has Aghanim's Scepter <code>attacker_team</code> int Attacker team (2=Radiant, 3=Dire) <code>target_team</code> int Target team <p>Hero Levels Now Available</p> <p>As of v1.4.5.4, <code>attacker_hero_level</code> and <code>target_hero_level</code> are populated from entity state during parsing. Previously these were always 0 (Dota 2's protobuf doesn't populate them), but we now inject levels from <code>m_iCurrentLevel</code> entity property.</p> <ul> <li>100% of hero deaths have <code>target_hero_level</code> populated</li> <li>94%+ have <code>attacker_hero_level</code> (non-hero attackers like summons/neutrals are 0)</li> </ul>"},{"location":"guides/combat-log/#visibility","title":"Visibility","text":"Field Type Description <code>is_visible_radiant</code> bool Visible to Radiant team <code>is_visible_dire</code> bool Visible to Dire team <code>at_night_time</code> bool Event occurred at night"},{"location":"guides/combat-log/#economy","title":"Economy","text":"Field Type Description <code>xp</code> int XP gained/reason <code>gold</code> int Gold gained/reason <code>last_hits</code> int Last hits at time <code>networth</code> int Player networth <code>xpm</code> int XP per minute <code>gpm</code> int Gold per minute"},{"location":"guides/combat-log/#additional","title":"Additional","text":"Field Type Description <code>stack_count</code> int Modifier stack count <code>building_type</code> int Building type ID <code>neutral_camp_type</code> int Neutral camp type <code>neutral_camp_team</code> int Neutral camp team <code>rune_type</code> int Rune type <code>obs_wards_placed</code> int Observer wards placed <code>regenerated_health</code> float Health regenerated <code>target_is_self</code> bool Target is self"},{"location":"guides/combat-log/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/combat-log/#dps-analysis","title":"DPS Analysis","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=5000)\n\ndamage_dealt = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.is_attacker_hero:\n        damage_dealt[entry.attacker_name] += entry.value\n\nprint(\"Total Damage Dealt by Hero:\")\nfor hero, damage in sorted(damage_dealt.items(), key=lambda x: -x[1]):\n    print(f\"  {hero}: {damage:,}\")\n</code></pre>"},{"location":"guides/combat-log/#kill-feed-reconstruction","title":"Kill Feed Reconstruction","text":"<pre><code>parser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [4], \"heroes_only\": True, \"max_entries\": 100})\n\nprint(\"Kill Feed:\")\nprint(\"-\" * 60)\n\nfor entry in result.combat_log.entries:\n    # Hero levels are now populated from entity state\n    attacker_lvl = f\" (lvl {entry.attacker_hero_level})\" if entry.attacker_hero_level &gt; 0 else \"\"\n    target_lvl = f\" (lvl {entry.target_hero_level})\" if entry.target_hero_level &gt; 0 else \"\"\n    print(f\"[{entry.game_time_str}] {entry.attacker_name}{attacker_lvl} killed {entry.target_name}{target_lvl}\")\n</code></pre> <p>Output: <pre><code>Kill Feed:\n------------------------------------------------------------\n[00:10] npc_dota_hero_pugna (lvl 1) killed npc_dota_hero_troll_warlord (lvl 1)\n[03:36] npc_dota_hero_pugna (lvl 2) killed npc_dota_hero_hoodwink (lvl 2)\n[05:09] npc_dota_hero_bristleback (lvl 3) killed npc_dota_hero_pugna (lvl 3)\n</code></pre></p>"},{"location":"guides/combat-log/#ability-usage-tracking","title":"Ability Usage Tracking","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[5], max_entries=1000)\n\nability_usage = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.inflictor_name:\n        ability_usage[entry.inflictor_name] += 1\n\nprint(\"Most Used Abilities:\")\nfor ability, count in sorted(ability_usage.items(), key=lambda x: -x[1])[:20]:\n    print(f\"  {ability}: {count}\")\n</code></pre>"},{"location":"guides/combat-log/#gold-economy","title":"Gold Economy","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[7], max_entries=2000)\n\ngold_gained = defaultdict(int)\n\nfor entry in result.entries:\n    if entry.is_target_hero:\n        gold_gained[entry.target_name] += entry.gold\n\nprint(\"Gold Gained:\")\nfor hero, gold in sorted(gold_gained.items(), key=lambda x: -x[1]):\n    print(f\"  {hero}: {gold:,}\")\n</code></pre>"},{"location":"guides/combat-log/#healing-analysis","title":"Healing Analysis","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=2000)\n\nhealing_received = defaultdict(int)\nhealing_sources = defaultdict(lambda: defaultdict(int))\n\nfor entry in result.entries:\n    healing_received[entry.target_name] += entry.value\n    if entry.inflictor_name:\n        healing_sources[entry.target_name][entry.inflictor_name] += entry.value\n\nprint(\"Healing Received:\")\nfor unit, total in sorted(healing_received.items(), key=lambda x: -x[1])[:10]:\n    print(f\"\\n{unit}: {total:,} total\")\n    for source, amount in sorted(healing_sources[unit].items(), key=lambda x: -x[1])[:3]:\n        print(f\"    {source}: {amount:,}\")\n</code></pre>"},{"location":"guides/combat-log/#important-notes","title":"Important Notes","text":""},{"location":"guides/combat-log/#game-time","title":"Game Time","text":"<p>The <code>game_time</code> field provides the in-game clock time (what you see on screen). The horn sounds at <code>game_time=0</code>, and pre-game events have negative times.</p> Field Description <code>game_time</code> In-game clock time in seconds (0:00 = horn, negative for pre-game) <code>game_time_str</code> Formatted time string (e.g., \"-0:40\", \"5:32\") <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [11], \"max_entries\": 100})  # PURCHASE events\n\nfor entry in result.combat_log.entries:\n    # Use game_time_str for formatted output\n    print(f\"[{entry.game_time_str}] {entry.value_name}\")\n</code></pre>"},{"location":"guides/combat-log/#pre-game-events-negative-game-time","title":"Pre-Game Events (Negative Game Time)","text":"<p>Events during the 90-second pre-game countdown have negative <code>game_time</code> values. Use <code>is_pre_horn</code> property to check:</p> <pre><code>parser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [11], \"max_entries\": 200})  # PURCHASE\n\n# Pre-game purchases (during countdown)\npregame = [e for e in result.combat_log.entries if e.is_pre_horn]\nprint(f\"Pre-game purchases: {len(pregame)}\")\n\nfor entry in pregame[:5]:\n    hero = entry.target_name.replace(\"npc_dota_hero_\", \"\")\n    item = entry.value_name.replace(\"item_\", \"\")\n    print(f\"[{entry.game_time_str}] {hero}: {item}\")\n# Output:\n# [-1:29] antimage: ward_observer\n# [-1:28] troll_warlord: tango\n# [-1:27] crystal_maiden: blood_grenade\n</code></pre>"},{"location":"guides/combat-log/#game-start-tick","title":"Game Start Tick","text":"<p>The <code>CombatLogResult</code> includes <code>game_start_tick</code> which is the tick when the horn sounded (game_time=0):</p> <pre><code>parser = Parser(\"match.dem\")\nresult = parser.parse(combat_log={\"types\": [18], \"max_entries\": 1})  # First blood\n\nprint(f\"Game started at tick: {result.combat_log.game_start_tick}\")\n\nif result.combat_log.entries:\n    entry = result.combat_log.entries[0]\n    print(f\"First blood at {entry.game_time_str} game time\")\n\n### Illusion Filtering\n\n```python\n# Filter out illusion damage for accurate stats\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=5000)\n\nreal_damage = [\n    entry for entry in result.entries\n    if not entry.is_attacker_illusion and not entry.is_target_illusion\n]\n\nprint(f\"Total entries: {len(result.entries)}\")\nprint(f\"Real damage entries (no illusions): {len(real_damage)}\")\n</code></pre>"},{"location":"guides/combat-log/#combat-log-vs-game-events","title":"Combat Log vs Game Events","text":"Aspect Combat Log Game Events API <code>parse_combat_log()</code> <code>parse_game_events()</code> Structure Fixed schema with 80+ fields Variable fields per event type Types 45 log types 364 event types Best for Detailed damage/heal analysis Discrete game occurrences Timing Full match (game_time is in-game clock) Full match Filtering By type ID, heroes_only By event name <p>Use combat log for continuous combat data (DPS, healing totals) and game events for discrete occurrences (tower kills, rune pickups).</p>"},{"location":"guides/combat-log/#available-data-fields","title":"Available Data Fields","text":"<p>The combat log exposes raw data that can be used by other tools for analysis or narrative generation.</p>"},{"location":"guides/combat-log/#data-available-per-event","title":"Data Available Per Event","text":"Data Point Field Notes HP after event <code>health</code> Target's HP after this event Damage/heal amount <code>value</code> Raw numeric value Ability/item name <code>inflictor_name</code> Internal name (e.g., \"pugna_nether_blast\") Item name (PURCHASE) <code>value_name</code> Resolved item name for PURCHASE events Ability level <code>ability_level</code> 1-4+ Assist player IDs <code>assist_players</code> List of player IDs Stun duration <code>stun_duration</code> Seconds Slow duration <code>slow_duration</code> Seconds Root applied <code>root_modifier</code> Boolean Lifesteal heal <code>heal_from_lifesteal</code> Boolean Will reincarnate <code>will_reincarnate</code> Boolean (Aegis/WK) Night time <code>at_night_time</code> Boolean Has Aghanim's <code>attacker_has_scepter</code> Boolean Hero levels <code>attacker_hero_level</code>, <code>target_hero_level</code> Integer Position <code>location_x</code>, <code>location_y</code> Map coordinates Game time <code>game_time</code> In-game clock time in seconds (negative for pre-game) Game time (formatted) <code>game_time_str</code> Formatted time string (e.g., \"-0:40\", \"5:32\")"},{"location":"guides/combat-log/#data-not-available-in-combat-log","title":"Data NOT Available in Combat Log","text":"Data Point Notes <code>stack_count</code> Always 0 - Valve doesn't populate this field <code>uses_charges</code> Always false - Valve doesn't populate this field Cooldowns Not in combat log Mana costs Not in combat log Exact max HP Only current HP after event <p>Getting Item Charges</p> <p>The combat log <code>stack_count</code> field is NOT populated by Valve. To get actual item charges (e.g., Magic Stick/Wand), use entity queries instead:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\ndef get_magic_stick_charges(demo_path: str, at_tick: int = 0) -&gt; dict:\n    \"\"\"\n    Get magic stick/wand charges for all players at a specific game tick.\n\n    Args:\n        demo_path: Path to the .dem file\n        at_tick: Game tick to query (0 = end of game)\n\n    Returns:\n        Dict mapping player_id -&gt; charges\n    \"\"\"\n    result = parser.query_entities(\n        demo_path,\n        class_names=['CDOTA_Item_MagicStick', 'CDOTA_Item_MagicWand'],\n        property_filter=['m_iCurrentCharges', 'm_iPlayerOwnerID'],\n        at_tick=at_tick\n    )\n\n    player_charges = {}\n    for entity in result.entities:\n        owner = entity.properties.get('m_iPlayerOwnerID', -1)\n        charges = entity.properties.get('m_iCurrentCharges', 0)\n        if owner &gt;= 0:\n            player_charges[owner] = max(player_charges.get(owner, 0), charges)\n\n    return player_charges\n\n# Get charges at a specific tick\ncharges = get_magic_stick_charges(\"match.dem\", at_tick=50000)\n# {0: 6, 2: 18, 4: 7, 6: 6, 8: 1, 10: 15, 12: 4, 14: 20, 16: 0, 18: 5}\n</code></pre> <p>Alternative: Calculate charges from HEAL event value (Magic Stick/Wand heal 15 HP per charge):</p> <pre><code># From a combat log HEAL entry with inflictor_name containing \"magic_stick\" or \"magic_wand\"\ncharges_used = entry.value // 15  # e.g., 150 HP healed = 10 charges\n</code></pre>"},{"location":"guides/combat-log/#deriving-respawn-events","title":"Deriving Respawn Events","text":"<p>The combat log doesn't have explicit respawn events, but you can derive them from DEATH events using the <code>derive_respawn_events()</code> utility.</p>"},{"location":"guides/combat-log/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import Parser, derive_respawn_events, CombatLogType\n\nparser = Parser(\"match.dem\")\n\n# Get all hero deaths\nresult = parser.parse(combat_log={\n    \"types\": [CombatLogType.DEATH],\n    \"heroes_only\": True,\n    \"max_entries\": 1000\n})\n\n# Derive respawn events\nrespawns = derive_respawn_events(result.combat_log)\n\nfor r in respawns[:10]:\n    print(f\"{r.hero_display_name} died at {r.death_game_time_str}, \"\n          f\"respawns after {r.respawn_duration:.0f}s\")\n</code></pre>"},{"location":"guides/combat-log/#herorespawnevent-fields","title":"HeroRespawnEvent Fields","text":"<p>Each <code>HeroRespawnEvent</code> includes:</p> Field Type Description <code>hero_name</code> str Internal hero name (e.g., \"npc_dota_hero_axe\") <code>hero_display_name</code> str Display name (e.g., \"Axe\") <code>death_tick</code> int Tick when hero died <code>death_game_time</code> float Game time when hero died <code>death_game_time_str</code> str Formatted death time <code>respawn_tick</code> int Estimated respawn tick <code>respawn_game_time</code> float Estimated respawn game time <code>respawn_game_time_str</code> str Formatted respawn time <code>respawn_duration</code> float Respawn duration in seconds <code>killer_name</code> str Who killed the hero <code>hero_level</code> int Hero level at death (if available) <code>team</code> int Hero's team (2=Radiant, 3=Dire) <code>will_reincarnate</code> bool True if Aegis/Wraith King ult <code>location_x</code> float Death X coordinate <code>location_y</code> float Death Y coordinate"},{"location":"guides/combat-log/#hero-levels-for-respawn-calculation","title":"Hero Levels for Respawn Calculation","text":"<p>As of v1.4.5.4, <code>target_hero_level</code> is now populated directly in combat log entries, so respawn times are calculated accurately without needing to provide levels manually:</p> <pre><code># Hero levels are now available directly in combat log\nrespawns = derive_respawn_events(result.combat_log)\n\nfor r in respawns[:5]:\n    print(f\"{r.hero_display_name} (lvl {r.hero_level}) died at {r.death_game_time_str}, \"\n          f\"respawns after {r.respawn_duration:.0f}s\")\n</code></pre> <p>You can still provide custom hero levels if needed (e.g., for edge cases or to override):</p> <pre><code># Optional: provide custom levels\nhero_levels = {\"npc_dota_hero_axe\": 25}\nrespawns = derive_respawn_events(result.combat_log, hero_levels=hero_levels)\n</code></pre>"},{"location":"guides/combat-log/#respawn-time-formula","title":"Respawn Time Formula","text":"<p>Respawn time is calculated as: <code>min(4 + (level \u00d7 2), 100)</code> seconds.</p> Level Respawn Time 1-5 6-14 seconds 10 24 seconds 15 34 seconds 20 44 seconds 25 54 seconds 30 64 seconds <p>Aegis and Wraith King</p> <p>When <code>will_reincarnate</code> is True (Aegis or Wraith King ult), the hero respawns at the death location after ~5 seconds instead of at fountain.</p>"},{"location":"guides/entities/","title":"Entity Queries Guide","text":"AI Summary <p>Query game entities using <code>query_entities()</code>. Filter by class name (substring or exact match) and select specific properties. Use <code>at_tick</code> to query at a specific game tick (default: end of game). Common classes: <code>Hero</code> (player heroes), <code>Tower</code>, <code>Courier</code>, <code>Creep</code>, <code>CDOTA_Item_MagicStick</code>, <code>CDOTA_Item_MagicWand</code>. Hero properties include <code>m_iHealth</code>, <code>m_iMaxHealth</code>, <code>m_flMana</code>, <code>m_vecOrigin</code> (position). Item properties include <code>m_iCurrentCharges</code>, <code>m_iPlayerOwnerID</code>. Use property_filter for performance.</p>"},{"location":"guides/entities/#overview","title":"Overview","text":"<p>Entity queries let you extract game state from the replay, including hero stats, positions, items, and unit properties.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    health = entity.properties.get(\"m_iHealth\", 0)\n    max_hp = entity.properties.get(\"m_iMaxHealth\", 0)\n    print(f\"{entity.class_name}: {health}/{max_hp} HP\")\n</code></pre>"},{"location":"guides/entities/#filtering-by-class","title":"Filtering by Class","text":""},{"location":"guides/entities/#substring-filter","title":"Substring Filter","text":"<pre><code># All entities with \"Hero\" in class name\nheroes = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=20)\n\n# All tower entities\ntowers = parser.query_entities(\"match.dem\", class_filter=\"Tower\", max_entities=30)\n\n# All courier entities\ncouriers = parser.query_entities(\"match.dem\", class_filter=\"Courier\", max_entities=10)\n</code></pre>"},{"location":"guides/entities/#exact-class-names","title":"Exact Class Names","text":"<pre><code># Specific hero classes\nresult = parser.query_entities(\n    \"match.dem\",\n    class_names=[\n        \"CDOTA_Unit_Hero_Invoker\",\n        \"CDOTA_Unit_Hero_Pudge\",\n        \"CDOTA_Unit_Hero_AntiMage\"\n    ],\n    max_entities=10\n)\n\n# Specific building types\nbuildings = parser.query_entities(\n    \"match.dem\",\n    class_names=[\n        \"CDOTA_BaseNPC_Tower\",\n        \"CDOTA_BaseNPC_Barracks\",\n        \"CDOTA_BaseNPC_Fort\"\n    ],\n    max_entities=50\n)\n</code></pre>"},{"location":"guides/entities/#property-filtering","title":"Property Filtering","text":"<p>For better performance, specify only the properties you need:</p> <pre><code># Only get health and position\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_vecOrigin\"],\n    max_entities=10\n)\n\nfor entity in result.entities:\n    pos = entity.properties.get(\"m_vecOrigin\", [0, 0, 0])\n    print(f\"{entity.class_name} at ({pos[0]:.0f}, {pos[1]:.0f})\")\n</code></pre>"},{"location":"guides/entities/#common-entity-classes","title":"Common Entity Classes","text":"Class Pattern Description <code>Hero</code> Player-controlled heroes <code>Tower</code> Tower buildings <code>Barracks</code> Barracks buildings <code>Fort</code> Ancient/Throne <code>Courier</code> Courier units <code>Creep</code> Lane creeps <code>NeutralCreep</code> Jungle creeps <code>Roshan</code> Roshan <code>Ward</code> Observer/Sentry wards"},{"location":"guides/entities/#hero-properties","title":"Hero Properties","text":""},{"location":"guides/entities/#core-stats","title":"Core Stats","text":"Property Type Description <code>m_iHealth</code> int Current health <code>m_iMaxHealth</code> int Maximum health <code>m_flMana</code> float Current mana <code>m_flMaxMana</code> float Maximum mana <code>m_iCurrentLevel</code> int Hero level <code>m_flStrength</code> float Strength attribute <code>m_flAgility</code> float Agility attribute <code>m_flIntellect</code> float Intelligence attribute"},{"location":"guides/entities/#position-and-movement","title":"Position and Movement","text":"Property Type Description <code>m_vecOrigin</code> list[float] Position [x, y, z] <code>m_angRotation</code> list[float] Rotation angles <code>m_flMovementSpeed</code> float Movement speed"},{"location":"guides/entities/#economy","title":"Economy","text":"Property Type Description <code>m_iTotalEarnedGold</code> int Total gold earned <code>m_iUnreliableGold</code> int Unreliable gold <code>m_iReliableGold</code> int Reliable gold <code>m_iLastHits</code> int Last hits <code>m_iDenies</code> int Denies"},{"location":"guides/entities/#kda","title":"KDA","text":"Property Type Description <code>m_iKills</code> int Kills <code>m_iDeaths</code> int Deaths <code>m_iAssists</code> int Assists"},{"location":"guides/entities/#combat","title":"Combat","text":"Property Type Description <code>m_flPhysicalArmorValue</code> float Armor <code>m_flMagicalResistanceValue</code> float Magic resistance <code>m_iDamageMin</code> int Minimum damage <code>m_iDamageMax</code> int Maximum damage <code>m_iAttackRange</code> int Attack range"},{"location":"guides/entities/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/entities/#end-game-scoreboard","title":"End Game Scoreboard","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\n        \"m_iCurrentLevel\",\n        \"m_iKills\", \"m_iDeaths\", \"m_iAssists\",\n        \"m_iTotalEarnedGold\", \"m_iLastHits\", \"m_iDenies\"\n    ],\n    max_entities=10\n)\n\nprint(\"End Game Scoreboard:\")\nprint(\"-\" * 70)\nprint(f\"{'Hero':&lt;30} {'Lvl':&gt;4} {'K':&gt;3} {'D':&gt;3} {'A':&gt;3} {'LH':&gt;5} {'Gold':&gt;8}\")\nprint(\"-\" * 70)\n\nfor entity in result.entities:\n    props = entity.properties\n    print(f\"{entity.class_name:&lt;30} \"\n          f\"{props.get('m_iCurrentLevel', 0):&gt;4} \"\n          f\"{props.get('m_iKills', 0):&gt;3} \"\n          f\"{props.get('m_iDeaths', 0):&gt;3} \"\n          f\"{props.get('m_iAssists', 0):&gt;3} \"\n          f\"{props.get('m_iLastHits', 0):&gt;5} \"\n          f\"{props.get('m_iTotalEarnedGold', 0):&gt;8,}\")\n</code></pre>"},{"location":"guides/entities/#hero-positions-map","title":"Hero Positions Map","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_vecOrigin\", \"m_iTeamNum\"],\n    max_entities=10\n)\n\nprint(\"Hero Positions (end of game):\")\nfor entity in result.entities:\n    pos = entity.properties.get(\"m_vecOrigin\", [0, 0, 0])\n    team = entity.properties.get(\"m_iTeamNum\", 0)\n    team_name = \"Radiant\" if team == 2 else \"Dire\" if team == 3 else \"Unknown\"\n\n    print(f\"{entity.class_name}: ({pos[0]:.0f}, {pos[1]:.0f}) - {team_name}\")\n</code></pre>"},{"location":"guides/entities/#building-status","title":"Building Status","text":"<pre><code># Check tower status\ntowers = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Tower\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_iTeamNum\"],\n    max_entities=30\n)\n\nprint(\"Tower Status:\")\nradiant_towers = 0\ndire_towers = 0\n\nfor tower in towers.entities:\n    health = tower.properties.get(\"m_iHealth\", 0)\n    max_health = tower.properties.get(\"m_iMaxHealth\", 0)\n    team = tower.properties.get(\"m_iTeamNum\", 0)\n\n    if health &gt; 0:\n        if team == 2:\n            radiant_towers += 1\n        elif team == 3:\n            dire_towers += 1\n\nprint(f\"Radiant towers remaining: {radiant_towers}\")\nprint(f\"Dire towers remaining: {dire_towers}\")\n</code></pre>"},{"location":"guides/entities/#item-slots","title":"Item Slots","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\n        \"m_hItems.0000\", \"m_hItems.0001\", \"m_hItems.0002\",\n        \"m_hItems.0003\", \"m_hItems.0004\", \"m_hItems.0005\"\n    ],\n    max_entities=10\n)\n\nfor entity in result.entities:\n    print(f\"\\n{entity.class_name} items:\")\n    for i in range(6):\n        item_handle = entity.properties.get(f\"m_hItems.{i:04d}\")\n        if item_handle and item_handle != 16777215:  # Invalid handle\n            print(f\"  Slot {i}: {item_handle}\")\n</code></pre>"},{"location":"guides/entities/#neutral-creeps","title":"Neutral Creeps","text":"<pre><code>result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"NeutralCreep\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\", \"m_vecOrigin\"],\n    max_entities=50\n)\n\nalive_creeps = [e for e in result.entities if e.properties.get(\"m_iHealth\", 0) &gt; 0]\nprint(f\"Neutral creeps alive: {len(alive_creeps)}\")\n</code></pre>"},{"location":"guides/entities/#entity-data-structure","title":"Entity Data Structure","text":"<p>Each <code>EntityData</code> object contains:</p> <pre><code>class EntityData(BaseModel):\n    index: int                    # Entity index\n    serial: int                   # Entity serial number\n    class_name: str               # Entity class name (e.g., \"CDOTA_Unit_Hero_Invoker\")\n    properties: Dict[str, Any]    # Entity properties\n</code></pre> <p>The <code>properties</code> dictionary contains all requested or available properties for the entity.</p>"},{"location":"guides/entities/#result-information","title":"Result Information","text":"<p>The <code>EntitiesResult</code> includes metadata:</p> <pre><code>result = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nprint(f\"Total entities returned: {result.total_entities}\")\nprint(f\"Captured at tick: {result.tick}\")\nprint(f\"Network tick: {result.net_tick}\")\nprint(f\"Parse success: {result.success}\")\n</code></pre>"},{"location":"guides/entities/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use property_filter - Specify only needed properties to reduce memory and processing</li> <li>Use class_names for exact matches - More efficient than substring filter</li> <li>Set max_entities - Limit results when you only need a few entities</li> <li>Query once, process multiple times - Entity queries are at end of replay, cache results</li> </ol> <pre><code># Efficient: specific properties\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iKills\"],\n    max_entities=10\n)\n\n# Less efficient: all properties\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    max_entities=10\n)\n</code></pre>"},{"location":"guides/entities/#querying-at-specific-ticks","title":"Querying at Specific Ticks","text":"<p>Use the <code>at_tick</code> parameter to query entity state at a specific game tick instead of end of game:</p> <pre><code># Query heroes at tick 50000\nresult = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\", \"m_iMaxHealth\"],\n    at_tick=50000,\n    max_entities=10\n)\n\nprint(f\"Hero health at tick {result.tick}:\")\nfor entity in result.entities:\n    health = entity.properties.get(\"m_iHealth\", 0)\n    max_hp = entity.properties.get(\"m_iMaxHealth\", 0)\n    print(f\"  {entity.class_name}: {health}/{max_hp}\")\n</code></pre>"},{"location":"guides/entities/#item-charges-at-specific-time","title":"Item Charges at Specific Time","text":"<p>Get Magic Stick/Wand charges for all players at a specific tick:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\ndef get_magic_stick_charges(demo_path: str, at_tick: int = 0) -&gt; dict:\n    \"\"\"\n    Get magic stick/wand charges for all players at a specific game tick.\n\n    Args:\n        demo_path: Path to the .dem file\n        at_tick: Game tick to query (0 = end of game)\n\n    Returns:\n        Dict mapping player_id -&gt; charges\n    \"\"\"\n    result = parser.query_entities(\n        demo_path,\n        class_names=['CDOTA_Item_MagicStick', 'CDOTA_Item_MagicWand'],\n        property_filter=['m_iCurrentCharges', 'm_iPlayerOwnerID'],\n        at_tick=at_tick\n    )\n\n    player_charges = {}\n    for entity in result.entities:\n        owner = entity.properties.get('m_iPlayerOwnerID', -1)\n        charges = entity.properties.get('m_iCurrentCharges', 0)\n        if owner &gt;= 0:\n            player_charges[owner] = max(player_charges.get(owner, 0), charges)\n\n    return player_charges\n\n# Get charges at tick 50000\ncharges = get_magic_stick_charges(\"match.dem\", at_tick=50000)\n# {0: 6, 2: 18, 4: 7, 6: 6, 8: 1, 10: 15, 12: 4, 14: 20, 16: 0, 18: 5}\n</code></pre>"},{"location":"guides/entities/#important-notes","title":"Important Notes","text":"<p>Note</p> <p>By default (<code>at_tick=0</code>), entity queries return the state at the end of the replay. Use <code>at_tick</code> to query state at a specific game tick.</p>"},{"location":"guides/entities/#entity-handles","title":"Entity Handles","text":"<p>Some properties reference other entities via handles:</p> <pre><code># Item handles reference item entities\nitem_handle = hero.properties.get(\"m_hItems.0000\")\n\n# These are internal entity references, not item IDs\n# Use string tables or item events for item identification\n</code></pre>"},{"location":"guides/entities/#team-numbers","title":"Team Numbers","text":"Team ID Team 2 Radiant 3 Dire 0/1 Neutral/Spectator"},{"location":"guides/entities/#hero-position-tracking-with-parse_entities","title":"Hero Position Tracking with parse_entities()","text":"<p>For tracking hero positions over time (not just end of game), use <code>parse_entities()</code> instead of <code>query_entities()</code>.</p>"},{"location":"guides/entities/#basic-position-tracking","title":"Basic Position Tracking","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Capture snapshots every 30 seconds (900 ticks at 30 ticks/sec)\nresult = parser.parse_entities(\"match.dem\", interval_ticks=900, max_snapshots=100)\n\nfor snapshot in result.snapshots:\n    print(f\"Game time: {snapshot.game_time:.1f}s\")\n    for hero in snapshot.heroes:\n        print(f\"  {hero.hero_name}: ({hero.x:.0f}, {hero.y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#position-at-specific-ticks","title":"Position at Specific Ticks","text":"<p>Use <code>target_ticks</code> to capture state at exact moments:</p> <pre><code># Get hero positions at specific ticks\nresult = parser.parse_entities(\"match.dem\", target_ticks=[30000, 45000, 60000])\n\nfor snapshot in result.snapshots:\n    print(f\"Tick {snapshot.tick}:\")\n    for hero in snapshot.heroes:\n        print(f\"  {hero.hero_name}: ({hero.x:.0f}, {hero.y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#filtering-by-hero","title":"Filtering by Hero","text":"<p>Use <code>target_heroes</code> to only get specific heroes. Use the <code>npc_dota_hero_*</code> format (same as combat log):</p> <pre><code># Get only specific heroes\nresult = parser.parse_entities(\n    \"match.dem\",\n    target_ticks=[50000],\n    target_heroes=[\"npc_dota_hero_axe\", \"npc_dota_hero_lina\"]\n)\n</code></pre>"},{"location":"guides/entities/#getting-death-positions","title":"Getting Death Positions","text":"<p>Combat log <code>location_x</code>/<code>location_y</code> are always 0. To get death positions, combine combat log with entity snapshots:</p> <pre><code># Get deaths from combat log\ncombat = parser.parse_combat_log(\"match.dem\", types=[1])  # type 1 = deaths\n\nfor death in combat.entries:\n    # Get victim's position at death tick\n    result = parser.parse_entities(\n        \"match.dem\",\n        target_ticks=[death.tick],\n        target_heroes=[death.target_name]  # e.g., \"npc_dota_hero_axe\"\n    )\n\n    if result.snapshots and result.snapshots[0].heroes:\n        victim = result.snapshots[0].heroes[0]\n        print(f\"{victim.hero_name} died at ({victim.x:.0f}, {victim.y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#position-coordinate-system","title":"Position Coordinate System","text":"<p>Hero positions use world coordinates centered on the map:</p> <ul> <li>X axis: West (Radiant, negative) to East (Dire, positive)</li> <li>Y axis: South (negative) to North (positive)</li> <li>Origin (0,0): Center of the map</li> <li>Range: Approximately -8000 to +8000 for both axes</li> </ul>"},{"location":"guides/entities/#herosnapshot-fields","title":"HeroSnapshot Fields","text":"<p>Each hero in a snapshot includes:</p> Field Type Description <code>player_id</code> int Player slot (0-9) <code>hero_id</code> int Hero ID <code>hero_name</code> str Hero name (<code>npc_dota_hero_*</code> format) <code>team</code> int 2=Radiant, 3=Dire <code>x</code> float X world coordinate <code>y</code> float Y world coordinate <code>health</code> int Current health <code>max_health</code> int Maximum health <code>mana</code> float Current mana <code>max_mana</code> float Maximum mana <code>level</code> int Hero level <code>last_hits</code> int Last hits <code>denies</code> int Denies <code>gold</code> int Current gold <code>net_worth</code> int Net worth <code>gpm</code> int Gold per minute <code>xpm</code> int XP per minute <code>kills</code> int Kills <code>deaths</code> int Deaths <code>assists</code> int Assists <code>armor</code> float Current armor <code>magic_resistance</code> float Magic resistance (0-1) <code>damage_min</code> int Minimum damage <code>damage_max</code> int Maximum damage <code>strength</code> float Strength attribute <code>agility</code> float Agility attribute <code>intellect</code> float Intellect attribute <code>abilities</code> list List of <code>AbilitySnapshot</code> <code>talents</code> list List of <code>TalentChoice</code> <code>inventory</code> list List of <code>ItemSnapshot</code> <code>is_illusion</code> bool True if illusion <code>is_clone</code> bool True if clone (e.g., Meepo)"},{"location":"guides/entities/#position-data-sources-comparison","title":"Position Data Sources Comparison","text":"Method Use Case Position Data <code>parse_entities()</code> Time-series or specific ticks \u2705 <code>position_x</code>, <code>position_y</code> <code>query_entities()</code> End-of-game state \u2705 Raw <code>CBodyComponent.m_cellX/Y</code> <code>parse_combat_log()</code> Combat events \u274c <code>location_x/y</code> always 0"},{"location":"guides/entities/#hero-abilities-and-talents","title":"Hero Abilities and Talents","text":"<p>The <code>parser.snapshot()</code> method returns hero state including abilities and talent choices.</p>"},{"location":"guides/entities/#basic-ability-tracking","title":"Basic Ability Tracking","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nsnap = parser.snapshot(target_tick=60000)  # ~33 minutes\n\nfor hero in snap.heroes:\n    print(f\"{hero.hero_name} (Level {hero.level})\")\n\n    # Show all abilities\n    for ability in hero.abilities:\n        if ability.level &gt; 0:\n            print(f\"  {ability.short_name}: Level {ability.level}\")\n</code></pre>"},{"location":"guides/entities/#ability-properties","title":"Ability Properties","text":"<p>Each <code>AbilitySnapshot</code> includes:</p> Field Type Description <code>slot</code> int Ability slot (0-5 for regular abilities) <code>name</code> str Full ability class name <code>level</code> int Current ability level (0-4) <code>cooldown</code> float Current cooldown remaining <code>max_cooldown</code> float Maximum cooldown length <code>mana_cost</code> int Mana cost <code>charges</code> int Current charges <code>is_ultimate</code> bool True if slot 5 (ultimate) <p>Helper Properties:</p> Property Type Description <code>short_name</code> str Name without \"CDOTA_Ability_\" prefix <code>is_maxed</code> bool True if at max level <code>is_on_cooldown</code> bool True if cooldown &gt; 0"},{"location":"guides/entities/#talent-tracking","title":"Talent Tracking","text":"<p>Talents are tracked separately from abilities:</p> <pre><code>snap = parser.snapshot(target_tick=120000)  # Late game\n\nfor hero in snap.heroes:\n    print(f\"{hero.hero_name}: {hero.talents_chosen}/4 talents\")\n\n    for talent in hero.talents:\n        print(f\"  Level {talent.tier}: {talent.side}\")\n</code></pre> <p>Each <code>TalentChoice</code> includes:</p> Field Type Description <code>tier</code> int Talent tier (10, 15, 20, or 25) <code>slot</code> int Raw ability slot index <code>is_left</code> bool True if left talent chosen <code>name</code> str Talent ability name <code>side</code> str \"left\" or \"right\""},{"location":"guides/entities/#finding-specific-abilities","title":"Finding Specific Abilities","text":"<p>Use helper methods to find abilities:</p> <pre><code>for hero in snap.heroes:\n    # Find ability by name (partial match)\n    omnislash = hero.get_ability(\"Omnislash\")\n    if omnislash and omnislash.level &gt; 0:\n        print(f\"Omnislash level {omnislash.level}\")\n\n    # Check if ultimate is learned\n    if hero.has_ultimate:\n        print(\"Has ultimate!\")\n\n    # Get talent at specific tier\n    lvl20_talent = hero.get_talent_at_tier(20)\n    if lvl20_talent:\n        print(f\"Level 20 talent: {lvl20_talent.side}\")\n</code></pre>"},{"location":"guides/entities/#tracking-skill-builds-over-time","title":"Tracking Skill Builds Over Time","text":"<p>Combine multiple snapshots to track skill progression:</p> <pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\n\n# Get snapshots at different times\nticks = [30000, 60000, 90000, 120000]\n\nfor tick in ticks:\n    snap = parser.snapshot(target_tick=tick)\n\n    for hero in snap.heroes:\n        if \"Juggernaut\" in hero.hero_name:\n            print(f\"Tick {tick} - Level {hero.level}\")\n            for ab in hero.abilities:\n                if ab.level &gt; 0:\n                    print(f\"  {ab.short_name}: {ab.level}\")\n            break\n</code></pre>"},{"location":"guides/entities/#cooldown-analysis","title":"Cooldown Analysis","text":"<p>Track ability cooldowns for timing analysis:</p> <pre><code>snap = parser.snapshot(target_tick=60000)\n\nfor hero in snap.heroes:\n    print(f\"\\n{hero.hero_name} cooldowns:\")\n    for ability in hero.abilities:\n        if ability.is_on_cooldown:\n            print(f\"  {ability.short_name}: {ability.cooldown:.1f}s remaining\")\n        elif ability.level &gt; 0:\n            print(f\"  {ability.short_name}: ready\")\n</code></pre>"},{"location":"guides/entities/#hero-inventory","title":"Hero Inventory","text":"<p>The <code>parser.snapshot()</code> method returns hero state including full inventory data: main inventory, backpack, stash, TP slot, and neutral item.</p>"},{"location":"guides/entities/#inventory-slot-layout","title":"Inventory Slot Layout","text":"Slot Location Description 0-5 Main Inventory 6 primary item slots 6-8 Backpack 3 backpack slots 9 TP Slot Dedicated TP scroll slot 10-15 Stash 6 stash slots at base 16 Neutral Item Equipped neutral item"},{"location":"guides/entities/#basic-inventory-tracking","title":"Basic Inventory Tracking","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\nsnap = parser.snapshot(target_tick=60000)  # ~17 minutes\n\nfor hero in snap.heroes:\n    print(f\"{hero.hero_name}:\")\n\n    # Main inventory\n    for item in hero.main_inventory:\n        charges = f\" ({item.charges})\" if item.charges &gt; 0 else \"\"\n        print(f\"  Slot {item.slot}: {item.short_name}{charges}\")\n\n    # Neutral item\n    if hero.neutral_item:\n        print(f\"  Neutral: {hero.neutral_item.short_name}\")\n</code></pre>"},{"location":"guides/entities/#itemsnapshot-properties","title":"ItemSnapshot Properties","text":"<p>Each <code>ItemSnapshot</code> includes:</p> Field Type Description <code>slot</code> int Inventory slot (0-16) <code>name</code> str Item class name (e.g., <code>item_blink</code>) <code>charges</code> int Current charges (wand, wards, etc.) <code>cooldown</code> float Remaining cooldown <code>max_cooldown</code> float Maximum cooldown length <p>Helper Properties:</p> Property Type Description <code>short_name</code> str Name without \"item_\" prefix <code>is_main_inventory</code> bool True if slot 0-5 <code>is_backpack</code> bool True if slot 6-8 <code>is_tp_slot</code> bool True if slot 9 <code>is_stash</code> bool True if slot 10-15 <code>is_neutral_slot</code> bool True if slot 16 <code>is_on_cooldown</code> bool True if cooldown &gt; 0"},{"location":"guides/entities/#herosnapshot-inventory-helpers","title":"HeroSnapshot Inventory Helpers","text":"<pre><code>snap = parser.snapshot(target_tick=60000)\n\nfor hero in snap.heroes:\n    # Access inventory by location\n    main = hero.main_inventory      # List[ItemSnapshot] - slots 0-5\n    backpack = hero.backpack        # List[ItemSnapshot] - slots 6-8\n    stash = hero.stash              # List[ItemSnapshot] - slots 10-15\n    neutral = hero.neutral_item     # Optional[ItemSnapshot] - slot 16\n    tp = hero.tp_scroll             # Optional[ItemSnapshot] - slot 9\n\n    # Find items by name\n    bkb = hero.get_item(\"black_king_bar\")\n    if bkb:\n        print(f\"BKB in slot {bkb.slot}\")\n\n    # Check if hero has item\n    if hero.has_item(\"blink\"):\n        print(\"Has Blink Dagger!\")\n</code></pre>"},{"location":"guides/entities/#tracking-item-timings","title":"Tracking Item Timings","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\n\n# Check item progression\nfor tick in [30000, 60000, 90000, 120000]:\n    snap = parser.snapshot(target_tick=tick)\n\n    for hero in snap.heroes:\n        if \"troll_warlord\" in hero.hero_name:\n            items = [item.short_name for item in hero.main_inventory]\n            print(f\"Tick {tick}: {items}\")\n</code></pre>"},{"location":"guides/entities/#item-charges-tracking","title":"Item Charges Tracking","text":"<pre><code>snap = parser.snapshot(target_tick=60000)\n\nfor hero in snap.heroes:\n    wand = hero.get_item(\"magicwand\")\n    if wand:\n        print(f\"{hero.hero_name}: Magic Wand with {wand.charges} charges\")\n</code></pre>"},{"location":"guides/entities/#full-inventory-example","title":"Full Inventory Example","text":"<pre><code>snap = parser.snapshot(target_tick=60000)\n\nfor hero in snap.heroes:\n    print(f\"\\n{hero.hero_name} Inventory:\")\n    print(\"  Main:\")\n    for item in hero.main_inventory:\n        charges = f\" x{item.charges}\" if item.charges else \"\"\n        print(f\"    [{item.slot}] {item.short_name}{charges}\")\n\n    if hero.backpack:\n        print(\"  Backpack:\")\n        for item in hero.backpack:\n            print(f\"    [{item.slot}] {item.short_name}\")\n\n    if hero.neutral_item:\n        print(f\"  Neutral: {hero.neutral_item.short_name}\")\n\n    if hero.stash:\n        print(\"  Stash:\")\n        for item in hero.stash:\n            charges = f\" x{item.charges}\" if item.charges else \"\"\n            print(f\"    [{item.slot}] {item.short_name}{charges}\")\n</code></pre>"},{"location":"guides/entities/#pre-horn-positions","title":"Pre-Horn Positions","text":"<p>Entity snapshots can capture hero positions before the horn sounds (during the strategy phase). Pre-horn snapshots have negative <code>game_time</code> values.</p>"},{"location":"guides/entities/#basic-pre-horn-tracking","title":"Basic Pre-Horn Tracking","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\n\n# Parse with interval that captures pre-horn\nresult = parser.parse(entities={'interval_ticks': 900, 'max_snapshots': 20})\n\nfor snap in result.entities.snapshots:\n    if snap.game_time &lt; 0:\n        print(f\"Pre-horn ({snap.game_time_str}): {len(snap.heroes)} heroes\")\n        for hero in snap.heroes:\n            print(f\"  {hero.hero_name} at ({hero.x:.0f}, {hero.y:.0f})\")\n</code></pre>"},{"location":"guides/entities/#understanding-pre-horn-time","title":"Understanding Pre-Horn Time","text":"<code>game_time</code> Meaning <code>-90.0</code> 1 minute 30 seconds before horn <code>-45.0</code> 45 seconds before horn <code>0.0</code> Horn sounds (game starts) <code>60.0</code> 1 minute into the game"},{"location":"guides/entities/#game-start-tick","title":"Game Start Tick","text":"<p>The <code>game_start_tick</code> field tells you when the horn sounded:</p> <pre><code>result = parser.parse(entities={'interval_ticks': 1800})\n\nprint(f\"Game started at tick: {result.entities.game_start_tick}\")\n\n# All snapshots with tick &lt; game_start_tick are pre-horn\nfor snap in result.entities.snapshots:\n    if snap.tick &lt; result.entities.game_start_tick:\n        print(f\"Pre-horn snapshot at tick {snap.tick}\")\n</code></pre>"},{"location":"guides/entities/#creep-positions","title":"Creep Positions","text":"<p>Track lane and neutral creep positions with the <code>include_creeps</code> option.</p> <p>Performance Note</p> <p>Including creeps significantly increases data volume. A typical snapshot may have 100-200 creeps vs 10 heroes. Use judiciously.</p>"},{"location":"guides/entities/#basic-creep-tracking","title":"Basic Creep Tracking","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\n\n# Enable creep tracking\nresult = parser.parse(entities={\n    'interval_ticks': 1800,\n    'max_snapshots': 10,\n    'include_creeps': True\n})\n\nfor snap in result.entities.snapshots:\n    lane_creeps = [c for c in snap.creeps if c.is_lane]\n    neutral_creeps = [c for c in snap.creeps if c.is_neutral]\n    print(f\"{snap.game_time_str}: {len(lane_creeps)} lane, {len(neutral_creeps)} neutral creeps\")\n</code></pre>"},{"location":"guides/entities/#creepsnapshot-fields","title":"CreepSnapshot Fields","text":"<p>Each creep in <code>snapshot.creeps</code> includes:</p> Field Type Description <code>entity_id</code> int Entity index <code>class_name</code> str Entity class (e.g., <code>CDOTA_BaseNPC_Creep_Lane</code>) <code>name</code> str Unit name (may be empty) <code>team</code> int 2=Radiant, 3=Dire, 4=Neutral <code>x</code> float X world coordinate <code>y</code> float Y world coordinate <code>health</code> int Current health <code>max_health</code> int Maximum health <code>is_lane</code> bool True for lane creeps <code>is_neutral</code> bool True for neutral creeps"},{"location":"guides/entities/#filtering-creeps-by-team","title":"Filtering Creeps by Team","text":"<pre><code>for snap in result.entities.snapshots:\n    radiant_creeps = [c for c in snap.creeps if c.team == 2]\n    dire_creeps = [c for c in snap.creeps if c.team == 3]\n    neutral_creeps = [c for c in snap.creeps if c.team == 4]\n\n    print(f\"{snap.game_time_str}:\")\n    print(f\"  Radiant creeps: {len(radiant_creeps)}\")\n    print(f\"  Dire creeps: {len(dire_creeps)}\")\n    print(f\"  Neutral creeps: {len(neutral_creeps)}\")\n</code></pre>"},{"location":"guides/entities/#creep-wave-analysis","title":"Creep Wave Analysis","text":"<pre><code># Track creep waves by position\nfor snap in result.entities.snapshots:\n    if snap.game_time &lt; 0:\n        continue  # Skip pre-horn\n\n    # Group lane creeps by approximate lane position\n    for creep in snap.creeps:\n        if creep.is_lane and creep.team == 2:  # Radiant lane creeps\n            # Mid lane is roughly where x \u2248 y\n            # Top lane: high y, low x\n            # Bot lane: low y, high x\n            if abs(creep.x - creep.y) &lt; 2000:\n                lane = \"mid\"\n            elif creep.y &gt; creep.x:\n                lane = \"top\"\n            else:\n                lane = \"bot\"\n            print(f\"Radiant creep at ({creep.x:.0f}, {creep.y:.0f}) - {lane} lane\")\n</code></pre>"},{"location":"guides/game-events/","title":"Game Events Guide","text":"AI Summary <p>Dota 2 replays contain 364 Source 1 legacy game events with typed fields. Use <code>parse_game_events()</code> to capture events like player kills, rune pickups, tower destructions, and combat log entries. Filter by event name substring or specific names. Events have tick timestamps and typed field dictionaries. Common events: <code>dota_player_kill</code>, <code>dota_combatlog</code>, <code>dota_rune_activated</code>, <code>dota_tower_kill</code>, <code>dota_roshan_kill</code>. Use <code>capture_types=True</code> to get the full event type list.</p>"},{"location":"guides/game-events/#overview","title":"Overview","text":"<p>Dota 2 replays contain Source 1 legacy game events - structured notifications about game occurrences. There are 364 different event types, each with specific typed fields.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_game_events(\"match.dem\", max_events=100)\n\nfor event in result.events:\n    print(f\"[{event.tick}] {event.name}: {event.fields}\")\n</code></pre>"},{"location":"guides/game-events/#discovering-event-types","title":"Discovering Event Types","text":"<p>To see all available event types:</p> <pre><code>result = parser.parse_game_events(\"match.dem\", capture_types=True, max_events=0)\n\nprint(f\"Total event types: {len(result.event_types)}\")\nfor event_type in sorted(result.event_types):\n    print(f\"  {event_type}\")\n</code></pre> <p>This returns 364 event type names like: - <code>dota_player_kill</code> - <code>dota_combatlog</code> - <code>dota_rune_activated</code> - <code>dota_tower_kill</code> - <code>dota_roshan_kill</code> - And many more...</p>"},{"location":"guides/game-events/#filtering-events","title":"Filtering Events","text":""},{"location":"guides/game-events/#by-name-substring","title":"By Name Substring","text":"<pre><code># All events containing \"kill\"\nkills = parser.parse_game_events(\"match.dem\", event_filter=\"kill\", max_events=100)\n\n# All combatlog events\ncombatlog = parser.parse_game_events(\"match.dem\", event_filter=\"combatlog\", max_events=500)\n\n# All rune events\nrunes = parser.parse_game_events(\"match.dem\", event_filter=\"rune\", max_events=50)\n</code></pre>"},{"location":"guides/game-events/#by-specific-event-names","title":"By Specific Event Names","text":"<pre><code># Only player kills and tower kills\nresult = parser.parse_game_events(\n    \"match.dem\",\n    event_names=[\"dota_player_kill\", \"dota_tower_kill\"],\n    max_events=100\n)\n</code></pre>"},{"location":"guides/game-events/#common-event-types","title":"Common Event Types","text":""},{"location":"guides/game-events/#player-kills","title":"Player Kills","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=100)\n\nfor event in result.events:\n    victim = event.fields.get(\"victim_userid\")\n    killer = event.fields.get(\"killer1_userid\")\n    print(f\"[Tick {event.tick}] Player {killer} killed player {victim}\")\n</code></pre>"},{"location":"guides/game-events/#tower-destruction","title":"Tower Destruction","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_tower_kill\", max_events=50)\n\nfor event in result.events:\n    killer = event.fields.get(\"killer_userid\")\n    tower = event.fields.get(\"teamnumber\")\n    gold = event.fields.get(\"gold\")\n    print(f\"[Tick {event.tick}] Tower destroyed by player {killer}, gold: {gold}\")\n</code></pre>"},{"location":"guides/game-events/#roshan-kills","title":"Roshan Kills","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_roshan_kill\", max_events=10)\n\nfor event in result.events:\n    team = event.fields.get(\"teamnumber\")\n    print(f\"[Tick {event.tick}] Roshan killed by team {team}\")\n</code></pre>"},{"location":"guides/game-events/#rune-activations","title":"Rune Activations","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_rune_activated\", max_events=50)\n\nfor event in result.events:\n    player = event.fields.get(\"player_id\")\n    rune_type = event.fields.get(\"rune\")\n    print(f\"[Tick {event.tick}] Player {player} activated rune type {rune_type}\")\n</code></pre>"},{"location":"guides/game-events/#combat-log-events","title":"Combat Log Events","text":"<pre><code>result = parser.parse_game_events(\"match.dem\", event_filter=\"dota_combatlog\", max_events=200)\n\nfor event in result.events:\n    log_type = event.fields.get(\"type\")\n    target = event.fields.get(\"targetname\")\n    source = event.fields.get(\"sourcename\")\n    value = event.fields.get(\"value\")\n    print(f\"[Tick {event.tick}] Type {log_type}: {source} -&gt; {target} ({value})\")\n</code></pre>"},{"location":"guides/game-events/#event-field-types","title":"Event Field Types","text":"<p>Event fields are automatically typed based on their definition:</p> Field Type Python Type string str float float long int short int byte int bool bool uint64 int"},{"location":"guides/game-events/#full-event-type-list","title":"Full Event Type List","text":"AI Summary <p>All 364 Event Types (click to expand)</p> <p>Common Dota 2 events include:</p> <p>Player Events: - <code>dota_player_kill</code> - <code>dota_player_deny</code> - <code>dota_player_pick_hero</code> - <code>dota_player_learned_ability</code> - <code>dota_player_used_ability</code> - <code>dota_player_gained_level</code> - <code>dota_player_take_tower_damage</code></p> <p>Unit Events: - <code>dota_tower_kill</code> - <code>dota_barracks_kill</code> - <code>dota_roshan_kill</code> - <code>dota_courier_lost</code> - <code>dota_npc_goal_reached</code></p> <p>Item Events: - <code>dota_item_purchased</code> - <code>dota_item_combined</code> - <code>dota_item_picked_up</code></p> <p>Rune Events: - <code>dota_rune_activated</code> - <code>dota_rune_spawned</code> - <code>dota_bounty_rune_pickup</code></p> <p>Game State: - <code>dota_match_done</code> - <code>dota_game_state_change</code> - <code>dota_team_kill_credit</code> - <code>game_rules_state_change</code></p> <p>Combat: - <code>dota_combatlog</code> - <code>dota_player_take_tower_damage</code></p> <p>Other: - <code>dota_chase_hero</code> - <code>dota_tutorial_*</code> (various tutorial events)</p> <p>Use <code>capture_types=True</code> to get the complete list for your replay.</p>"},{"location":"guides/game-events/#example-kill-timeline","title":"Example: Kill Timeline","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get all player kills\nresult = parser.parse_game_events(\"match.dem\", event_filter=\"dota_player_kill\", max_events=500)\n\nprint(\"Kill Timeline:\")\nprint(\"-\" * 50)\n\nfor event in result.events:\n    tick = event.tick\n    killer = event.fields.get(\"killer1_userid\", \"Unknown\")\n    victim = event.fields.get(\"victim_userid\", \"Unknown\")\n    assisters = []\n\n    # Check for assists\n    for i in range(2, 6):\n        assister = event.fields.get(f\"killer{i}_userid\")\n        if assister:\n            assisters.append(str(assister))\n\n    assist_str = f\" + {', '.join(assisters)}\" if assisters else \"\"\n    print(f\"[Tick {tick:6d}] Player {killer}{assist_str} killed Player {victim}\")\n</code></pre>"},{"location":"guides/game-events/#game-events-vs-combat-log","title":"Game Events vs Combat Log","text":"<p>Both provide combat information but differ:</p> Aspect Game Events Combat Log API <code>parse_game_events()</code> <code>parse_combat_log()</code> Structure Named events with typed fields Structured entries with fixed schema Types 364 event types 12 log types Best for High-level events (kills, runes) Detailed damage/heal analysis Timing Throughout match After ~12-17 minutes <p>Use game events for discrete occurrences (kills, objectives) and combat log for continuous combat data (DPS, healing).</p>"},{"location":"guides/game-events/#performance-tips","title":"Performance Tips","text":"<ol> <li>Always set <code>max_events</code> - Events can be numerous</li> <li>Use specific filters - Narrow down with <code>event_filter</code> or <code>event_names</code></li> <li>Discover first - Use <code>capture_types=True</code> to find relevant events</li> <li>Combine with other APIs - Use entity queries for context about players</li> </ol>"},{"location":"guides/modifiers/","title":"Modifiers Guide","text":"AI Summary <p>Track buffs, debuffs, and auras using <code>parse_modifiers()</code>. Each modifier entry includes parent entity, caster, ability handle, creation time, duration (-1 for permanent), stack count, and flags for aura/debuff. Use <code>auras_only=True</code> to filter aura effects. Modifiers track status effects like stuns, slows, and item buffs throughout the match. Combine with entity queries to resolve entity handles to names.</p>"},{"location":"guides/modifiers/#overview","title":"Overview","text":"<p>Modifiers represent buffs, debuffs, auras, and other status effects applied to units during the match.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    print(f\"[Tick {mod.tick}] Entity {mod.parent}: {duration_str}\")\n</code></pre>"},{"location":"guides/modifiers/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/modifiers/#all-modifiers","title":"All Modifiers","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\nprint(f\"Total modifiers captured: {result.total_modifiers}\")\n\nfor mod in result.modifiers:\n    mod_type = \"DEBUFF\" if mod.is_debuff else \"BUFF\"\n    aura_tag = \" (AURA)\" if mod.is_aura else \"\"\n\n    print(f\"[{mod.tick}] {mod_type}{aura_tag} on entity {mod.parent}\")\n</code></pre>"},{"location":"guides/modifiers/#auras-only","title":"Auras Only","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", auras_only=True, max_modifiers=200)\n\nprint(f\"Aura modifiers: {len(result.modifiers)}\")\n\nfor mod in result.modifiers:\n    print(f\"[{mod.tick}] Aura on entity {mod.parent}, stacks: {mod.stack_count}\")\n</code></pre>"},{"location":"guides/modifiers/#modifier-entry-fields","title":"Modifier Entry Fields","text":"<p>Each <code>ModifierEntry</code> contains:</p> Field Type Description <code>tick</code> int Game tick when modifier was recorded <code>net_tick</code> int Network tick <code>parent</code> int Entity handle of unit with modifier <code>caster</code> int Entity handle of caster <code>ability</code> int Ability handle that created modifier <code>modifier_class</code> int Modifier class ID <code>serial_num</code> int Serial number for tracking <code>index</code> int Modifier index <code>creation_time</code> float Game time when created <code>duration</code> float Duration in seconds (-1 = permanent) <code>stack_count</code> int Number of stacks <code>is_aura</code> bool Whether it's an aura <code>is_debuff</code> bool Whether it's a debuff"},{"location":"guides/modifiers/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/modifiers/#duration-analysis","title":"Duration Analysis","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\npermanent = []\ntimed = []\n\nfor mod in result.modifiers:\n    if mod.duration &lt; 0:\n        permanent.append(mod)\n    else:\n        timed.append(mod)\n\nprint(f\"Permanent modifiers: {len(permanent)}\")\nprint(f\"Timed modifiers: {len(timed)}\")\n\nif timed:\n    durations = [m.duration for m in timed]\n    print(f\"Duration range: {min(durations):.1f}s - {max(durations):.1f}s\")\n    print(f\"Average duration: {sum(durations)/len(durations):.1f}s\")\n</code></pre>"},{"location":"guides/modifiers/#buff-vs-debuff-count","title":"Buff vs Debuff Count","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\nbuffs = [m for m in result.modifiers if not m.is_debuff]\ndebuffs = [m for m in result.modifiers if m.is_debuff]\n\nprint(f\"Buffs: {len(buffs)}\")\nprint(f\"Debuffs: {len(debuffs)}\")\n</code></pre>"},{"location":"guides/modifiers/#stacking-modifiers","title":"Stacking Modifiers","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=500)\n\nstacking = [m for m in result.modifiers if m.stack_count &gt; 1]\n\nprint(f\"Modifiers with stacks: {len(stacking)}\")\n\nfor mod in stacking[:10]:\n    print(f\"  Entity {mod.parent}: {mod.stack_count} stacks\")\n</code></pre>"},{"location":"guides/modifiers/#modifier-timeline","title":"Modifier Timeline","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\n# Group by tick ranges (every 1000 ticks)\ntimeline = defaultdict(list)\nfor mod in result.modifiers:\n    bucket = (mod.tick // 1000) * 1000\n    timeline[bucket].append(mod)\n\nprint(\"Modifier Activity Timeline:\")\nfor tick in sorted(timeline.keys()):\n    mods = timeline[tick]\n    debuff_count = sum(1 for m in mods if m.is_debuff)\n    buff_count = len(mods) - debuff_count\n    print(f\"  Tick {tick:&gt;6}: {buff_count} buffs, {debuff_count} debuffs\")\n</code></pre>"},{"location":"guides/modifiers/#entity-modifier-history","title":"Entity Modifier History","text":"<pre><code>from collections import defaultdict\n\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=2000)\n\n# Group modifiers by parent entity\nentity_mods = defaultdict(list)\nfor mod in result.modifiers:\n    entity_mods[mod.parent].append(mod)\n\n# Find entities with most modifiers\nsorted_entities = sorted(entity_mods.items(), key=lambda x: -len(x[1]))\n\nprint(\"Entities with Most Modifiers:\")\nfor entity_id, mods in sorted_entities[:10]:\n    debuff_count = sum(1 for m in mods if m.is_debuff)\n    aura_count = sum(1 for m in mods if m.is_aura)\n    print(f\"  Entity {entity_id}: {len(mods)} total ({debuff_count} debuffs, {aura_count} auras)\")\n</code></pre>"},{"location":"guides/modifiers/#long-duration-debuffs","title":"Long Duration Debuffs","text":"<pre><code>result = parser.parse_modifiers(\"match.dem\", max_modifiers=1000)\n\n# Find long-duration debuffs (potential stuns/silences)\nlong_debuffs = [\n    m for m in result.modifiers\n    if m.is_debuff and m.duration &gt; 2.0\n]\n\nprint(f\"Long duration debuffs (&gt;2s): {len(long_debuffs)}\")\n\nfor mod in sorted(long_debuffs, key=lambda m: -m.duration)[:10]:\n    print(f\"  Duration: {mod.duration:.1f}s on entity {mod.parent}\")\n</code></pre>"},{"location":"guides/modifiers/#combining-with-entity-queries","title":"Combining with Entity Queries","text":"<p>Since modifiers reference entities by handle, you can combine with entity queries:</p> <pre><code># Get modifiers\nmods_result = parser.parse_modifiers(\"match.dem\", max_modifiers=200)\n\n# Get hero entities for reference\nentities_result = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    property_filter=[\"m_iHealth\"],\n    max_entities=10\n)\n\n# Build entity index map\nentity_map = {e.index: e.class_name for e in entities_result.entities}\n\n# Report modifiers on known entities\nfor mod in mods_result.modifiers[:20]:\n    entity_name = entity_map.get(mod.parent, f\"Unknown({mod.parent})\")\n    mod_type = \"DEBUFF\" if mod.is_debuff else \"BUFF\"\n    print(f\"{mod_type} on {entity_name}\")\n</code></pre>"},{"location":"guides/modifiers/#aura-effects","title":"Aura Effects","text":"<p>Auras are special modifiers that affect units in an area:</p> <pre><code>result = parser.parse_modifiers(\"match.dem\", auras_only=True, max_modifiers=300)\n\nprint(\"Aura Analysis:\")\nprint(\"-\" * 50)\n\n# Group by caster\nfrom collections import defaultdict\ncaster_auras = defaultdict(list)\n\nfor mod in result.modifiers:\n    caster_auras[mod.caster].append(mod)\n\nprint(f\"Unique aura casters: {len(caster_auras)}\")\n\nfor caster, auras in sorted(caster_auras.items(), key=lambda x: -len(x[1]))[:5]:\n    affected_units = len(set(m.parent for m in auras))\n    print(f\"  Caster {caster}: {len(auras)} aura applications to {affected_units} units\")\n</code></pre>"},{"location":"guides/modifiers/#performance-tips","title":"Performance Tips","text":"<ol> <li>Set max_modifiers - Modifiers can be numerous in long matches</li> <li>Use auras_only - When only interested in aura effects</li> <li>Filter client-side - Parse once, filter the results multiple times</li> </ol> <pre><code># Efficient: get all modifiers once\nall_mods = parser.parse_modifiers(\"match.dem\", max_modifiers=2000)\n\n# Filter in Python\ndebuffs = [m for m in all_mods.modifiers if m.is_debuff]\nauras = [m for m in all_mods.modifiers if m.is_aura]\npermanent = [m for m in all_mods.modifiers if m.duration &lt; 0]\n</code></pre>"},{"location":"guides/modifiers/#common-modifier-patterns","title":"Common Modifier Patterns","text":""},{"location":"guides/modifiers/#permanent-buffs-passivesitems","title":"Permanent Buffs (Passives/Items)","text":"<pre><code>permanent_buffs = [\n    m for m in result.modifiers\n    if m.duration &lt; 0 and not m.is_debuff\n]\n</code></pre>"},{"location":"guides/modifiers/#control-effects-stunsroots","title":"Control Effects (Stuns/Roots)","text":"<pre><code># Long-duration debuffs are often control effects\ncontrol_effects = [\n    m for m in result.modifiers\n    if m.is_debuff and 0 &lt; m.duration &lt;= 5.0\n]\n</code></pre>"},{"location":"guides/modifiers/#dothot-effects","title":"DoT/HoT Effects","text":"<pre><code># Short-duration stackable effects\ndot_hot = [\n    m for m in result.modifiers\n    if m.stack_count &gt; 0 and 0 &lt; m.duration &lt; 15\n]\n</code></pre>"},{"location":"guides/modifiers/#important-notes","title":"Important Notes","text":"<p>Note</p> <p>Modifiers track when effects are applied. The <code>parent</code> and <code>caster</code> fields are entity handles, not player IDs. Use entity queries to resolve these to unit types.</p>"},{"location":"guides/modifiers/#duration-values","title":"Duration Values","text":"Duration Meaning <code>-1</code> Permanent (passives, items) <code>0</code> Instant effect <code>&gt; 0</code> Timed effect in seconds"},{"location":"guides/modifiers/#entity-handles","title":"Entity Handles","text":"<p>The <code>parent</code>, <code>caster</code>, and <code>ability</code> fields are entity handles: - Use entity queries to get entity details by index - Handles may reference entities no longer in the game - Handle 0 typically means no specific source</p>"},{"location":"guides/unit-orders/","title":"Unit Orders Guide","text":"AI Summary <p>Parse player commands using <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code>. Detect attack commands (<code>order_type=4</code>) to analyze creep aggro triggers, last-hit patterns, and harass behavior. Each order includes player entity, order type, target, position, and ability. Key for lane mechanics analysis: when a hero issues ATTACK_TARGET on enemy hero within 500 units of enemy creeps, it triggers creep aggro.</p>"},{"location":"guides/unit-orders/#overview","title":"Overview","text":"<p>The <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> callback captures every command a player issues to their units. This is essential for analyzing:</p> <ul> <li>Creep aggro triggers - When players right-click enemy heroes</li> <li>Last-hit patterns - Attack commands on creeps</li> <li>Ability usage - Cast orders with targets</li> <li>Movement patterns - Move and patrol commands</li> <li>Micro decisions - Multi-unit control</li> </ul> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=10000\n)\n\nfor msg in result.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n    target = msg.data.get(\"target_index\", 0)\n    print(f\"[{msg.tick}] Order {order_type}, target={target}\")\n</code></pre>"},{"location":"guides/unit-orders/#message-structure","title":"Message Structure","text":""},{"location":"guides/unit-orders/#fields","title":"Fields","text":"Field Type Description <code>entindex</code> int Entity index of the player/unit issuing the order <code>order_type</code> int Type of order (see Order Types below) <code>units</code> list[int] Entity indices of units receiving the order <code>target_index</code> int Target entity index (for targeted orders) <code>ability_id</code> int Ability ID (for cast orders) <code>position</code> dict Target position <code>{x, y, z}</code> (for position orders) <code>queue</code> bool Whether order is queued (shift-click) <code>sequence_number</code> int Order sequence number <code>flags</code> int Order flags"},{"location":"guides/unit-orders/#order-types","title":"Order Types","text":"<p>The <code>order_type</code> field maps to <code>dotaunitorder_t</code> enum values:</p>"},{"location":"guides/unit-orders/#movement-orders","title":"Movement Orders","text":"Value Name Description 0 <code>NONE</code> No order 1 <code>MOVE_TO_POSITION</code> Move to ground position (right-click ground) 2 <code>MOVE_TO_TARGET</code> Move to/follow a unit 28 <code>MOVE_TO_DIRECTION</code> Move in direction 29 <code>PATROL</code> Patrol command 39 <code>MOVE_RELATIVE</code> Relative movement"},{"location":"guides/unit-orders/#attack-orders","title":"Attack Orders","text":"Value Name Description 3 <code>ATTACK_MOVE</code> Attack-move (A-click ground) 4 <code>ATTACK_TARGET</code> Attack specific target (right-click enemy)"},{"location":"guides/unit-orders/#ability-orders","title":"Ability Orders","text":"Value Name Description 5 <code>CAST_POSITION</code> Cast ability on ground 6 <code>CAST_TARGET</code> Cast ability on unit 7 <code>CAST_TARGET_TREE</code> Cast ability on tree 8 <code>CAST_NO_TARGET</code> Cast ability (no target) 9 <code>CAST_TOGGLE</code> Toggle ability 20 <code>CAST_TOGGLE_AUTO</code> Toggle autocast 40 <code>CAST_TOGGLE_ALT</code> Alt toggle"},{"location":"guides/unit-orders/#control-orders","title":"Control Orders","text":"Value Name Description 10 <code>HOLD_POSITION</code> Hold position (H key) 21 <code>STOP</code> Stop command (S key) 33 <code>CONTINUE</code> Continue previous order"},{"location":"guides/unit-orders/#item-orders","title":"Item Orders","text":"Value Name Description 12 <code>DROP_ITEM</code> Drop item on ground 13 <code>GIVE_ITEM</code> Give item to ally 14 <code>PICKUP_ITEM</code> Pick up item 15 <code>PICKUP_RUNE</code> Pick up rune 16 <code>PURCHASE_ITEM</code> Purchase item 17 <code>SELL_ITEM</code> Sell item 18 <code>DISASSEMBLE_ITEM</code> Disassemble item 19 <code>MOVE_ITEM</code> Move item in inventory 41 <code>CONSUME_ITEM</code> Consume item"},{"location":"guides/unit-orders/#other-orders","title":"Other Orders","text":"Value Name Description 11 <code>TRAIN_ABILITY</code> Level up ability 22 <code>TAUNT</code> Taunt 23 <code>BUYBACK</code> Buyback 24 <code>GLYPH</code> Activate glyph 26 <code>CAST_RUNE</code> Use bottle on rune 27 <code>PING_ABILITY</code> Ping ability cooldown 30 <code>VECTOR_TARGET_POSITION</code> Vector targeted ability 31 <code>RADAR</code> Scan ability"},{"location":"guides/unit-orders/#creep-aggro-detection","title":"Creep Aggro Detection","text":""},{"location":"guides/unit-orders/#how-creep-aggro-works-in-dota-2","title":"How Creep Aggro Works in Dota 2","text":"<p>Creep aggro is triggered when: 1. A hero issues an attack command (<code>order_type=4</code>) on an enemy hero 2. The hero is within 500 units of enemy lane creeps 3. This puts creeps on a 2.5 second aggro cooldown</p>"},{"location":"guides/unit-orders/#detecting-aggro-triggers","title":"Detecting Aggro Triggers","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get all attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\nATTACK_TARGET = 4\n\nattack_commands = []\nfor msg in orders.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n\n    if order_type == ATTACK_TARGET:\n        attack_commands.append({\n            \"tick\": msg.tick,\n            \"player_entity\": msg.data.get(\"entindex\"),\n            \"target_entity\": msg.data.get(\"target_index\"),\n            \"units\": msg.data.get(\"units\", []),\n            \"queued\": msg.data.get(\"queue\", False),\n        })\n\nprint(f\"Found {len(attack_commands)} attack commands\")\n</code></pre>"},{"location":"guides/unit-orders/#identifying-hero-on-hero-attacks","title":"Identifying Hero-on-Hero Attacks","text":"<p>To determine if an attack triggers creep aggro, you need to: 1. Check if the attacker is a hero 2. Check if the target is an enemy hero 3. Check proximity to enemy creeps (requires entity position data)</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Get entity data to identify heroes\nentities = parser.query_entities(\n    \"match.dem\",\n    class_filter=\"Hero\",\n    max_entities=20\n)\n\n# Build hero entity index set\nhero_entities = {e.index for e in entities.entities}\n\nATTACK_TARGET = 4\n\npotential_aggro_triggers = []\nfor msg in orders.messages:\n    if msg.data.get(\"order_type\") != ATTACK_TARGET:\n        continue\n\n    target = msg.data.get(\"target_index\", 0)\n\n    # Check if target is a hero (potential aggro trigger)\n    if target in hero_entities:\n        potential_aggro_triggers.append({\n            \"tick\": msg.tick,\n            \"attacker\": msg.data.get(\"entindex\"),\n            \"target_hero\": target,\n        })\n\nprint(f\"Potential aggro triggers: {len(potential_aggro_triggers)}\")\n</code></pre>"},{"location":"guides/unit-orders/#full-aggro-analysis-with-positions","title":"Full Aggro Analysis with Positions","text":"<p>For complete aggro analysis, combine orders with entity snapshots:</p> <pre><code>from python_manta import MantaParser\nimport math\n\nparser = MantaParser()\n\n# Parse attack orders\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Get attack target orders\nATTACK_TARGET = 4\nattack_ticks = []\n\nfor msg in orders.messages:\n    if msg.data.get(\"order_type\") == ATTACK_TARGET:\n        attack_ticks.append(msg.tick)\n\n# Sample entity positions at attack moments\n# Use unique ticks to avoid duplicates\nunique_ticks = sorted(set(attack_ticks))[:100]  # Limit for performance\n\nif unique_ticks:\n    snapshots = parser.parse_entities(\n        \"match.dem\",\n        target_ticks=unique_ticks,\n        max_snapshots=100\n    )\n\n    # Analyze each snapshot for creep proximity\n    AGGRO_RANGE = 500\n\n    for snapshot in snapshots.snapshots:\n        # Get hero positions\n        heroes = {h.hero_name: (h.x, h.y) for h in snapshot.heroes if h.hero_name}\n\n        # Would need creep positions from entity data\n        # This is a simplified example\n        print(f\"Tick {snapshot.tick}: {len(heroes)} heroes tracked\")\n</code></pre>"},{"location":"guides/unit-orders/#lane-mechanics-analysis","title":"Lane Mechanics Analysis","text":""},{"location":"guides/unit-orders/#last-hit-pattern-detection","title":"Last-Hit Pattern Detection","text":"<pre><code>from python_manta import MantaParser\nfrom collections import defaultdict\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=100000\n)\n\nATTACK_TARGET = 4\nATTACK_MOVE = 3\n\nplayer_attacks = defaultdict(list)\n\nfor msg in orders.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n\n    if order_type in [ATTACK_TARGET, ATTACK_MOVE]:\n        player = msg.data.get(\"entindex\")\n        player_attacks[player].append({\n            \"tick\": msg.tick,\n            \"type\": \"target\" if order_type == ATTACK_TARGET else \"move\",\n            \"target\": msg.data.get(\"target_index\"),\n        })\n\n# Analyze attack patterns\nfor player, attacks in player_attacks.items():\n    target_attacks = [a for a in attacks if a[\"type\"] == \"target\"]\n    move_attacks = [a for a in attacks if a[\"type\"] == \"move\"]\n\n    print(f\"Player entity {player}:\")\n    print(f\"  Direct attacks: {len(target_attacks)}\")\n    print(f\"  Attack-moves: {len(move_attacks)}\")\n</code></pre>"},{"location":"guides/unit-orders/#harass-timing-analysis","title":"Harass Timing Analysis","text":"<p>Analyze when players harass vs last-hit:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Get orders and combat log for correlation\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Filter to laning phase (first 10 minutes ~ 18000 ticks at 30 ticks/sec)\nLANING_END_TICK = 18000\nATTACK_TARGET = 4\n\nlaning_attacks = []\nfor msg in orders.messages:\n    if msg.tick &gt; LANING_END_TICK:\n        break\n\n    if msg.data.get(\"order_type\") == ATTACK_TARGET:\n        laning_attacks.append({\n            \"tick\": msg.tick,\n            \"player\": msg.data.get(\"entindex\"),\n            \"target\": msg.data.get(\"target_index\"),\n        })\n\nprint(f\"Laning phase attacks: {len(laning_attacks)}\")\n\n# Group by time windows (30 second intervals)\nfrom collections import defaultdict\nTICKS_PER_30_SEC = 900\n\ntime_windows = defaultdict(int)\nfor attack in laning_attacks:\n    window = attack[\"tick\"] // TICKS_PER_30_SEC\n    time_windows[window] += 1\n\nprint(\"\\nAttack frequency by 30-second windows:\")\nfor window, count in sorted(time_windows.items()):\n    minutes = (window * 30) // 60\n    seconds = (window * 30) % 60\n    print(f\"  {minutes}:{seconds:02d}: {count} attacks\")\n</code></pre>"},{"location":"guides/unit-orders/#multi-unit-control-analysis","title":"Multi-Unit Control Analysis","text":"<p>For heroes with summons or illusions:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\n# Find orders with multiple units\nmulti_unit_orders = []\nfor msg in orders.messages:\n    units = msg.data.get(\"units\", [])\n    if len(units) &gt; 1:\n        multi_unit_orders.append({\n            \"tick\": msg.tick,\n            \"order_type\": msg.data.get(\"order_type\"),\n            \"unit_count\": len(units),\n            \"units\": units,\n        })\n\nprint(f\"Multi-unit orders: {len(multi_unit_orders)}\")\n\n# Analyze micro patterns\nfrom collections import Counter\norder_types = Counter(o[\"order_type\"] for o in multi_unit_orders)\nprint(\"\\nMulti-unit order types:\")\nfor order_type, count in order_types.most_common():\n    print(f\"  Type {order_type}: {count}\")\n</code></pre>"},{"location":"guides/unit-orders/#queued-commands-analysis","title":"Queued Commands Analysis","text":"<p>Detect shift-queued commands:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\norders = parser.parse_universal(\n    \"match.dem\",\n    \"CDOTAUserMsg_SpectatorPlayerUnitOrders\",\n    max_messages=50000\n)\n\nqueued_orders = []\nfor msg in orders.messages:\n    if msg.data.get(\"queue\", False):\n        queued_orders.append({\n            \"tick\": msg.tick,\n            \"order_type\": msg.data.get(\"order_type\"),\n            \"player\": msg.data.get(\"entindex\"),\n        })\n\nprint(f\"Queued orders: {len(queued_orders)}\")\nprint(f\"Queue usage rate: {len(queued_orders) / len(orders.messages) * 100:.1f}%\")\n</code></pre>"},{"location":"guides/unit-orders/#performance-considerations","title":"Performance Considerations","text":"<p>High Volume Callback</p> <p><code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> fires frequently - expect 10,000-50,000+ messages per match. Always set <code>max_messages</code> appropriately.</p>"},{"location":"guides/unit-orders/#recommended-limits","title":"Recommended Limits","text":"<pre><code># For full match analysis\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 100000)\n\n# For laning phase only\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 20000)\n\n# For sampling/overview\norders = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 5000)\n</code></pre>"},{"location":"guides/unit-orders/#efficient-filtering","title":"Efficient Filtering","text":"<p>Filter early to reduce memory:</p> <pre><code>ATTACK_TARGET = 4\nATTACK_MOVE = 3\n\n# Process in batches if needed\nattack_orders = []\nresult = parser.parse_universal(\"match.dem\", \"SpectatorPlayerUnitOrders\", 50000)\n\nfor msg in result.messages:\n    order_type = msg.data.get(\"order_type\", 0)\n    if order_type in [ATTACK_TARGET, ATTACK_MOVE]:\n        attack_orders.append(msg)\n\n# Now work with filtered subset\nprint(f\"Attack orders: {len(attack_orders)} of {len(result.messages)} total\")\n</code></pre>"},{"location":"guides/unit-orders/#related-apis","title":"Related APIs","text":"Task API Entity positions <code>parse_entities()</code> Combat damage <code>parse_combat_log()</code> Hero state <code>query_entities(class_filter=\"Hero\")</code> Ability usage <code>parse_universal(\"CDOTAUserMsg_UnitEvent\")</code>"},{"location":"guides/unit-orders/#order-type-reference","title":"Order Type Reference","text":"<p>Complete <code>dotaunitorder_t</code> enum:</p> <pre><code>0  = DOTA_UNIT_ORDER_NONE\n1  = DOTA_UNIT_ORDER_MOVE_TO_POSITION\n2  = DOTA_UNIT_ORDER_MOVE_TO_TARGET\n3  = DOTA_UNIT_ORDER_ATTACK_MOVE\n4  = DOTA_UNIT_ORDER_ATTACK_TARGET\n5  = DOTA_UNIT_ORDER_CAST_POSITION\n6  = DOTA_UNIT_ORDER_CAST_TARGET\n7  = DOTA_UNIT_ORDER_CAST_TARGET_TREE\n8  = DOTA_UNIT_ORDER_CAST_NO_TARGET\n9  = DOTA_UNIT_ORDER_CAST_TOGGLE\n10 = DOTA_UNIT_ORDER_HOLD_POSITION\n11 = DOTA_UNIT_ORDER_TRAIN_ABILITY\n12 = DOTA_UNIT_ORDER_DROP_ITEM\n13 = DOTA_UNIT_ORDER_GIVE_ITEM\n14 = DOTA_UNIT_ORDER_PICKUP_ITEM\n15 = DOTA_UNIT_ORDER_PICKUP_RUNE\n16 = DOTA_UNIT_ORDER_PURCHASE_ITEM\n17 = DOTA_UNIT_ORDER_SELL_ITEM\n18 = DOTA_UNIT_ORDER_DISASSEMBLE_ITEM\n19 = DOTA_UNIT_ORDER_MOVE_ITEM\n20 = DOTA_UNIT_ORDER_CAST_TOGGLE_AUTO\n21 = DOTA_UNIT_ORDER_STOP\n22 = DOTA_UNIT_ORDER_TAUNT\n23 = DOTA_UNIT_ORDER_BUYBACK\n24 = DOTA_UNIT_ORDER_GLYPH\n25 = DOTA_UNIT_ORDER_EJECT_ITEM_FROM_STASH\n26 = DOTA_UNIT_ORDER_CAST_RUNE\n27 = DOTA_UNIT_ORDER_PING_ABILITY\n28 = DOTA_UNIT_ORDER_MOVE_TO_DIRECTION\n29 = DOTA_UNIT_ORDER_PATROL\n30 = DOTA_UNIT_ORDER_VECTOR_TARGET_POSITION\n31 = DOTA_UNIT_ORDER_RADAR\n32 = DOTA_UNIT_ORDER_SET_ITEM_COMBINE_LOCK\n33 = DOTA_UNIT_ORDER_CONTINUE\n34 = DOTA_UNIT_ORDER_VECTOR_TARGET_CANCELED\n35 = DOTA_UNIT_ORDER_CAST_RIVER_PAINT\n36 = DOTA_UNIT_ORDER_PREGAME_ADJUST_ITEM_ASSIGNMENT\n37 = DOTA_UNIT_ORDER_DROP_ITEM_AT_FOUNTAIN\n38 = DOTA_UNIT_ORDER_TAKE_ITEM_FROM_NEUTRAL_ITEM_STASH\n39 = DOTA_UNIT_ORDER_MOVE_RELATIVE\n40 = DOTA_UNIT_ORDER_CAST_TOGGLE_ALT\n41 = DOTA_UNIT_ORDER_CONSUME_ITEM\n42 = DOTA_UNIT_ORDER_SET_ITEM_MARK_FOR_SELL\n</code></pre>"},{"location":"guides/universal/","title":"Universal Messages Guide","text":"AI Summary <p>Parse any of 272 message types using <code>parse_universal()</code>. Filter by callback name (substring match). Common messages: <code>CDOTAUserMsg_ChatMessage</code> (chat), <code>CDOTAUserMsg_LocationPing</code> (pings), <code>CDOTAUserMsg_ItemPurchased</code> (items), <code>CDOTAUserMsg_UnitEvent</code> (abilities), <code>CDOTAUserMsg_OverheadEvent</code> (damage numbers). Each message has tick, net_tick, type, and data dict. Always set max_messages to avoid memory issues. Message data structure varies by type.</p>"},{"location":"guides/universal/#overview","title":"Overview","text":"<p>The universal parser can extract any of the 272 message callback types from a replay. It's the most flexible parsing method.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\nfor msg in result.messages:\n    print(f\"[{msg.tick}] {msg.type}: {msg.data}\")\n</code></pre>"},{"location":"guides/universal/#message-filtering","title":"Message Filtering","text":""},{"location":"guides/universal/#substring-matching","title":"Substring Matching","text":"<p>The filter matches callback names as substrings:</p> <pre><code># Matches CDOTAUserMsg_ChatMessage, CDOTAUserMsg_ChatEvent, etc.\nchat = parser.parse_universal(\"match.dem\", \"Chat\", 100)\n\n# Matches CDOTAUserMsg_LocationPing\npings = parser.parse_universal(\"match.dem\", \"Ping\", 50)\n\n# Matches multiple message types containing \"Unit\"\nunits = parser.parse_universal(\"match.dem\", \"Unit\", 200)\n</code></pre>"},{"location":"guides/universal/#exact-callback-names","title":"Exact Callback Names","text":"<p>For precise matching, use the full callback name:</p> <pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n</code></pre>"},{"location":"guides/universal/#all-messages","title":"All Messages","text":"<p>Use empty string to capture all message types (use with caution):</p> <pre><code># WARNING: Can produce millions of messages!\nall_messages = parser.parse_universal(\"match.dem\", \"\", 1000)\n\n# See what types were captured\ntypes = set(msg.type for msg in all_messages.messages)\nprint(f\"Captured {len(types)} different message types\")\n</code></pre>"},{"location":"guides/universal/#common-message-types","title":"Common Message Types","text":""},{"location":"guides/universal/#chat-messages","title":"Chat Messages","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 200)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"source_player_id\")\n    text = msg.data.get(\"message_text\", \"\")\n    chat_type = msg.data.get(\"chat_type\", 0)  # 1=all, 2=team, etc.\n\n    type_name = {1: \"All\", 2: \"Team\", 3: \"Spectator\"}.get(chat_type, \"Unknown\")\n    print(f\"[{msg.tick}] Player {player_id} ({type_name}): {text}\")\n</code></pre>"},{"location":"guides/universal/#map-pings","title":"Map Pings","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_LocationPing\", 100)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    ping_data = msg.data.get(\"location_ping\", {})\n    x = ping_data.get(\"x\", 0)\n    y = ping_data.get(\"y\", 0)\n    ping_type = ping_data.get(\"type\", 0)\n\n    print(f\"[{msg.tick}] Player {player_id} pinged ({x}, {y}) type={ping_type}\")\n</code></pre>"},{"location":"guides/universal/#item-purchases","title":"Item Purchases","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ItemPurchased\", 500)\n\nfrom collections import defaultdict\npurchases = defaultdict(list)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    item_id = msg.data.get(\"item_ability\")\n\n    purchases[player_id].append(item_id)\n\nfor player_id, items in purchases.items():\n    print(f\"Player {player_id}: {len(items)} items purchased\")\n</code></pre>"},{"location":"guides/universal/#unit-events-ability-usage","title":"Unit Events (Ability Usage)","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_UnitEvent\", 200)\n\nfor msg in result.messages:\n    event_type = msg.data.get(\"msg_type\", 0)\n    entity = msg.data.get(\"entity_index\")\n\n    # Event types: 1=spawn, 2=speech, 3=add_gesture, etc.\n    print(f\"[{msg.tick}] Entity {entity}: event type {event_type}\")\n</code></pre>"},{"location":"guides/universal/#overhead-events-damage-numbers","title":"Overhead Events (Damage Numbers)","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_OverheadEvent\", 300)\n\nfor msg in result.messages:\n    event_type = msg.data.get(\"message_type\", 0)\n    value = msg.data.get(\"value\", 0)\n    target = msg.data.get(\"target_player_entindex\")\n\n    # Types: 1=gold, 2=crit, 3=heal, 4=damage, 5=mana, 6=miss, etc.\n    print(f\"[{msg.tick}] Type {event_type}: {value} on entity {target}\")\n</code></pre>"},{"location":"guides/universal/#game-rules-state","title":"Game Rules State","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_GamerulesStateChanged\", 20)\n\nfor msg in result.messages:\n    state = msg.data.get(\"state\", 0)\n\n    state_names = {\n        0: \"INIT\", 1: \"WAIT_FOR_PLAYERS_TO_LOAD\", 2: \"HERO_SELECTION\",\n        3: \"STRATEGY_TIME\", 4: \"PRE_GAME\", 5: \"GAME_IN_PROGRESS\",\n        6: \"POST_GAME\", 7: \"DISCONNECT\"\n    }\n    name = state_names.get(state, f\"UNKNOWN({state})\")\n    print(f\"[{msg.tick}] Game state changed to: {name}\")\n</code></pre>"},{"location":"guides/universal/#message-data-structure","title":"Message Data Structure","text":"<p>Each <code>MessageEvent</code> contains:</p> Field Type Description <code>type</code> str Callback name (e.g., \"CDOTAUserMsg_ChatMessage\") <code>tick</code> int Game tick when message occurred <code>net_tick</code> int Network tick <code>data</code> dict Message-specific payload <code>game_time</code> float Game time in seconds (negative before horn) <code>game_time_str</code> str Formatted game time (e.g., \"-0:40\", \"5:32\") <p>The <code>data</code> dictionary structure varies by message type.</p>"},{"location":"guides/universal/#message-categories","title":"Message Categories","text":""},{"location":"guides/universal/#user-messages-cdotausermsg_","title":"User Messages (CDOTAUserMsg_*)","text":"<p>Game events visible to players: - <code>CDOTAUserMsg_ChatMessage</code> - Chat text - <code>CDOTAUserMsg_ChatEvent</code> - Chat events (kills, items) - <code>CDOTAUserMsg_LocationPing</code> - Map pings - <code>CDOTAUserMsg_ItemPurchased</code> - Item buys - <code>CDOTAUserMsg_UnitEvent</code> - Unit actions - <code>CDOTAUserMsg_OverheadEvent</code> - Floating numbers - <code>CDOTAUserMsg_ParticleManager</code> - Visual effects - <code>CDOTAUserMsg_CreateLinearProjectile</code> - Projectiles</p>"},{"location":"guides/universal/#network-messages-cnetmsg_","title":"Network Messages (CNETMsg_*)","text":"<p>Low-level network data: - <code>CNETMsg_Tick</code> - Tick sync (very frequent!) - <code>CNETMsg_SetConVar</code> - Console variables - <code>CNETMsg_StringCmd</code> - String commands</p>"},{"location":"guides/universal/#service-messages-csvcmsg_","title":"Service Messages (CSVCMsg_*)","text":"<p>Server-to-client: - <code>CSVCMsg_ServerInfo</code> - Server info - <code>CSVCMsg_CreateStringTable</code> - String tables - <code>CSVCMsg_UpdateStringTable</code> - Table updates - <code>CSVCMsg_PacketEntities</code> - Entity updates</p>"},{"location":"guides/universal/#demo-messages-cdemo","title":"Demo Messages (CDemo*)","text":"<p>Recording-related: - <code>CDemoFileHeader</code> - File header - <code>CDemoFileInfo</code> - Match info - <code>CDemoFullPacket</code> - Full state snapshot</p>"},{"location":"guides/universal/#analysis-examples","title":"Analysis Examples","text":""},{"location":"guides/universal/#chat-timeline","title":"Chat Timeline","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 500)\n\nprint(\"Chat Timeline:\")\nprint(\"-\" * 60)\n\nfor msg in result.messages:\n    tick = msg.tick\n    player = msg.data.get(\"source_player_id\", \"?\")\n    text = msg.data.get(\"message_text\", \"\")\n\n    if text:  # Skip empty messages\n        print(f\"[{tick:&gt;7}] Player {player}: {text}\")\n</code></pre>"},{"location":"guides/universal/#ping-heatmap-data","title":"Ping Heatmap Data","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_LocationPing\", 500)\n\nfrom collections import defaultdict\nping_locations = defaultdict(int)\n\nfor msg in result.messages:\n    ping = msg.data.get(\"location_ping\", {})\n    # Bucket to 500-unit grid\n    x = (ping.get(\"x\", 0) // 500) * 500\n    y = (ping.get(\"y\", 0) // 500) * 500\n    ping_locations[(x, y)] += 1\n\nprint(\"Ping Hotspots:\")\nfor loc, count in sorted(ping_locations.items(), key=lambda x: -x[1])[:10]:\n    print(f\"  ({loc[0]}, {loc[1]}): {count} pings\")\n</code></pre>"},{"location":"guides/universal/#message-type-statistics","title":"Message Type Statistics","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"\", 10000)\n\nfrom collections import Counter\ntype_counts = Counter(msg.type for msg in result.messages)\n\nprint(\"Message Type Distribution:\")\nfor msg_type, count in type_counts.most_common(20):\n    print(f\"  {msg_type}: {count}\")\n</code></pre>"},{"location":"guides/universal/#item-build-order","title":"Item Build Order","text":"<pre><code>result = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ItemPurchased\", 1000)\n\nfrom collections import defaultdict\nplayer_items = defaultdict(list)\n\nfor msg in result.messages:\n    player_id = msg.data.get(\"player_id\")\n    item_id = msg.data.get(\"item_ability\")\n\n    player_items[player_id].append({\n        \"tick\": msg.tick,\n        \"item\": item_id\n    })\n\n# Print build order for each player\nfor player_id, items in sorted(player_items.items()):\n    print(f\"\\nPlayer {player_id} item order:\")\n    for i, item in enumerate(items, 1):\n        print(f\"  {i}. Item {item['item']} at tick {item['tick']}\")\n</code></pre>"},{"location":"guides/universal/#performance-warning","title":"Performance Warning","text":"<p>Warning</p> <p>Some message types generate thousands or millions of entries per match. Always set <code>max_messages</code> to prevent memory exhaustion.</p>"},{"location":"guides/universal/#high-frequency-messages","title":"High-Frequency Messages","text":"Message Type Frequency Notes <code>CNETMsg_Tick</code> ~1M+ Every network tick <code>CSVCMsg_PacketEntities</code> ~500K+ Entity updates <code>CDOTAUserMsg_ParticleManager</code> ~100K+ Visual effects <code>CDOTAUserMsg_OverheadEvent</code> ~50K+ Damage/heal numbers"},{"location":"guides/universal/#recommended-limits","title":"Recommended Limits","text":"<pre><code># Safe limits for common types\nchat = parser.parse_universal(\"match.dem\", \"ChatMessage\", 1000)\npings = parser.parse_universal(\"match.dem\", \"LocationPing\", 500)\nitems = parser.parse_universal(\"match.dem\", \"ItemPurchased\", 2000)\n\n# For analysis, sample large types\ntick_sample = parser.parse_universal(\"match.dem\", \"CNETMsg_Tick\", 100)\n</code></pre>"},{"location":"guides/universal/#all-272-callbacks-reference","title":"All 272 Callbacks Reference","text":"<p>For a complete list of all available callbacks, see the Callbacks Reference.</p> <p>Common useful callbacks:</p> Callback Use Case <code>CDOTAUserMsg_ChatMessage</code> Player chat <code>CDOTAUserMsg_LocationPing</code> Map pings <code>CDOTAUserMsg_ItemPurchased</code> Item builds <code>CDOTAUserMsg_UnitEvent</code> Unit actions <code>CDOTAUserMsg_OverheadEvent</code> Combat numbers <code>CDOTAUserMsg_GamerulesStateChanged</code> Game phase changes <code>CDOTAUserMsg_ChatEvent</code> Kill/event notifications <code>CMsgDOTACombatLogEntry</code> Detailed combat data <code>CDemoFileInfo</code> Match metadata"},{"location":"guides/use-cases/","title":"MCP Server Use Cases","text":"AI Summary <p>Validates python-manta can extract all data required by MCP Replay Dota 2 Server. Covers 5 core analysis patterns: Teamfight Analysis (deaths, damage, abilities), Carry Farm Tracking (item timings, gold/XP), Gank Analysis (kill sequences, damage breakdown), Objective Control (Roshan, towers), and Laning Phase Comparison (hero stats at intervals). All examples use Match 8447659831 (Team Spirit vs Tundra) with verified expected values.</p>"},{"location":"guides/use-cases/#reference-match-team-spirit-vs-tundra","title":"Reference Match: Team Spirit vs Tundra","text":"<p>All examples use Match 8447659831 as the reference replay:</p> Property Value Match ID 8447659831 Teams Team Spirit (TSpirit) vs Tundra Winner Radiant (Team Spirit) Game Mode Captains Mode <p>Radiant (Team Spirit):</p> <ul> <li>Yatoro: Troll Warlord (carry)</li> <li>Collapse: Bristleback (offlane)</li> <li>Larl: Monkey King (mid)</li> <li>Miposhka: Chen (support)</li> <li>rue: Hoodwink (support)</li> </ul> <p>Dire (Tundra):</p> <ul> <li>Crystallis: Faceless Void (carry)</li> <li>33: Lycan (offlane)</li> <li>bzm: Storm Spirit (mid)</li> <li>Saksa: Shadow Shaman (support)</li> <li>Tobi: Pugna (support)</li> </ul> <p>Key Events:</p> Event Time Details First Kill 03:07 Pugna kills Hoodwink (nether ward) First Roshan 19:17 Radiant (Troll Warlord) Second Roshan 28:57 Radiant (Troll Warlord) First Tower 11:15 Dire bot T1 destroyed"},{"location":"guides/use-cases/#use-case-1-analyzing-a-teamfight","title":"Use Case 1: Analyzing a Teamfight","text":"<p>Extract death events, damage sequences, and ability usage for fight reconstruction.</p> <p>Required Data:</p> <ul> <li><code>get_hero_deaths()</code> - game_time, victim, killer, ability</li> <li><code>get_fight_combat_log()</code> - participants, damage events, ability casts</li> </ul> <pre><code>from python_manta import Parser, CombatLogType\n\ndef analyze_teamfight(demo_path: str, fight_start: float, fight_end: float):\n    parser = Parser(demo_path)\n    result = parser.parse(combat_log={\"max_entries\": 0})\n\n    # Get deaths in fight window\n    deaths = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.DEATH.value\n        and \"hero\" in e.target_name.lower()\n        and fight_start &lt;= e.game_time &lt;= fight_end\n    ]\n\n    # Get damage events\n    damage = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.DAMAGE.value\n        and fight_start &lt;= e.game_time &lt;= fight_end\n    ]\n\n    # Get ability casts\n    abilities = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.ABILITY.value\n        and fight_start &lt;= e.game_time &lt;= fight_end\n    ]\n\n    print(f\"Fight Analysis ({fight_start:.0f}s - {fight_end:.0f}s)\")\n    print(\"=\" * 50)\n    print(f\"Deaths: {len(deaths)}\")\n    print(f\"Damage Events: {len(damage)}\")\n    print(f\"Ability Casts: {len(abilities)}\")\n\n    print(\"\\nDeath Sequence:\")\n    for d in deaths:\n        victim = d.target_name.replace(\"npc_dota_hero_\", \"\")\n        killer = d.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        mins = int(d.game_time // 60)\n        secs = int(d.game_time % 60)\n        print(f\"  [{mins:02d}:{secs:02d}] {killer} killed {victim}\")\n\n# Analyze fight around first Roshan (19:17)\nanalyze_teamfight(\"match.dem\", fight_start=1127, fight_end=1167)\n</code></pre> <p>Expected Output (Roshan Fight at 19:17): <pre><code>Fight Analysis (1127s - 1167s)\n==================================================\nDeaths: 0\nDamage Events: 847\nAbility Casts: 23\n\nDeath Sequence:\n  (no hero deaths - successful Roshan take)\n</code></pre></p>"},{"location":"guides/use-cases/#use-case-2-tracking-carry-farm","title":"Use Case 2: Tracking Carry Farm","text":"<p>Track item purchase timings, gold income, and XP progression for a carry player.</p> <p>Required Data:</p> <ul> <li><code>get_item_purchases()</code> - game_time, item name</li> <li><code>get_stats_at_minute()</code> - last_hits, net_worth, kills, deaths</li> </ul> <pre><code>from python_manta import Parser, CombatLogType\n\ndef track_carry_farm(demo_path: str, hero_name: str):\n    parser = Parser(demo_path)\n    result = parser.parse(combat_log={\"max_entries\": 0})\n\n    target = f\"npc_dota_hero_{hero_name}\"\n\n    # Get item purchases\n    purchases = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.PURCHASE.value\n        and e.target_name == target\n    ]\n\n    # Key items to track\n    key_items = [\n        \"item_phase_boots\", \"item_bfury\", \"item_sange_and_yasha\",\n        \"item_black_king_bar\", \"item_satanic\", \"item_butterfly\"\n    ]\n\n    print(f\"Item Timeline: {hero_name}\")\n    print(\"=\" * 50)\n\n    for item in key_items:\n        matches = [p for p in purchases if p.value_name == item]\n        if matches:\n            p = matches[-1]  # Last match is completed item\n            mins = int(p.game_time // 60)\n            secs = int(p.game_time % 60)\n            item_name = item.replace(\"item_\", \"\")\n            print(f\"  {item_name:20} @ {mins:02d}:{secs:02d}\")\n\n    # Get gold earned\n    gold = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.GOLD.value\n        and e.target_name == target\n    ]\n    total_gold = sum(e.value for e in gold)\n    print(f\"\\nTotal Gold Earned: {total_gold:,}\")\n\n# Track Yatoro's Troll Warlord\ntrack_carry_farm(\"match.dem\", \"troll_warlord\")\n</code></pre> <p>Expected Output (Yatoro's Troll Warlord): <pre><code>Item Timeline: troll_warlord\n==================================================\n  phase_boots          @ 05:35\n  bfury                @ 12:07\n  sange_and_yasha      @ 16:54\n  black_king_bar       @ 25:27\n  satanic              @ 29:41\n  butterfly            @ 36:38\n\nTotal Gold Earned: 47,832\n</code></pre></p>"},{"location":"guides/use-cases/#use-case-3-understanding-a-gank","title":"Use Case 3: Understanding a Gank","text":"<p>Reconstruct early game kills with damage sequences and participants.</p> <p>Required Data:</p> <ul> <li><code>get_hero_deaths()</code> - game_time, position (x, y), killer</li> <li><code>get_fight_combat_log()</code> - damage sequence, ability usage</li> </ul> <pre><code>from python_manta import Parser, CombatLogType\n\ndef analyze_gank(demo_path: str, kill_index: int = 0):\n    parser = Parser(demo_path)\n    result = parser.parse(combat_log={\"max_entries\": 0})\n\n    # Find hero deaths after game starts\n    deaths = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.DEATH.value\n        and \"hero\" in e.target_name.lower()\n        and e.game_time &gt; 60  # After laning starts\n    ]\n\n    if kill_index &gt;= len(deaths):\n        print(\"Kill not found\")\n        return\n\n    kill = deaths[kill_index]\n    victim = kill.target_name.replace(\"npc_dota_hero_\", \"\")\n    killer = kill.attacker_name.replace(\"npc_dota_hero_\", \"\")\n    mins = int(kill.game_time // 60)\n    secs = int(kill.game_time % 60)\n\n    print(f\"Gank Analysis: Kill #{kill_index + 1}\")\n    print(\"=\" * 50)\n    print(f\"Time: {mins:02d}:{secs:02d} ({kill.game_time:.1f}s)\")\n    print(f\"Victim: {victim}\")\n    print(f\"Killer: {killer}\")\n    print(f\"Victim Team: {'Radiant' if kill.target_team == 2 else 'Dire'}\")\n\n    # Get damage sequence (5 seconds before death)\n    damage = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.DAMAGE.value\n        and e.target_name == kill.target_name\n        and kill.game_time - 5 &lt;= e.game_time &lt;= kill.game_time\n    ]\n\n    print(f\"\\nDamage Sequence ({len(damage)} events):\")\n    attackers = {}\n    for d in damage:\n        atk = d.attacker_name.replace(\"npc_dota_hero_\", \"\").replace(\"npc_dota_\", \"\")\n        attackers[atk] = attackers.get(atk, 0) + d.value\n\n    for atk, dmg in sorted(attackers.items(), key=lambda x: -x[1]):\n        print(f\"  {atk}: {dmg} damage\")\n\n# Analyze first kill\nanalyze_gank(\"match.dem\", kill_index=0)\n</code></pre> <p>Expected Output (First Kill - Pugna kills Hoodwink): <pre><code>Gank Analysis: Kill #1\n==================================================\nTime: 03:07 (187.5s)\nVictim: hoodwink\nKiller: pugna\nVictim Team: Radiant\n\nDamage Sequence (5 events):\n  pugna_nether_ward: 312 damage\n  pugna: 89 damage\n</code></pre></p>"},{"location":"guides/use-cases/#use-case-4-objective-control-analysis","title":"Use Case 4: Objective Control Analysis","text":"<p>Track Roshan kills and tower destruction with team attribution.</p> <p>Required Data:</p> <ul> <li><code>get_objective_kills()</code> - roshan_kills, tower_kills</li> <li>game_time, killer, team for each objective</li> </ul> <pre><code>from python_manta import Parser, CombatLogType, Team\n\ndef analyze_objectives(demo_path: str):\n    parser = Parser(demo_path)\n    result = parser.parse(combat_log={\"max_entries\": 0})\n\n    # Roshan kills\n    roshan = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.DEATH.value\n        and \"roshan\" in e.target_name.lower()\n    ]\n\n    # Tower kills\n    towers = [\n        e for e in result.combat_log.entries\n        if e.type == CombatLogType.TEAM_BUILDING_KILL.value\n        and \"tower\" in e.target_name.lower()\n    ]\n\n    print(\"Objective Control Analysis\")\n    print(\"=\" * 50)\n\n    print(f\"\\nRoshan Kills ({len(roshan)}):\")\n    for i, r in enumerate(roshan, 1):\n        killer = r.attacker_name.replace(\"npc_dota_hero_\", \"\")\n        team = \"Radiant\" if r.attacker_team == Team.RADIANT.value else \"Dire\"\n        mins = int(r.game_time // 60)\n        secs = int(r.game_time % 60)\n        print(f\"  #{i}: [{mins:02d}:{secs:02d}] {killer} ({team})\")\n\n    print(f\"\\nTower Kills ({len(towers)}):\")\n    for t in towers[:5]:  # First 5\n        tower = t.target_name.replace(\"npc_dota_\", \"\").replace(\"goodguys_\", \"Radiant \").replace(\"badguys_\", \"Dire \")\n        mins = int(t.game_time // 60)\n        secs = int(t.game_time % 60)\n        print(f\"  [{mins:02d}:{secs:02d}] {tower}\")\n\nanalyze_objectives(\"match.dem\")\n</code></pre> <p>Expected Output: <pre><code>Objective Control Analysis\n==================================================\n\nRoshan Kills (2):\n  #1: [19:17] troll_warlord (Radiant)\n  #2: [28:57] troll_warlord (Radiant)\n\nTower Kills (13):\n  [11:15] Dire tower1_bot\n  [12:16] Dire tower1_top\n  [13:08] Radiant tower1_bot\n  [13:37] Radiant tower1_mid\n  [18:28] Dire tower1_mid\n</code></pre></p>"},{"location":"guides/use-cases/#use-case-5-comparing-laning-phase","title":"Use Case 5: Comparing Laning Phase","text":"<p>Get hero stats at specific minute marks for lane matchup analysis.</p> <p>Required Data:</p> <ul> <li><code>get_stats_at_minute()</code> - level, health, position at specific times</li> </ul> <pre><code>from python_manta import Parser, Team\n\ndef compare_laning(demo_path: str, minute: int = 10):\n    parser = Parser(demo_path)\n\n    # Build index to find game start\n    index = parser.build_index(interval_ticks=1800)\n    game_start = index.game_started\n\n    # Get snapshot at specified minute\n    target_tick = game_start + (minute * 60 * 30)  # 30 ticks/sec\n    snapshot = parser.snapshot(target_tick=target_tick)\n\n    print(f\"Hero Stats at {minute} Minutes\")\n    print(\"=\" * 70)\n\n    print(\"\\nRadiant:\")\n    for h in sorted([h for h in snapshot.heroes if h.team == Team.RADIANT.value],\n                    key=lambda x: x.player_id):\n        name = h.hero_name.replace(\"CDOTA_Unit_Hero_\", \"\")\n        print(f\"  {name:20} Lvl {h.level:2}  HP {h.health:4}/{h.max_health:4}  \"\n              f\"Armor {h.armor:4.1f}  Dmg {h.damage_min:3}-{h.damage_max:3}\")\n\n    print(\"\\nDire:\")\n    for h in sorted([h for h in snapshot.heroes if h.team == Team.DIRE.value],\n                    key=lambda x: x.player_id):\n        name = h.hero_name.replace(\"CDOTA_Unit_Hero_\", \"\")\n        print(f\"  {name:20} Lvl {h.level:2}  HP {h.health:4}/{h.max_health:4}  \"\n              f\"Armor {h.armor:4.1f}  Dmg {h.damage_min:3}-{h.damage_max:3}\")\n\ncompare_laning(\"match.dem\", minute=10)\n</code></pre> <p>Expected Output (10 Minutes): <pre><code>Hero Stats at 10 Minutes\n======================================================================\n\nRadiant:\n  TrollWarlord         Lvl  6  HP  852/ 890  Armor -1.0  Dmg  68- 76\n  Chen                 Lvl  5  HP  962/ 962  Armor -1.0  Dmg  65- 75\n  MonkeyKing           Lvl  8  HP  941/1066  Armor  2.0  Dmg  93- 97\n  Hoodwink             Lvl  5  HP  830/ 830  Armor  0.0  Dmg  61- 68\n  Bristleback          Lvl  8  HP 1070/1380  Armor  1.0  Dmg  81- 87\n\nDire:\n  Lycan                Lvl  6  HP 1336/1352  Armor  0.0  Dmg  80- 85\n  Pugna                Lvl  6  HP  824/ 824  Armor  0.0  Dmg  76- 83\n  FacelessVoid         Lvl  7  HP 1115/1154  Armor  0.0  Dmg  89- 95\n  StormSpirit          Lvl  7  HP  637/1044  Armor  1.0  Dmg  82- 92\n  ShadowShaman         Lvl  4  HP  808/ 808  Armor  2.0  Dmg  76- 83\n</code></pre></p>"},{"location":"guides/use-cases/#data-mapping-summary","title":"Data Mapping Summary","text":"MCP Use Case python-manta API Data Source Teamfight Analysis <code>parse(combat_log={...})</code> <code>CombatLogType.DEATH</code>, <code>DAMAGE</code>, <code>ABILITY</code> Carry Farm Tracking <code>parse(combat_log={...})</code> <code>CombatLogType.PURCHASE</code>, <code>GOLD</code>, <code>XP</code> Gank Analysis <code>parse(combat_log={...})</code> <code>CombatLogType.DEATH</code> with <code>game_time</code> filtering Objective Control <code>parse(combat_log={...})</code> <code>CombatLogType.DEATH</code> (Roshan), <code>TEAM_BUILDING_KILL</code> Laning Comparison <code>snapshot(target_tick=...)</code> <code>HeroSnapshot</code> with level, health, armor, damage, attributes"},{"location":"guides/use-cases/#testing","title":"Testing","text":"<p>All use cases are validated in <code>tests/integration/test_mcp_usecase_validation.py</code> with real expected values from Match 8447659831.</p> <p>Run the tests: <pre><code>uv run pytest tests/integration/test_mcp_usecase_validation.py -v\n</code></pre></p> <p>Expected: 35 tests pass</p>"},{"location":"reference/","title":"Reference","text":"AI Summary <p>Complete reference materials for Python Manta. Includes: 272 message callbacks (Dota User Messages, Demo Messages, Network Messages), 364 game event types (player kills, tower events, rune pickups), 12 combat log entry types, attack projectile tracking from TE_Projectile, modifier/buff fields, entity properties and classes, and string table structures.</p>"},{"location":"reference/#reference-materials","title":"Reference Materials","text":"Reference Description Callbacks Complete list of all 272 message callbacks Game Events All 364 game event types and fields Combat Log 12 combat log entry types Attacks Attack projectiles from TE_Projectile (towers, creeps, heroes) Modifiers Buff/debuff modifier fields Entities Entity classes and properties String Tables String table structure and common tables"},{"location":"reference/attacks/","title":"Attacks Reference","text":"AI Summary <p>Complete reference for attack tracking from both TE_Projectile (ranged) and combat log (melee). Captures ALL auto-attacks in the game with consistent fields: entity indices, names, timing, and damage. Typically 30,000+ events per match combining ranged projectiles and melee hits.</p>"},{"location":"reference/attacks/#overview","title":"Overview","text":"<p>The attacks collector unifies two data sources into a single consistent API:</p> <ul> <li>Ranged attacks: From <code>TE_Projectile</code> messages (projectile speed, dodgeable)</li> <li>Melee attacks: From combat log DAMAGE events with no ability (damage values)</li> </ul> <p>Both types share the same <code>AttackEvent</code> model with all fields populated where data is available.</p> <p>Key Use Cases:</p> <ul> <li>Last-hit analysis (who attacked which creep)</li> <li>Lane farming patterns</li> <li>Hero attack tracking (both melee and ranged heroes)</li> <li>Tower/creep/neutral combat analysis</li> </ul>"},{"location":"reference/attacks/#attackevent-fields","title":"AttackEvent Fields","text":"<p>Every <code>AttackEvent</code> contains these fields, populated consistently for both ranged and melee:</p>"},{"location":"reference/attacks/#timing","title":"Timing","text":"Field Type Description <code>tick</code> <code>int</code> Game tick (~30/second) <code>game_time</code> <code>float</code> Game time in seconds from horn <code>game_time_str</code> <code>str</code> Formatted time (e.g., \"15:34\") <code>launch_tick</code> <code>int</code> Tick when projectile was launched (ranged only)"},{"location":"reference/attacks/#entity-identification","title":"Entity Identification","text":"Field Type Ranged Melee Description <code>source_index</code> <code>int</code> \u2713 \u2713 Entity ID of attacker <code>target_index</code> <code>int</code> \u2713 \u2713* Entity ID of target <code>attacker_name</code> <code>str</code> \u2713 \u2713 Unit name (e.g., <code>npc_dota_hero_troll_warlord</code>) <code>target_name</code> <code>str</code> \u2713 \u2713 Target unit name <p>*Melee target_index populated for heroes, may be 0 for creeps/neutrals</p>"},{"location":"reference/attacks/#attack-properties","title":"Attack Properties","text":"Field Type Ranged Melee Description <code>is_melee</code> <code>bool</code> <code>False</code> <code>True</code> Attack type identifier <code>damage</code> <code>int</code> 0 \u2713 Damage dealt <code>target_health</code> <code>int</code> 0 \u2713 Target health AFTER attack <code>projectile_speed</code> <code>int</code> \u2713 0 Projectile move speed <code>dodgeable</code> <code>bool</code> \u2713 <code>False</code> Can be disjointed <code>location_x</code> <code>float</code> \u2713 \u2713* Attacker position X <code>location_y</code> <code>float</code> \u2713 \u2713* Attacker position Y <code>attacker_team</code> <code>int</code> 0 \u2713 Attacker team (2=Radiant, 3=Dire) <code>target_team</code> <code>int</code> 0 \u2713 Target team (2=Radiant, 3=Dire) <code>is_attacker_hero</code> <code>bool</code> <code>False</code> \u2713 Attacker is a hero <code>is_target_hero</code> <code>bool</code> <code>False</code> \u2713 Target is a hero <p>*Melee location from entity lookup (heroes ~37%, creeps 0)</p>"},{"location":"reference/attacks/#raw-handles-advanced","title":"Raw Handles (Advanced)","text":"Field Type Description <code>source_handle</code> <code>int</code> Raw entity handle (ranged only) <code>target_handle</code> <code>int</code> Raw entity handle (ranged only)"},{"location":"reference/attacks/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import Parser\n\nparser = Parser(\"match.dem\")\n\n# Collect all attack events (ranged + melee)\nresult = parser.parse(attacks={})\n\nprint(f\"Total attacks: {result.attacks.total_events}\")\n\n# Separate by type\nmelee = [a for a in result.attacks.events if a.is_melee]\nranged = [a for a in result.attacks.events if not a.is_melee]\n\nprint(f\"Melee: {len(melee)}, Ranged: {len(ranged)}\")\n</code></pre>"},{"location":"reference/attacks/#limiting-events","title":"Limiting Events","text":"<pre><code># First 1000 attacks only\nresult = parser.parse(attacks={\"max_events\": 1000})\n</code></pre>"},{"location":"reference/attacks/#hero-name-format","title":"Hero Name Format","text":"<p>All hero names use the canonical Dota 2 format with underscores:</p> <pre><code># Correct format (matches combat log)\n\"npc_dota_hero_troll_warlord\"\n\"npc_dota_hero_faceless_void\"\n\"npc_dota_hero_shadow_shaman\"\n\"npc_dota_hero_monkey_king\"\n\"npc_dota_hero_storm_spirit\"\n\n# NOT: \"npc_dota_hero_trollwarlord\" (incorrect)\n</code></pre>"},{"location":"reference/attacks/#use-case-examples","title":"Use Case Examples","text":""},{"location":"reference/attacks/#lane-farming-analysis","title":"Lane Farming Analysis","text":"<pre><code>result = parser.parse(attacks={})\n\n# Find all attacks on lane creeps\nlane_creep_attacks = [\n    a for a in result.attacks.events\n    if \"creep_goodguys\" in a.target_name or \"creep_badguys\" in a.target_name\n]\n\n# Group by attacker\nfrom collections import Counter\nattackers = Counter(a.attacker_name for a in lane_creep_attacks)\nfor name, count in attackers.most_common(10):\n    print(f\"{name}: {count} attacks on lane creeps\")\n</code></pre>"},{"location":"reference/attacks/#contested-last-hits","title":"Contested Last Hits","text":"<pre><code>result = parser.parse(attacks={}, entity_deaths={\"include_creeps\": True})\n\n# Find creeps that were attacked by multiple heroes before death\nfrom collections import defaultdict\n\ncreep_attackers = defaultdict(set)\nfor attack in result.attacks.events:\n    if \"npc_dota_hero\" in attack.attacker_name:\n        creep_attackers[attack.target_name].add(attack.attacker_name)\n\ncontested = {k: v for k, v in creep_attackers.items() if len(v) &gt; 1}\nprint(f\"Creeps contested by multiple heroes: {len(contested)}\")\n</code></pre>"},{"location":"reference/attacks/#hero-vs-hero-combat","title":"Hero vs Hero Combat","text":"<pre><code>result = parser.parse(attacks={})\n\n# Find hero-on-hero attacks\nhero_fights = [\n    a for a in result.attacks.events\n    if \"npc_dota_hero\" in a.attacker_name and \"npc_dota_hero\" in a.target_name\n]\n\nprint(f\"Hero vs hero attacks: {len(hero_fights)}\")\n\n# Sample output\nfor a in hero_fights[:5]:\n    atk = a.attacker_name.replace(\"npc_dota_hero_\", \"\")\n    tgt = a.target_name.replace(\"npc_dota_hero_\", \"\")\n    dmg = f\", dmg={a.damage}\" if a.is_melee else \"\"\n    print(f\"[{a.game_time_str}] {atk} -&gt; {tgt}{dmg}\")\n</code></pre>"},{"location":"reference/attacks/#melee-hero-tracking-eg-troll-warlord","title":"Melee Hero Tracking (e.g., Troll Warlord)","text":"<pre><code>result = parser.parse(attacks={})\n\n# Troll Warlord has both ranged and melee forms\ntroll_attacks = [a for a in result.attacks.events if \"troll_warlord\" in a.attacker_name]\n\ntroll_melee = [a for a in troll_attacks if a.is_melee]\ntroll_ranged = [a for a in troll_attacks if not a.is_melee]\n\nprint(f\"Troll melee attacks: {len(troll_melee)}\")\nprint(f\"Troll ranged attacks: {len(troll_ranged)}\")\n\n# Melee attacks have damage\nif troll_melee:\n    avg_dmg = sum(a.damage for a in troll_melee) / len(troll_melee)\n    print(f\"Average melee damage: {avg_dmg:.1f}\")\n</code></pre>"},{"location":"reference/attacks/#entity-index-consistency","title":"Entity Index Consistency","text":"<p>Entity indices match between attacks and snapshots:</p> <pre><code>result = parser.parse(attacks={})\nsnap = parser.snapshot(target_tick=30000)\n\n# Build hero index map\nhero_by_id = {h.entity_id: h.hero_name for h in snap.heroes}\n\n# Verify consistency\nfor attack in result.attacks.events[:100]:\n    if attack.source_index in hero_by_id:\n        assert attack.attacker_name == hero_by_id[attack.source_index]\n</code></pre>"},{"location":"reference/attacks/#statistics-real-match-data","title":"Statistics (Real Match Data)","text":"<p>From match 8447659831 (Team Spirit vs Tundra, ~46 min):</p> Metric Value Total attacks 32,895 Melee attacks 17,000 (52%) Ranged attacks 15,895 (48%) Troll Warlord melee 2,791 Pugna ranged 235"},{"location":"reference/attacks/#combat-log-vs-attacks","title":"Combat Log vs Attacks","text":"Data Type Combat Log Attacks Collector Hero damage Yes (all) Yes (auto-attacks only) Melee auto-attacks Yes (as damage) Yes (with entity ID) Ranged auto-attacks No Yes (with projectile data) Tower attacks on creeps No Yes Neutral attacks No Yes Ability damage Yes No Kill attribution Yes No <p>Rule of thumb: - Use combat log for damage analysis and kill tracking - Use attacks for attack pattern analysis and entity correlation</p>"},{"location":"reference/attacks/#performance-notes","title":"Performance Notes","text":"<ul> <li>Total events: ~30,000+ per match (ranged + melee)</li> <li>Use <code>max_events</code> to limit for faster parsing</li> <li>Events are ordered by tick</li> <li>Entity name \u2192 index mapping is automatic for heroes</li> </ul>"},{"location":"reference/callbacks/","title":"Callbacks Reference","text":"AI Summary <p>Complete reference of all 272 message callbacks available in Python Manta. Use with <code>parse_universal(demo_path, callback_name, max_messages)</code>. Callbacks are categorized: Dota User Messages (143 types for game events, chat, pings, items), Demo Messages (16 types for recording metadata), Network Messages (31 types for low-level networking), and misc messages. Filter matches substrings: \"Chat\" matches ChatMessage, ChatEvent, ChatWheel.</p>"},{"location":"reference/callbacks/#overview","title":"Overview","text":"<p>Python Manta supports 272 message callbacks inherited from the dotabuff/manta Go library. Use <code>parse_universal()</code> to capture any of these message types.</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\n\n# Filter by exact callback name\nresult = parser.parse_universal(\"match.dem\", \"CDOTAUserMsg_ChatMessage\", 100)\n\n# Filter by substring (matches multiple)\nresult = parser.parse_universal(\"match.dem\", \"Chat\", 200)  # ChatMessage, ChatEvent, etc.\n</code></pre>"},{"location":"reference/callbacks/#dota-user-messages-143","title":"Dota User Messages (143)","text":"<p>Game-related messages visible to players.</p>"},{"location":"reference/callbacks/#communication","title":"Communication","text":"Callback Description <code>CDOTAUserMsg_ChatMessage</code> Player chat messages <code>CDOTAUserMsg_ChatEvent</code> Chat events (kills, items, etc.) <code>CDOTAUserMsg_ChatWheel</code> Chat wheel phrases <code>CDOTAUserMsg_ChatWheelCooldown</code> Chat wheel cooldown <code>CDOTAUserMsg_BotChat</code> Bot chat messages <code>CDOTAUserMsg_BeastChat</code> Beast chat (custom game) <code>CDOTAUserMsg_SpeechBubble</code> Speech bubbles"},{"location":"reference/callbacks/#pings-and-alerts","title":"Pings and Alerts","text":"Callback Description <code>CDOTAUserMsg_LocationPing</code> Map location pings <code>CDOTAUserMsg_Ping</code> General ping <code>CDOTAUserMsg_PingConfirmation</code> Ping confirmation <code>CDOTAUserMsg_AbilityPing</code> Ability ping <code>CDOTAUserMsg_InnatePing</code> Innate ability ping <code>CDOTAUserMsg_FacetPing</code> Facet ping <code>CDOTAUserMsg_MinimapEvent</code> Minimap events <code>CDOTAUserMsg_MinimapDebugPoint</code> Debug minimap points <code>CDOTAUserMsg_MapLine</code> Map drawing lines <code>CDOTAUserMsg_WorldLine</code> World drawing lines <code>CDOTAUserMsg_CoachHUDPing</code> Coach HUD pings <code>CDOTAUserMsg_RadarAlert</code> Radar alerts"},{"location":"reference/callbacks/#item-events","title":"Item Events","text":"Callback Description <code>CDOTAUserMsg_ItemPurchased</code> Item purchases <code>CDOTAUserMsg_ItemSold</code> Item sales <code>CDOTAUserMsg_ItemFound</code> Items found <code>CDOTAUserMsg_ItemAlert</code> Item alerts <code>CDOTAUserMsg_EnemyItemAlert</code> Enemy item alerts <code>CDOTAUserMsg_QuickBuyAlert</code> Quick buy alerts <code>CDOTAUserMsg_WillPurchaseAlert</code> Will purchase alerts <code>CDOTAUserMsg_SetNextAutobuyItem</code> Auto-buy settings <code>CDOTAUserMsg_EmptyItemSlotAlert</code> Empty slot alerts <code>CDOTAUserMsg_FoundNeutralItem</code> Neutral item found"},{"location":"reference/callbacks/#combat-and-abilities","title":"Combat and Abilities","text":"Callback Description <code>CDOTAUserMsg_UnitEvent</code> Unit events (spawn, death, etc.) <code>CDOTAUserMsg_OverheadEvent</code> Overhead numbers (damage, heal) <code>CDOTAUserMsg_DamageReport</code> Damage reports <code>CDOTAUserMsg_KillcamDamageTaken</code> Killcam damage <code>CDOTAUserMsg_MiniKillCamInfo</code> Mini killcam info <code>CDOTAUserMsg_AbilitySteal</code> Ability steal (Rubick) <code>CDOTAUserMsg_ModifierAlert</code> Modifier alerts <code>CDOTAUserMsg_SharedCooldown</code> Shared cooldowns <code>CDOTAUserMsg_DodgeTrackingProjectiles</code> Projectile dodging"},{"location":"reference/callbacks/#projectiles","title":"Projectiles","text":"Callback Description <code>CDOTAUserMsg_CreateLinearProjectile</code> Create projectile <code>CDOTAUserMsg_DestroyLinearProjectile</code> Destroy projectile <code>CDOTAUserMsg_UpdateLinearProjectileCPData</code> Update projectile <code>CDOTAUserMsg_TE_Projectile</code> Projectile effect <code>CDOTAUserMsg_TE_ProjectileLoc</code> Projectile location <code>CDOTAUserMsg_TE_DestroyProjectile</code> Destroy projectile effect <code>CDOTAUserMsg_TE_DotaBloodImpact</code> Blood impact effect"},{"location":"reference/callbacks/#animation","title":"Animation","text":"Callback Description <code>CDOTAUserMsg_TE_UnitAnimation</code> Unit animation <code>CDOTAUserMsg_TE_UnitAnimationEnd</code> Animation end <code>CDOTAUserMsg_MiniTaunt</code> Mini taunt <code>CDOTAUserMsg_HighFiveCompleted</code> High five complete <code>CDOTAUserMsg_HighFiveLeftHanging</code> High five missed <code>CDOTAUserMsg_SalutePlayer</code> Player salute"},{"location":"reference/callbacks/#game-state","title":"Game State","text":"Callback Description <code>CDOTAUserMsg_GamerulesStateChanged</code> Game state change <code>CDOTAUserMsg_SendFinalGold</code> Final gold amounts <code>CDOTAUserMsg_SelectPenaltyGold</code> Penalty gold <code>CDOTAUserMsg_RoshanTimer</code> Roshan timer <code>CDOTAUserMsg_SendRoshanPopup</code> Roshan popup <code>CDOTAUserMsg_SendRoshanSpectatorPhase</code> Roshan phase <code>CDOTAUserMsg_OutpostCaptured</code> Outpost captured <code>CDOTAUserMsg_OutpostGrantedXP</code> Outpost XP <code>CDOTAUserMsg_XPAlert</code> XP alerts"},{"location":"reference/callbacks/#draft-and-hero-selection","title":"Draft and Hero Selection","text":"Callback Description <code>CDOTAUserMsg_AbilityDraftRequestAbility</code> Ability draft request <code>CDOTAUserMsg_PlayerDraftPick</code> Draft pick <code>CDOTAUserMsg_PlayerDraftSuggestPick</code> Draft suggestion <code>CDOTAUserMsg_SuggestHeroPick</code> Hero suggestion <code>CDOTAUserMsg_SuggestHeroRole</code> Role suggestion <code>CDOTAUserMsg_SwapVerify</code> Swap verification"},{"location":"reference/callbacks/#stats-and-progress","title":"Stats and Progress","text":"Callback Description <code>CDOTAUserMsg_StatsMatchDetails</code> Match statistics <code>CDOTAUserMsg_StatsHeroMinuteDetails</code> Per-minute hero stats <code>CDOTAUserMsg_HeroRelicProgress</code> Hero relic progress <code>CDOTAUserMsg_QuestStatus</code> Quest status <code>CDOTAUserMsg_UpdateQuestProgress</code> Quest progress update <code>CDOTAUserMsg_AddQuestLogEntry</code> Quest log entry <code>CDOTAUserMsg_GuildChallenge_Progress</code> Guild challenge <code>CDOTAUserMsg_CompendiumState</code> Compendium state"},{"location":"reference/callbacks/#spectator-and-player-input","title":"Spectator and Player Input","text":"Callback Description <code>CDOTAUserMsg_SpectatorPlayerClick</code> Spectator clicks <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> Player commands - attack, move, cast, items. See Unit Orders Guide <code>CDOTAUserMsg_MoveCameraToUnit</code> Camera movement <code>CDOTAUserMsg_CombatHeroPositions</code> Hero positions <p>Creep Aggro Detection</p> <p>Use <code>CDOTAUserMsg_SpectatorPlayerUnitOrders</code> with <code>order_type=4</code> (ATTACK_TARGET) to detect attack commands that trigger creep aggro. See the Unit Orders Guide for detailed examples.</p>"},{"location":"reference/callbacks/#alerts","title":"Alerts","text":"Callback Description <code>CDOTAUserMsg_HPManaAlert</code> HP/Mana alerts <code>CDOTAUserMsg_GlyphAlert</code> Glyph alerts <code>CDOTAUserMsg_NeutralCampAlert</code> Neutral camp alerts <code>CDOTAUserMsg_CourierKilledAlert</code> Courier killed <code>CDOTAUserMsg_BuyBackStateAlert</code> Buyback state <code>CDOTAUserMsg_AghsStatusAlert</code> Aghanim's status <code>CDOTAUserMsg_TalentTreeAlert</code> Talent alerts <code>CDOTAUserMsg_TimerAlert</code> Timer alerts <code>CDOTAUserMsg_TipAlert</code> Tip alerts <code>CDOTAUserMsg_MadstoneAlert</code> Madstone alerts <code>CDOTAUserMsg_EmptyTeleportAlert</code> Empty TP scroll"},{"location":"reference/callbacks/#duel-and-combat","title":"Duel and Combat","text":"Callback Description <code>CDOTAUserMsg_DuelRequested</code> Duel request <code>CDOTAUserMsg_DuelAccepted</code> Duel accepted <code>CDOTAUserMsg_DuelOpponentKilled</code> Duel kill <code>CDOTAUserMsg_NevermoreRequiem</code> SF Requiem <code>CDOTAUserMsg_MarsArenaOfBloodAttack</code> Mars Arena"},{"location":"reference/callbacks/#arcana-and-cosmetics","title":"Arcana and Cosmetics","text":"Callback Description <code>CDOTAUserMsg_ESArcanaCombo</code> Earth Spirit Arcana <code>CDOTAUserMsg_ESArcanaComboSummary</code> ES Arcana summary <code>CDOTAUserMsg_WRArcanaProgress</code> Windranger Arcana <code>CDOTAUserMsg_WRArcanaSummary</code> WR Arcana summary <code>CDOTAUserMsg_QoP_ArcanaSummary</code> QoP Arcana <code>CDOTAUserMsg_OMArcanaCombo</code> Ogre Magi Arcana <code>CDOTAUserMsg_WK_Arcana_Progress</code> Wraith King Arcana <code>CDOTAUserMsg_MuertaReleaseEvent_AssignedTargetKilled</code> Muerta event"},{"location":"reference/callbacks/#voting-and-social","title":"Voting and Social","text":"Callback Description <code>CDOTAUserMsg_VoteStart</code> Vote start <code>CDOTAUserMsg_VoteUpdate</code> Vote update <code>CDOTAUserMsg_VoteEnd</code> Vote end <code>CDOTAUserMsg_FlipCoinResult</code> Coin flip <code>CDOTAUserMsg_RollDiceResult</code> Dice roll <code>CDOTAUserMsg_RockPaperScissorsStarted</code> RPS started <code>CDOTAUserMsg_RockPaperScissorsFinished</code> RPS finished <code>CDOTAUserMsg_GiftPlayer</code> Gift player"},{"location":"reference/callbacks/#ui-and-hud","title":"UI and HUD","text":"Callback Description <code>CDOTAUserMsg_HudError</code> HUD errors <code>CDOTAUserMsg_SendStatPopup</code> Stat popup <code>CDOTAUserMsg_SendGenericToolTip</code> Generic tooltip <code>CDOTAUserMsg_ShowGenericPopup</code> Generic popup <code>CDOTAUserMsg_DismissAllStatPopups</code> Dismiss popups <code>CDOTAUserMsg_CustomMsg</code> Custom message <code>CDOTAUserMsg_CustomHeaderMessage</code> Custom header <code>CDOTAUserMsg_CustomHudElement_Create</code> Custom HUD create <code>CDOTAUserMsg_CustomHudElement_Modify</code> Custom HUD modify <code>CDOTAUserMsg_CustomHudElement_Destroy</code> Custom HUD destroy <code>CDOTAUserMsg_ContextualTip</code> Contextual tips <code>CDOTAUserMsg_ShowSurvey</code> Survey popup <code>CDOTAUserMsg_InvalidCommand</code> Invalid command"},{"location":"reference/callbacks/#tutorial","title":"Tutorial","text":"Callback Description <code>CDOTAUserMsg_TutorialTipInfo</code> Tutorial tips <code>CDOTAUserMsg_TutorialFade</code> Tutorial fade <code>CDOTAUserMsg_TutorialFinish</code> Tutorial finish <code>CDOTAUserMsg_TutorialMinimapPosition</code> Minimap position <code>CDOTAUserMsg_TutorialPingMinimap</code> Minimap ping <code>CDOTAUserMsg_TutorialRequestExp</code> Request XP"},{"location":"reference/callbacks/#misc-dota","title":"Misc Dota","text":"Callback Description <code>CDOTAUserMsg_BoosterState</code> Booster state <code>CDOTAUserMsg_HalloweenDrops</code> Halloween drops <code>CDOTAUserMsg_ReceivedXmasGift</code> Xmas gift <code>CDOTAUserMsg_MutedPlayers</code> Muted players <code>CDOTAUserMsg_PauseMinigameData</code> Pause minigame <code>CDOTAUserMsg_ReplaceQueryUnit</code> Replace query unit <code>CDOTAUserMsg_UpdateSharedContent</code> Shared content <code>CDOTAUserMsg_QueuedOrderRemoved</code> Queued order <code>CDOTAUserMsg_ProjectionAbility</code> Projection ability <code>CDOTAUserMsg_ProjectionEvent</code> Projection event <code>CDOTAUserMsg_VersusScene_PlayerBehavior</code> Versus scene <code>CDOTAUserMsg_AIDebugLine</code> AI debug <code>CDOTAUserMsg_CombatLogBulkData</code> Combat log bulk <code>CDOTAUserMsg_AllStarEvent</code> All-Star event <code>CDOTAUserMsg_DebugChallenge</code> Debug challenge <code>CDOTAUserMsg_ClientLoadGridNav</code> Grid nav <code>CDOTAUserMsg_GlobalLightColor</code> Global light color <code>CDOTAUserMsg_GlobalLightDirection</code> Global light direction <code>CDOTAUserMsg_ShovelUnearth</code> Shovel unearth <code>CDOTAUserMsg_NeutralCraftAvailable</code> Neutral craft <code>CDOTAUserMsg_HotPotato_Created</code> Hot potato created <code>CDOTAUserMsg_HotPotato_Exploded</code> Hot potato exploded"},{"location":"reference/callbacks/#demo-messages-16","title":"Demo Messages (16)","text":"<p>Recording-related messages from the demo file.</p> Callback Description <code>CDemoFileHeader</code> File header <code>CDemoFileInfo</code> Match info (picks/bans) <code>CDemoPacket</code> Demo packet <code>CDemoFullPacket</code> Full state snapshot <code>CDemoSyncTick</code> Sync tick <code>CDemoStop</code> Demo stop <code>CDemoStringTables</code> String tables <code>CDemoSendTables</code> Send tables <code>CDemoClassInfo</code> Class info <code>CDemoSignonPacket</code> Signon packet <code>CDemoConsoleCmd</code> Console command <code>CDemoCustomData</code> Custom data <code>CDemoCustomDataCallbacks</code> Custom callbacks <code>CDemoUserCmd</code> User command <code>CDemoSaveGame</code> Save game <code>CDemoSpawnGroups</code> Spawn groups <code>CDemoAnimationData</code> Animation data <code>CDemoAnimationHeader</code> Animation header <code>CDemoRecovery</code> Recovery data <code>CDOTAMatchMetadataFile</code> Match metadata"},{"location":"reference/callbacks/#network-messages-31","title":"Network Messages (31)","text":"<p>Low-level network protocol messages.</p>"},{"location":"reference/callbacks/#net-messages","title":"NET Messages","text":"Callback Description <code>CNETMsg_Tick</code> Network tick (very frequent!) <code>CNETMsg_NOP</code> No operation <code>CNETMsg_SetConVar</code> Set console variable <code>CNETMsg_SignonState</code> Signon state <code>CNETMsg_StringCmd</code> String command <code>CNETMsg_SplitScreenUser</code> Split screen <code>CNETMsg_DebugOverlay</code> Debug overlay"},{"location":"reference/callbacks/#spawn-group-messages","title":"Spawn Group Messages","text":"Callback Description <code>CNETMsg_SpawnGroup_Load</code> Load spawn group <code>CNETMsg_SpawnGroup_Unload</code> Unload spawn group <code>CNETMsg_SpawnGroup_LoadCompleted</code> Load complete <code>CNETMsg_SpawnGroup_ManifestUpdate</code> Manifest update <code>CNETMsg_SpawnGroup_SetCreationTick</code> Creation tick"},{"location":"reference/callbacks/#svc-messages","title":"SVC Messages","text":"Callback Description <code>CSVCMsg_ServerInfo</code> Server information <code>CSVCMsg_ClassInfo</code> Class information <code>CSVCMsg_CreateStringTable</code> Create string table <code>CSVCMsg_UpdateStringTable</code> Update string table <code>CSVCMsg_ClearAllStringTables</code> Clear string tables <code>CSVCMsg_PacketEntities</code> Entity updates <code>CSVCMsg_PacketReliable</code> Reliable packet <code>CSVCMsg_FlattenedSerializer</code> Serializer data <code>CSVCMsg_Prefetch</code> Prefetch <code>CSVCMsg_SetView</code> Set view <code>CSVCMsg_SetPause</code> Set pause <code>CSVCMsg_Sounds</code> Sound events <code>CSVCMsg_VoiceInit</code> Voice init <code>CSVCMsg_VoiceData</code> Voice data <code>CSVCMsg_Print</code> Print message <code>CSVCMsg_Menu</code> Menu <code>CSVCMsg_GetCvarValue</code> Get cvar value <code>CSVCMsg_UserMessage</code> User message <code>CSVCMsg_SplitScreen</code> Split screen <code>CSVCMsg_BSPDecal</code> BSP decal <code>CSVCMsg_CmdKeyValues</code> Key values <code>CSVCMsg_Broadcast_Command</code> Broadcast command <code>CSVCMsg_FullFrameSplit</code> Frame split <code>CSVCMsg_HLTVStatus</code> HLTV status <code>CSVCMsg_HltvFixupOperatorStatus</code> HLTV fixup <code>CSVCMsg_PeerList</code> Peer list <code>CSVCMsg_RconServerDetails</code> RCON details <code>CSVCMsg_ServerSteamID</code> Server Steam ID <code>CSVCMsg_StopSound</code> Stop sound"},{"location":"reference/callbacks/#combat-log-message","title":"Combat Log Message","text":"Callback Description <code>CMsgDOTACombatLogEntry</code> Combat log entry <p>Note</p> <p>For structured combat log parsing, use <code>parse_combat_log()</code> instead of <code>parse_universal()</code>.</p>"},{"location":"reference/callbacks/#entity-messages-6","title":"Entity Messages (6)","text":"<p>Entity-related messages.</p> Callback Description <code>CEntityMessageDoSpark</code> Spark effect <code>CEntityMessageFixAngle</code> Fix angle <code>CEntityMessagePlayJingle</code> Play jingle <code>CEntityMessagePropagateForce</code> Propagate force <code>CEntityMessageRemoveAllDecals</code> Remove decals <code>CEntityMessageScreenOverlay</code> Screen overlay"},{"location":"reference/callbacks/#general-user-messages-25","title":"General User Messages (25)","text":"<p>Generic Source 2 user messages.</p> Callback Description <code>CUserMessageSayText</code> Say text <code>CUserMessageSayText2</code> Say text 2 <code>CUserMessageSayTextChannel</code> Say text channel <code>CUserMessageTextMsg</code> Text message <code>CUserMessageHudMsg</code> HUD message <code>CUserMessageHudText</code> HUD text <code>CUserMessageShake</code> Screen shake <code>CUserMessageShakeDir</code> Directional shake <code>CUserMessageFade</code> Screen fade <code>CUserMessageScreenTilt</code> Screen tilt <code>CUserMessageRumble</code> Rumble <code>CUserMessageCloseCaption</code> Closed caption <code>CUserMessageCloseCaptionDirect</code> Direct caption <code>CUserMessageCloseCaptionPlaceholder</code> Caption placeholder <code>CUserMessageSendAudio</code> Send audio <code>CUserMessageAudioParameter</code> Audio parameter <code>CUserMessageVoiceMask</code> Voice mask <code>CUserMessageRequestState</code> Request state <code>CUserMessageRequestInventory</code> Request inventory <code>CUserMessageRequestDiagnostic</code> Request diagnostic <code>CUserMessageRequestDllStatus</code> Request DLL status <code>CUserMessageRequestUtilAction</code> Request util action <code>CUserMessageResetHUD</code> Reset HUD <code>CUserMessageItemPickup</code> Item pickup <code>CUserMessageShowMenu</code> Show menu <code>CUserMessageColoredText</code> Colored text <code>CUserMessageCreditsMsg</code> Credits <code>CUserMessageAchievementEvent</code> Achievement <code>CUserMessageCurrentTimescale</code> Current timescale <code>CUserMessageDesiredTimescale</code> Desired timescale <code>CUserMessageGameTitle</code> Game title <code>CUserMessageAmmoDenied</code> Ammo denied <code>CUserMessageCameraTransition</code> Camera transition <code>CUserMessageHapticsManagerEffect</code> Haptics effect <code>CUserMessageHapticsManagerPulse</code> Haptics pulse <code>CUserMessageLagCompensationError</code> Lag compensation <code>CUserMessageServerFrameTime</code> Server frame time <code>CUserMessageUpdateCssClasses</code> Update CSS <code>CUserMessageWaterShake</code> Water shake"},{"location":"reference/callbacks/#misc-messages-15","title":"Misc Messages (15)","text":"<p>Other message types.</p> Callback Description <code>CMsgSource1LegacyGameEvent</code> Legacy game event <code>CMsgSource1LegacyGameEventList</code> Game event list <code>CMsgSource1LegacyListenEvents</code> Listen events <code>CMsgDOTACombatLogEntry</code> Combat log <code>CMsgGCToClientTournamentItemDrop</code> Tournament drop <code>CMsgVDebugGameSessionIDEvent</code> Debug session ID <code>CMsgPlaceDecalEvent</code> Place decal <code>CMsgClearWorldDecalsEvent</code> Clear world decals <code>CMsgClearEntityDecalsEvent</code> Clear entity decals <code>CMsgClearDecalsForSkeletonInstanceEvent</code> Clear skeleton decals <code>CMsgSosStartSoundEvent</code> Start sound <code>CMsgSosStopSoundEvent</code> Stop sound <code>CMsgSosStopSoundEventHash</code> Stop sound hash <code>CMsgSosSetSoundEventParams</code> Sound params <code>CMsgSosSetLibraryStackFields</code> Library stack"},{"location":"reference/callbacks/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/callbacks/#common-filters","title":"Common Filters","text":"<pre><code># Chat and communication\nchat = parser.parse_universal(\"match.dem\", \"ChatMessage\", 100)\npings = parser.parse_universal(\"match.dem\", \"LocationPing\", 100)\nwheel = parser.parse_universal(\"match.dem\", \"ChatWheel\", 100)\n\n# Items\npurchases = parser.parse_universal(\"match.dem\", \"ItemPurchased\", 500)\nalerts = parser.parse_universal(\"match.dem\", \"ItemAlert\", 100)\n\n# Combat\noverhead = parser.parse_universal(\"match.dem\", \"OverheadEvent\", 500)\nunit_events = parser.parse_universal(\"match.dem\", \"UnitEvent\", 200)\n\n# Game state\nstate_changes = parser.parse_universal(\"match.dem\", \"GamerulesStateChanged\", 20)\n</code></pre>"},{"location":"reference/callbacks/#filtering-multiple-types","title":"Filtering Multiple Types","text":"<pre><code># Substring \"Alert\" matches many alert types\nalerts = parser.parse_universal(\"match.dem\", \"Alert\", 500)\n\n# Common matched types:\n# - CDOTAUserMsg_ItemAlert\n# - CDOTAUserMsg_EnemyItemAlert\n# - CDOTAUserMsg_GlyphAlert\n# - CDOTAUserMsg_NeutralCampAlert\n# - etc.\n</code></pre>"},{"location":"reference/combat-log/","title":"Combat Log Reference","text":"AI Summary <p>Complete reference for 12 combat log entry types parsed from Dota 2 replays. Types include: DAMAGE (0), HEAL (1), MODIFIER_ADD (2), MODIFIER_REMOVE (3), DEATH (4), ABILITY (5), ITEM (6), LOCATION (7), GOLD (8), GAME_STATE (9), XP (10), PURCHASE (11). Each entry contains attacker/target info, damage values, game_time (seconds from horn), and team visibility flags.</p>"},{"location":"reference/combat-log/#combat-log-types","title":"Combat Log Types","text":"Type ID Name Description 0 DAMAGE Damage dealt to a unit 1 HEAL Health restored to a unit 2 MODIFIER_ADD Buff/debuff applied 3 MODIFIER_REMOVE Buff/debuff removed 4 DEATH Unit death 5 ABILITY Ability used 6 ITEM Item used 7 LOCATION Location event 8 GOLD Gold gained/lost 9 GAME_STATE Game state change 10 XP Experience gained 11 PURCHASE Item purchased"},{"location":"reference/combat-log/#entry-fields","title":"Entry Fields","text":"<p>Every <code>CombatLogEntry</code> contains these fields:</p>"},{"location":"reference/combat-log/#identification","title":"Identification","text":"Field Type Description <code>tick</code> <code>int</code> Game tick (~30/second) <code>net_tick</code> <code>int</code> Network tick <code>type</code> <code>int</code> Combat log type ID (0-11) <code>type_name</code> <code>str</code> Human-readable type name <code>game_time</code> <code>float</code> Game time in seconds (negative before horn) <code>game_time_str</code> <code>str</code> Formatted game time (e.g., \"-0:40\", \"5:32\")"},{"location":"reference/combat-log/#participants","title":"Participants","text":"Field Type Description <code>attacker_name</code> <code>str</code> Attacker unit name <code>target_name</code> <code>str</code> Target unit name <code>target_source_name</code> <code>str</code> Target source name <code>damage_source_name</code> <code>str</code> Damage source name <code>inflictor_name</code> <code>str</code> Ability/item causing the effect"},{"location":"reference/combat-log/#unit-flags","title":"Unit Flags","text":"Field Type Description <code>is_attacker_hero</code> <code>bool</code> Attacker is a hero <code>is_attacker_illusion</code> <code>bool</code> Attacker is an illusion <code>is_target_hero</code> <code>bool</code> Target is a hero <code>is_target_illusion</code> <code>bool</code> Target is an illusion <code>attacker_team</code> <code>int</code> Attacker team ID <code>target_team</code> <code>int</code> Target team ID"},{"location":"reference/combat-log/#visibility","title":"Visibility","text":"Field Type Description <code>is_visible_radiant</code> <code>bool</code> Visible to Radiant team <code>is_visible_dire</code> <code>bool</code> Visible to Dire team"},{"location":"reference/combat-log/#values","title":"Values","text":"Field Type Description <code>value</code> <code>int</code> Primary value (damage, heal, gold, XP) <code>health</code> <code>int</code> Target health after event <code>gold</code> <code>int</code> Gold value <code>xp</code> <code>int</code> XP value <code>last_hits</code> <code>int</code> Last hits at time of event"},{"location":"reference/combat-log/#ability-info","title":"Ability Info","text":"Field Type Description <code>ability_level</code> <code>int</code> Level of ability used <code>is_ability_toggle_on</code> <code>bool</code> Ability toggled on <code>is_ability_toggle_off</code> <code>bool</code> Ability toggled off"},{"location":"reference/combat-log/#duration-effects","title":"Duration Effects","text":"Field Type Description <code>stun_duration</code> <code>float</code> Stun duration in seconds <code>slow_duration</code> <code>float</code> Slow duration in seconds"},{"location":"reference/combat-log/#type-specific-usage","title":"Type-Specific Usage","text":""},{"location":"reference/combat-log/#damage-type-0","title":"DAMAGE (Type 0)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.attacker_name} -&gt; {entry.target_name}: {entry.value} damage\")\n    if entry.inflictor_name:\n        print(f\"  via {entry.inflictor_name}\")\n</code></pre>"},{"location":"reference/combat-log/#heal-type-1","title":"HEAL (Type 1)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[1], max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.target_name} healed for {entry.value}\")\n</code></pre>"},{"location":"reference/combat-log/#modifier_add-type-2","title":"MODIFIER_ADD (Type 2)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[2], max_entries=100)\n\nfor entry in result.entries:\n    if entry.inflictor_name:\n        print(f\"[{entry.game_time_str}] {entry.inflictor_name} applied to {entry.target_name}\")\n</code></pre>"},{"location":"reference/combat-log/#death-type-4","title":"DEATH (Type 4)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[4], heroes_only=True, max_entries=100)\n\nfor entry in result.entries:\n    print(f\"[{entry.game_time_str}] {entry.target_name} died\")\n    if entry.attacker_name:\n        print(f\"  killed by {entry.attacker_name}\")\n</code></pre>"},{"location":"reference/combat-log/#gold-type-8","title":"GOLD (Type 8)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[8], max_entries=100)\n\nfor entry in result.entries:\n    if entry.gold &gt; 0:\n        print(f\"[{entry.game_time_str}] {entry.target_name} gained {entry.gold} gold\")\n</code></pre>"},{"location":"reference/combat-log/#xp-type-10","title":"XP (Type 10)","text":"<pre><code>result = parser.parse_combat_log(\"match.dem\", types=[10], max_entries=100)\n\nfor entry in result.entries:\n    if entry.xp &gt; 0:\n        print(f\"[{entry.game_time_str}] {entry.target_name} gained {entry.xp} XP\")\n</code></pre>"},{"location":"reference/combat-log/#filtering","title":"Filtering","text":""},{"location":"reference/combat-log/#by-type","title":"By Type","text":"<pre><code># Only damage and death\nresult = parser.parse_combat_log(\"match.dem\", types=[0, 4], max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#by-hero","title":"By Hero","text":"<pre><code># Only hero-to-hero combat\nresult = parser.parse_combat_log(\"match.dem\", heroes_only=True, max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#combined","title":"Combined","text":"<pre><code># Hero damage only\nresult = parser.parse_combat_log(\"match.dem\", types=[0], heroes_only=True, max_entries=500)\n</code></pre>"},{"location":"reference/combat-log/#unit-name-format","title":"Unit Name Format","text":"<p>Unit names follow Dota 2's internal naming:</p> Pattern Example Description <code>npc_dota_hero_*</code> <code>npc_dota_hero_axe</code> Hero <code>npc_dota_creep_*</code> <code>npc_dota_creep_badguys_melee</code> Lane creep <code>npc_dota_neutral_*</code> <code>npc_dota_neutral_centaur_khan</code> Neutral creep <code>npc_dota_*tower*</code> <code>npc_dota_badguys_tower1_mid</code> Tower <code>npc_dota_roshan</code> <code>npc_dota_roshan</code> Roshan"},{"location":"reference/combat-log/#timing-note","title":"Timing Note","text":"<p>Combat log entries typically appear after 12-17 minutes of game time. For early-game events, use <code>parse_game_events()</code> instead.</p>"},{"location":"reference/entities/","title":"Entities Reference","text":"AI Summary <p>Reference for querying game entities from Dota 2 replays. Entities represent all game objects: heroes, creeps, buildings, items, abilities, and more. Use <code>query_entities()</code> to get entity data at a specific tick with optional class filtering. Each entity has an index, serial, class name, and property dictionary. Common properties include health, mana, position, level, gold, and KDA stats.</p>"},{"location":"reference/entities/#entity-data-fields","title":"Entity Data Fields","text":"<p>Every <code>EntityData</code> contains:</p> Field Type Description <code>index</code> <code>int</code> Entity index (unique identifier) <code>serial</code> <code>int</code> Entity serial number <code>class_name</code> <code>str</code> Entity class name (e.g., <code>CDOTA_Unit_Hero_Axe</code>) <code>properties</code> <code>Dict[str, Any]</code> Entity properties dictionary"},{"location":"reference/entities/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\nfor entity in result.entities:\n    print(f\"{entity.class_name} (index={entity.index})\")\n    print(f\"  Health: {entity.properties.get('m_iHealth')}\")\n    print(f\"  Level: {entity.properties.get('m_iCurrentLevel')}\")\n</code></pre>"},{"location":"reference/entities/#entity-classes","title":"Entity Classes","text":""},{"location":"reference/entities/#heroes","title":"Heroes","text":"Class Pattern Description <code>CDOTA_Unit_Hero_*</code> Hero units <code>CDOTA_Unit_Hero_Axe</code> Axe specifically <code>CDOTA_Unit_Hero_Invoker</code> Invoker specifically"},{"location":"reference/entities/#creeps","title":"Creeps","text":"Class Pattern Description <code>CDOTA_BaseNPC_Creep_*</code> Lane creeps <code>CDOTA_BaseNPC_Creep_Neutral</code> Neutral creeps"},{"location":"reference/entities/#buildings","title":"Buildings","text":"Class Pattern Description <code>CDOTA_BaseNPC_Tower</code> Towers <code>CDOTA_BaseNPC_Barracks</code> Barracks <code>CDOTA_BaseNPC_Building</code> Ancient and other buildings <code>CDOTA_BaseNPC_Fort</code> Ancient (throne)"},{"location":"reference/entities/#other-units","title":"Other Units","text":"Class Pattern Description <code>CDOTA_BaseNPC_Courier</code> Couriers <code>CDOTA_Unit_Roshan</code> Roshan <code>CDOTA_NPC_Observer_Ward</code> Observer wards <code>CDOTA_NPC_Sentry_Ward</code> Sentry wards"},{"location":"reference/entities/#items","title":"Items","text":"Class Pattern Description <code>CDOTA_Item_*</code> Items <code>CDOTA_Item_Physical</code> Dropped items"},{"location":"reference/entities/#abilities","title":"Abilities","text":"Class Pattern Description <code>CDOTA_Ability_*</code> Ability instances"},{"location":"reference/entities/#common-hero-properties","title":"Common Hero Properties","text":""},{"location":"reference/entities/#health-mana","title":"Health &amp; Mana","text":"Property Type Description <code>m_iHealth</code> <code>int</code> Current health <code>m_iMaxHealth</code> <code>int</code> Maximum health <code>m_flMana</code> <code>float</code> Current mana <code>m_flMaxMana</code> <code>float</code> Maximum mana <code>m_flHealthThinkRegen</code> <code>float</code> Health regeneration <code>m_flManaThinkRegen</code> <code>float</code> Mana regeneration"},{"location":"reference/entities/#position-movement","title":"Position &amp; Movement","text":"Property Type Description <code>m_vecOrigin</code> <code>[x, y, z]</code> Position in world coordinates <code>m_angRotation</code> <code>[pitch, yaw, roll]</code> Rotation angles <code>m_flSpeed</code> <code>float</code> Current movement speed"},{"location":"reference/entities/#combat-stats","title":"Combat Stats","text":"Property Type Description <code>m_iCurrentLevel</code> <code>int</code> Hero level <code>m_iKills</code> <code>int</code> Kills <code>m_iDeaths</code> <code>int</code> Deaths <code>m_iAssists</code> <code>int</code> Assists <code>m_iDamageMin</code> <code>int</code> Minimum attack damage <code>m_iDamageMax</code> <code>int</code> Maximum attack damage <code>m_flPhysicalArmorValue</code> <code>float</code> Armor value <code>m_flMagicalResistanceValue</code> <code>float</code> Magic resistance"},{"location":"reference/entities/#economy","title":"Economy","text":"Property Type Description <code>m_iGold</code> <code>int</code> Reliable + unreliable gold <code>m_iGoldReliable</code> <code>int</code> Reliable gold <code>m_iGoldUnreliable</code> <code>int</code> Unreliable gold <code>m_iTotalEarnedGold</code> <code>int</code> Total gold earned <code>m_iLastHitCount</code> <code>int</code> Total last hits <code>m_iDenyCount</code> <code>int</code> Total denies"},{"location":"reference/entities/#team-player","title":"Team &amp; Player","text":"Property Type Description <code>m_iTeamNum</code> <code>int</code> Team number (2=Radiant, 3=Dire) <code>m_iPlayerID</code> <code>int</code> Player ID (0-9) <code>m_hAbilities</code> <code>list</code> Ability handles <code>m_hItems</code> <code>list</code> Item handles"},{"location":"reference/entities/#filtering","title":"Filtering","text":""},{"location":"reference/entities/#by-class-name","title":"By Class Name","text":"<pre><code># All heroes\nheroes = parser.query_entities(\"match.dem\", class_filter=\"Hero\", max_entities=10)\n\n# All towers\ntowers = parser.query_entities(\"match.dem\", class_filter=\"Tower\", max_entities=20)\n\n# All couriers\ncouriers = parser.query_entities(\"match.dem\", class_filter=\"Courier\", max_entities=4)\n</code></pre>"},{"location":"reference/entities/#by-tick","title":"By Tick","text":"<pre><code># Get state at specific tick\nearly_game = parser.query_entities(\"match.dem\", tick=10000, class_filter=\"Hero\")\nlate_game = parser.query_entities(\"match.dem\", tick=50000, class_filter=\"Hero\")\n</code></pre>"},{"location":"reference/entities/#by-property","title":"By Property","text":"<pre><code># Get all entities, then filter in Python\nresult = parser.query_entities(\"match.dem\", max_entities=100)\n\n# Find low health heroes\nlow_health = [\n    e for e in result.entities\n    if \"Hero\" in e.class_name\n    and e.properties.get(\"m_iHealth\", 0) &lt; 500\n]\n</code></pre>"},{"location":"reference/entities/#property-name-patterns","title":"Property Name Patterns","text":"<p>Properties follow Source 2 naming conventions:</p> Prefix Meaning Example <code>m_i</code> Integer <code>m_iHealth</code> <code>m_fl</code> Float <code>m_flMana</code> <code>m_b</code> Boolean <code>m_bIsAlive</code> <code>m_sz</code> String <code>m_szName</code> <code>m_vec</code> Vector <code>m_vecOrigin</code> <code>m_ang</code> Angle <code>m_angRotation</code> <code>m_h</code> Handle <code>m_hAbilities</code> <code>m_n</code> Enum/Int <code>m_nGameState</code>"},{"location":"reference/entities/#result-metadata","title":"Result Metadata","text":"<p><code>EntitiesResult</code> includes:</p> Field Type Description <code>entities</code> <code>List[EntityData]</code> Entity data <code>total_entities</code> <code>int</code> Count of entities returned <code>tick</code> <code>int</code> Tick when captured <code>net_tick</code> <code>int</code> Network tick when captured <code>success</code> <code>bool</code> Parse success flag <code>error</code> <code>Optional[str]</code> Error message if failed"},{"location":"reference/game-events/","title":"Game Events Reference","text":"AI Summary <p>Complete reference for 364 Source 1 legacy game events in Dota 2 replays. Events are organized by category: Player (kills, denies, abilities), Unit (towers, barracks, roshan), Item (purchases, pickups), Rune (spawns, activations), Game State (match events), and Combat (combatlog). Use <code>parse_game_events()</code> with <code>capture_types=True</code> to discover all available events in a replay.</p>"},{"location":"reference/game-events/#event-categories","title":"Event Categories","text":""},{"location":"reference/game-events/#player-events","title":"Player Events","text":"Event Name Description Key Fields <code>dota_player_kill</code> Player killed another player <code>victim_userid</code>, <code>killer1_userid</code>, <code>killer2_userid</code>-<code>killer5_userid</code> <code>dota_player_deny</code> Player denied a unit <code>killer_userid</code>, <code>denied_userid</code> <code>dota_player_pick_hero</code> Player picked a hero <code>player</code>, <code>heroindex</code>, <code>hero</code> <code>dota_player_learned_ability</code> Player learned an ability <code>player</code>, <code>abilityname</code> <code>dota_player_used_ability</code> Player used an ability <code>player</code>, <code>abilityname</code> <code>dota_player_gained_level</code> Player leveled up <code>player</code>, <code>level</code> <code>dota_player_take_tower_damage</code> Player took tower damage <code>player</code>, <code>damage</code> <code>dota_player_update_hero_selection</code> Hero selection updated <code>player</code> <code>dota_player_update_selected_unit</code> Selected unit changed <code>player</code> <code>dota_player_update_query_unit</code> Query unit changed <code>player</code> <code>dota_player_update_killcam_unit</code> Killcam unit changed <code>player</code>"},{"location":"reference/game-events/#unit-events","title":"Unit Events","text":"Event Name Description Key Fields <code>dota_tower_kill</code> Tower destroyed <code>killer_userid</code>, <code>teamnumber</code>, <code>gold</code> <code>dota_barracks_kill</code> Barracks destroyed <code>killer_userid</code>, <code>teamnumber</code> <code>dota_roshan_kill</code> Roshan killed <code>teamnumber</code> <code>dota_courier_lost</code> Courier killed <code>teamnumber</code> <code>dota_npc_goal_reached</code> NPC reached goal <code>npc_entindex</code> <code>dota_hero_swap</code> Heroes swapped <code>playerid1</code>, <code>playerid2</code>"},{"location":"reference/game-events/#item-events","title":"Item Events","text":"Event Name Description Key Fields <code>dota_item_purchased</code> Item purchased <code>userid</code>, <code>itemname</code> <code>dota_item_combined</code> Items combined <code>userid</code>, <code>itemname</code> <code>dota_item_picked_up</code> Item picked up <code>userid</code>, <code>itemname</code> <code>dota_inventory_changed</code> Inventory changed <code>userid</code> <code>dota_item_given</code> Item given to another <code>userid</code>, <code>itemname</code>, <code>recipientuserid</code>"},{"location":"reference/game-events/#rune-events","title":"Rune Events","text":"Event Name Description Key Fields <code>dota_rune_activated</code> Rune activated <code>player_id</code>, <code>rune</code> <code>dota_rune_spawned</code> Rune spawned <code>rune</code>, <code>pos_x</code>, <code>pos_y</code>, <code>pos_z</code> <code>dota_bounty_rune_pickup</code> Bounty rune picked up <code>player_id</code>, <code>team</code>, <code>gold</code> <code>dota_neutral_token_pickup</code> Neutral token picked up <code>player_id</code>"},{"location":"reference/game-events/#game-state-events","title":"Game State Events","text":"Event Name Description Key Fields <code>dota_match_done</code> Match ended <code>winningteam</code>, <code>radiant_score</code>, <code>dire_score</code> <code>dota_game_state_change</code> Game state changed <code>old_state</code>, <code>new_state</code> <code>game_rules_state_change</code> Game rules changed <code>state</code> <code>dota_team_kill_credit</code> Team credited with kill <code>killer_userid</code>, <code>victim_userid</code>, <code>teamnumber</code> <code>dota_aegis_event</code> Aegis event <code>player_id</code>, <code>event</code> <code>dota_buyback</code> Player bought back <code>player_id</code>, <code>cost</code> <code>dota_glyph_used</code> Glyph activated <code>teamnumber</code>"},{"location":"reference/game-events/#combat-events","title":"Combat Events","text":"Event Name Description Key Fields <code>dota_combatlog</code> Combat log entry <code>type</code>, <code>sourcename</code>, <code>targetname</code>, <code>value</code> <code>dota_player_take_tower_damage</code> Tower damage taken <code>player</code>, <code>damage</code>"},{"location":"reference/game-events/#event-field-types","title":"Event Field Types","text":"<p>Fields in game events are automatically typed:</p> Go Type Python Type Example <code>string</code> <code>str</code> <code>\"npc_dota_hero_axe\"</code> <code>float</code> <code>float</code> <code>123.456</code> <code>long</code> <code>int</code> <code>1234567890</code> <code>short</code> <code>int</code> <code>12345</code> <code>byte</code> <code>int</code> <code>255</code> <code>bool</code> <code>bool</code> <code>True</code> <code>uint64</code> <code>int</code> <code>76561198012345678</code>"},{"location":"reference/game-events/#discovering-events","title":"Discovering Events","text":"<p>Get all event types available in a replay:</p> <pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_game_events(\"match.dem\", capture_types=True, max_events=0)\n\nprint(f\"Total event types: {len(result.event_types)}\")\nfor event_type in sorted(result.event_types):\n    print(f\"  {event_type}\")\n</code></pre>"},{"location":"reference/game-events/#common-event-patterns","title":"Common Event Patterns","text":""},{"location":"reference/game-events/#kill-events","title":"Kill Events","text":"<pre><code># dota_player_kill fields\n{\n    \"victim_userid\": int,      # Victim player ID\n    \"killer1_userid\": int,     # Primary killer\n    \"killer2_userid\": int,     # Assist 1 (optional)\n    \"killer3_userid\": int,     # Assist 2 (optional)\n    \"killer4_userid\": int,     # Assist 3 (optional)\n    \"killer5_userid\": int,     # Assist 4 (optional)\n}\n</code></pre>"},{"location":"reference/game-events/#tower-kill-events","title":"Tower Kill Events","text":"<pre><code># dota_tower_kill fields\n{\n    \"killer_userid\": int,      # Killer player ID\n    \"teamnumber\": int,         # 2=Radiant, 3=Dire (tower team)\n    \"gold\": int,               # Gold awarded\n}\n</code></pre>"},{"location":"reference/game-events/#combatlog-events","title":"Combatlog Events","text":"<pre><code># dota_combatlog fields\n{\n    \"type\": int,               # Combat log type\n    \"sourcename\": str,         # Source unit\n    \"targetname\": str,         # Target unit\n    \"value\": int,              # Damage/heal amount\n}\n</code></pre>"},{"location":"reference/game-events/#all-364-event-types","title":"All 364 Event Types","text":"<p>Use <code>capture_types=True</code> to get the complete list for your specific replay. The actual events available depend on the game version and what occurred during the match.</p> <p>Common categories include:</p> <ul> <li><code>dota_player_*</code> - Player actions</li> <li><code>dota_npc_*</code> - NPC actions</li> <li><code>dota_item_*</code> - Item events</li> <li><code>dota_rune_*</code> - Rune events</li> <li><code>dota_tower_*</code> - Tower events</li> <li><code>dota_roshan_*</code> - Roshan events</li> <li><code>dota_game_*</code> - Game state events</li> <li><code>dota_tutorial_*</code> - Tutorial events</li> <li><code>dota_ability_*</code> - Ability events</li> <li><code>game_*</code> - Engine game events</li> </ul>"},{"location":"reference/modifiers/","title":"Modifiers Reference","text":"AI Summary <p>Reference for parsing buff and debuff modifiers from Dota 2 replays. Modifiers are effects applied to units including stuns, slows, auras, and ability effects. Each modifier has parent entity, caster, ability source, duration, stack count, and aura/debuff flags. Use <code>parse_modifiers()</code> to capture modifier events with optional filtering by modifier class.</p>"},{"location":"reference/modifiers/#modifier-entry-fields","title":"Modifier Entry Fields","text":"<p>Every <code>ModifierEntry</code> contains:</p> Field Type Description <code>tick</code> <code>int</code> Game tick when captured <code>net_tick</code> <code>int</code> Network tick <code>parent</code> <code>int</code> Entity handle of unit with modifier <code>caster</code> <code>int</code> Entity handle of unit that applied modifier <code>ability</code> <code>int</code> Ability handle that created modifier <code>modifier_class</code> <code>int</code> Modifier class ID <code>serial_num</code> <code>int</code> Serial number for tracking <code>index</code> <code>int</code> Modifier index on the unit <code>creation_time</code> <code>float</code> Game time when modifier was created <code>duration</code> <code>float</code> Duration in seconds (-1 = permanent) <code>stack_count</code> <code>int</code> Number of stacks <code>is_aura</code> <code>bool</code> Whether this is an aura effect <code>is_debuff</code> <code>bool</code> Whether this is a debuff"},{"location":"reference/modifiers/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.parse_modifiers(\"match.dem\", max_modifiers=100)\n\nfor mod in result.modifiers:\n    duration_str = f\"{mod.duration}s\" if mod.duration &gt;= 0 else \"permanent\"\n    buff_type = \"debuff\" if mod.is_debuff else \"buff\"\n    aura_str = \" (aura)\" if mod.is_aura else \"\"\n\n    print(f\"Entity {mod.parent}: {buff_type}{aura_str}, duration={duration_str}, stacks={mod.stack_count}\")\n</code></pre>"},{"location":"reference/modifiers/#filtering-by-class","title":"Filtering by Class","text":"<pre><code># Filter by specific modifier class IDs\nresult = parser.parse_modifiers(\"match.dem\", modifier_class_filter=[1, 5, 10], max_modifiers=100)\n</code></pre>"},{"location":"reference/modifiers/#duration-values","title":"Duration Values","text":"Duration Meaning <code>-1</code> Permanent modifier (e.g., passive abilities) <code>0</code> Instant effect <code>&gt; 0</code> Timed duration in seconds"},{"location":"reference/modifiers/#common-modifier-types","title":"Common Modifier Types","text":"<p>Modifiers represent various game effects:</p>"},{"location":"reference/modifiers/#crowd-control","title":"Crowd Control","text":"<ul> <li>Stuns</li> <li>Silences</li> <li>Hexes</li> <li>Roots</li> <li>Disarms</li> </ul>"},{"location":"reference/modifiers/#buffs","title":"Buffs","text":"<ul> <li>Damage amplification</li> <li>Attack speed bonuses</li> <li>Move speed bonuses</li> <li>Armor bonuses</li> </ul>"},{"location":"reference/modifiers/#debuffs","title":"Debuffs","text":"<ul> <li>Damage reduction</li> <li>Slows</li> <li>Break effects</li> <li>Mutes</li> </ul>"},{"location":"reference/modifiers/#auras","title":"Auras","text":"<ul> <li>Team auras (from items like Vladmir's Offering)</li> <li>Hero auras (from abilities like Drow Ranger's Precision Aura)</li> <li>Building auras</li> </ul>"},{"location":"reference/modifiers/#entity-handles","title":"Entity Handles","text":"<p>The <code>parent</code>, <code>caster</code>, and <code>ability</code> fields are entity handles. To resolve these to actual entities, use <code>query_entities()</code>:</p> <pre><code># Get modifier data\nmods = parser.parse_modifiers(\"match.dem\", max_modifiers=50)\n\n# Get entity data at same tick\nentities = parser.query_entities(\"match.dem\", tick=mods.modifiers[0].tick)\n\n# Match entity handles to entity data\nfor mod in mods.modifiers:\n    parent_entity = next(\n        (e for e in entities.entities if e.index == mod.parent),\n        None\n    )\n    if parent_entity:\n        print(f\"Modifier on {parent_entity.class_name}\")\n</code></pre>"},{"location":"reference/modifiers/#stack-count","title":"Stack Count","text":"<p><code>stack_count</code> indicates:</p> Value Meaning <code>0</code> No stacking / single application <code>1+</code> Current number of stacks <p>Some abilities that use stacking: - Flesh Heap (Pudge) - Counter Helix (Axe) proc counter - Essence Shift (Slark) stacks - Silencer's Intelligence Steal</p>"},{"location":"reference/string-tables/","title":"String Tables Reference","text":"AI Summary <p>Reference for string tables in Dota 2 replays. String tables store key-value mappings for names, abilities, items, models, and other game data. Use <code>get_string_tables()</code> to retrieve all tables or filter by name. Common tables include <code>userinfo</code> (player info), <code>ActiveModifiers</code> (buff names), <code>CombatLogNames</code> (unit names), and <code>EntityNames</code>.</p>"},{"location":"reference/string-tables/#string-table-structure","title":"String Table Structure","text":"<p>Every <code>StringTableData</code> entry contains:</p> Field Type Description <code>table_name</code> <code>str</code> Name of the table <code>index</code> <code>int</code> Entry index in table <code>key</code> <code>str</code> Entry key <code>value</code> <code>Optional[str]</code> Entry value (may be binary/base64)"},{"location":"reference/string-tables/#basic-usage","title":"Basic Usage","text":"<pre><code>from python_manta import MantaParser\n\nparser = MantaParser()\nresult = parser.get_string_tables(\"match.dem\")\n\nprint(f\"Tables found: {result.table_names}\")\nprint(f\"Total entries: {result.total_entries}\")\n\nfor table_name, entries in result.tables.items():\n    print(f\"\\n{table_name}: {len(entries)} entries\")\n    for entry in entries[:5]:  # First 5 entries\n        print(f\"  [{entry.index}] {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#common-tables","title":"Common Tables","text":""},{"location":"reference/string-tables/#userinfo","title":"userinfo","text":"<p>Player information including Steam IDs and names.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\nfor entry in result.tables.get(\"userinfo\", []):\n    print(f\"Player {entry.index}: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#combatlognames","title":"CombatLogNames","text":"<p>Names used in combat log entries (heroes, abilities, items).</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"CombatLogNames\")\n\nfor entry in result.tables.get(\"CombatLogNames\", []):\n    print(f\"[{entry.index}] {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#activemodifiers","title":"ActiveModifiers","text":"<p>Active modifier/buff names in the game.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"ActiveModifiers\")\n\nfor entry in result.tables.get(\"ActiveModifiers\", []):\n    print(f\"Modifier: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#entitynames","title":"EntityNames","text":"<p>Entity names used in the replay.</p> <pre><code>result = parser.get_string_tables(\"match.dem\", table_filter=\"EntityNames\")\n\nfor entry in result.tables.get(\"EntityNames\", []):\n    print(f\"Entity: {entry.key}\")\n</code></pre>"},{"location":"reference/string-tables/#all-table-names","title":"All Table Names","text":"<p>Common string tables found in Dota 2 replays:</p> Table Name Description <code>userinfo</code> Player information <code>server_query_info</code> Server query data <code>instancebaseline</code> Entity baselines <code>lightstyles</code> Light styles <code>CombatLogNames</code> Names for combat log <code>ActiveModifiers</code> Active modifier names <code>EntityNames</code> Entity name mappings <code>soundprecache</code> Sound precache <code>decalprecache</code> Decal precache <code>genericprecache</code> Generic precache"},{"location":"reference/string-tables/#filtering","title":"Filtering","text":"<pre><code># Get specific table\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\n# Get multiple tables (run multiple calls)\ntables_needed = [\"userinfo\", \"CombatLogNames\", \"EntityNames\"]\nall_data = {}\n\nfor table in tables_needed:\n    result = parser.get_string_tables(\"match.dem\", table_filter=table)\n    all_data[table] = result.tables.get(table, [])\n</code></pre>"},{"location":"reference/string-tables/#binary-values","title":"Binary Values","text":"<p>Some string table values contain binary data encoded as base64. These typically appear in:</p> <ul> <li><code>instancebaseline</code> - Entity baseline data</li> <li>Some precache tables</li> </ul> <pre><code>import base64\n\nfor entry in result.tables.get(\"somtable\", []):\n    if entry.value:\n        try:\n            decoded = base64.b64decode(entry.value)\n            # Process binary data\n        except:\n            # Plain string value\n            pass\n</code></pre>"},{"location":"reference/string-tables/#use-cases","title":"Use Cases","text":""},{"location":"reference/string-tables/#player-name-resolution","title":"Player Name Resolution","text":"<pre><code># Get player names\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"userinfo\")\n\nplayer_names = {}\nfor entry in result.tables.get(\"userinfo\", []):\n    player_names[entry.index] = entry.key\n\n# Use with other parsed data\nfor entity in entities:\n    player_id = entity.properties.get(\"m_iPlayerID\")\n    if player_id in player_names:\n        print(f\"Hero owned by {player_names[player_id]}\")\n</code></pre>"},{"location":"reference/string-tables/#combat-log-name-resolution","title":"Combat Log Name Resolution","text":"<pre><code># Get name mappings\nresult = parser.get_string_tables(\"match.dem\", table_filter=\"CombatLogNames\")\n\nname_lookup = {entry.index: entry.key for entry in result.tables.get(\"CombatLogNames\", [])}\n\n# Resolve combat log names\nfor log_entry in combat_log:\n    attacker = name_lookup.get(log_entry.attacker_id, \"Unknown\")\n    target = name_lookup.get(log_entry.target_id, \"Unknown\")\n</code></pre>"},{"location":"reference/string-tables/#result-metadata","title":"Result Metadata","text":"<p><code>StringTablesResult</code> includes:</p> Field Type Description <code>tables</code> <code>Dict[str, List[StringTableData]]</code> Table name -&gt; entries <code>table_names</code> <code>List[str]</code> List of all table names <code>total_entries</code> <code>int</code> Total entries across all tables <code>success</code> <code>bool</code> Parse success flag <code>error</code> <code>Optional[str]</code> Error message if failed"}]}